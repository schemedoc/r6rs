\documentclass[twoside]{algol60}
%\documentclass[twoside,twocolumn]{algol60}

\usepackage{verbatim}

\input{commands}

\makeindex

\begin{document}

\chapter{Hash tables and hash functions}

% FIXME: intro

\section{Hash tables}

\subsection{Constructors}

% FIXME \mainindex{hashtable}

\begin{entry}{%
\proto{make-eq-hash-table}{}{}
\proto{make-eq-hash-table}{ \var{k}}}

Returns a newly allocated hash table that accepts arbitrary objects as keys, 
and compares those keys with {\cf eq?}. If an argument is given, then the initial 
capacity of the hash table is set to \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-eqv-hash-table}{}{}
\proto{make-eqv-hash-table}{ \var{k}}}

Returns a newly allocated hash table that accepts arbitrary objects as keys, 
and compares those keys with {\cf eqv?}. If an argument is given, then the initial 
capacity of the hash table is set to \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-hash-table}{ \vari{procedure} \varii{procedure}}{}
\proto{make-hash-table}{ \vari{procedure} \varii{procedure} \var{k}}}

Returns a newly allocated mutable hash table using \vari{procedure} 
as the hash function and \varii{procedure} as the procedure used to 
compare keys.  The hash function must accept a key and return a 
non-negative exact integer. If a third argument is given, then the 
initial capacity of the hash table is set to \var{k} elements.

\end{entry}

\subsection{Procedures}

\begin{entry}{%
\proto{hash-table?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} was created by one of the hash table constructors, otherwise returns \schfalse.
\end{entry}

\begin{entry}{\proto{hash-table-size}{ \var{hash-table}}}
Returns the number of keys contained in \var{hash-table} as an exact integer.
\end{entry}

\begin{entry}{%
\proto{hash-table-ref}{ \var{hash-table} \var{key} \var{default}}}
Returns the value in \var{hash-table} associated with \var{key}.  If \var{hash-table} does not contain an association for \var{key}, then \var{default} is returned.
\end{entry}

\begin{entry}{\proto{hash-table-set!}{ \var{hash-table} \var{key} \var{value}}}
Changes \var{hash-table} to associate \var{key} with value, replacing any existing association for \var{key}. Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-delete!}{ \var{hash-table} \var{key}}}
Removes any association for \var{key} within \var{hash-table}.  Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-contains?}{ \var{hash-table} \var{key}}}
Returns \schtrue{} if \var{hash-table} contains an association for \var{key}, otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{%
\proto{hash-table-update!}{ \var{hash-table} \var{procedure} \var{default}}}
Equivalent to:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref
             hash-table key default)))
\end{scheme}

If \var{hash-table} does not contain an association for \var{key}, then \var{default} is passed to \var{procedure}.
\end{entry}

\begin{entry}{\proto{hash-table-update!/call}{ \var{hash-table} \var{procedure} \var{f}}}
Equivalent to, but potentially more efficient than:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref/call [TODO: non-existent procedure]
             hash-table key f)))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-fold}{ \var{hash-table} \var{procedure} \var{init}}}
For every association in \var{hash-table}, calls \var{procedure} with three arguments: the association key, the association value, and an accumulated value. The accumulated value is \var{init} for the first invocation of \var{procedure}, and for subsequent invocations of \var{procedure}, it is the return value of the previous invocation of \var{procedure}. The order of the calls to \var{procedure} is indeterminate. The return value of {\cf hash-table-fold} is the value of the last invocation of \var{procedure}. If any side effect is performed on the hash table while a {\cf hash-table-fold} operation is in progress, then the behavior of {\cf hash-table-fold} is unspecified.

\end{entry}

\begin{entry}{%
\proto{hash-table-copy}{ \var{hash-table}}{}
\proto{hash-table-copy}{ \var{hash-table} \var{immutable}}}

Returns a copy of \var{hash-table}.  If the \var{immutable} argument is provided and is a true value, the returned hash table will be immutable, otherwise it will be mutable.

\end{entry}

\begin{entry}{\proto{hash-table-clear!}{ \var{hash-table}}}
Removes all associations from \var{hash-table}.  Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-for-each}{ \var{procedure} \var{hash-table}}}
For every association in \var{hash-table}, calls \var{procedure} with two arguments: the association key and the association value. The \var{procedure} is called once for each association in hash-table. The order of these calls is indeterminate. If any side effect is performed on the hash table while a {\cf hash-table-for-each} operation is in progress, then the behavior of {\cf hash-table-for-each} is unspecified. The return value of {\cf hash-table-for-each} is the unspecified value.

Equivalent to:
\begin{scheme}
(hash-table-fold hash-table 
                 (lambda (k v a)
                   (procedure k v))
                 (unspecified))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table->alist}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table
                 (lambda (k v a) 
                   (cons (cons k v) a))
                 '())
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-keys}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table 
                 (lambda (k v a) (cons k a)) 
                 '())
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-values}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table
                 (lambda (k v a) (cons v a)) 
                 '())
\end{scheme}
\end{entry}

\subsection{Reflection}

\begin{entry}{\proto{hash-table-equivalence-predicate}{ \var{hash-table}}}
Returns the equivalence predicate used by \var{hash-table} to compare keys.  For hash tables created with {\cf make-eq-hash-table} and {\cf make-eqv-hash-table}, returns {\cf eq?} and {\cf eqv?} respectively.
\end{entry}

\begin{entry}{\proto{hash-table-hash-function}{ \var{hash-table}}}
Returns the hash function used by hash-table.  For hash tables created by {\cf make-eq-hash-table} or {\cf make-eqv-hash-table}, \schfalse{} is returned.
\end{entry}

\begin{entry}{\proto{hash-table-mutable?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} is mutable, \schfalse{} otherwise.
\end{entry}

\section{Hash functions}

\begin{entry}{\proto{equal-hash}{ \var{obj}}}
Returns an integer hash value for \var{obj}, based on its structure and current contents.
\end{entry}

\begin{entry}{\proto{string-hash}{ \var{string}}}
Returns an integer hash value for \var{string}, based on its current contents.
\end{entry}

\begin{entry}{\proto{string-ci-hash}{ \var{string}}}
Returns an integer hash value for \var{string} based on its current contents, ignoring case.
\end{entry}

\begin{entry}{\proto{symbol-hash}{ \var{symbol}}}
Returns an integer hash value for \var{symbol}.
\end{entry}

\section{Issues}

\subsection{Limit proposal scope}
Should the specification be limited to eq and eqv hash tables, since those are the only kind which may not be implementable as a portable library? (Editors straw-poll: no)

\subsection{Complexity}
It may be appropriate to specify constraints on complexity, such as constant time for hash-table-size, or an appropriate constraint on accessor procedures.

\subsection{Concurrency}
R6RS does not deal with concurrency.  Even if this proposal does not say anything about that, the issue should be considered.  Any implementation that supports concurrency will have to implement some kind of mutual exclusion for operations that have side effects, and some will need mutual exclusion even for {\cf hash-table-ref}.  As specified, the updating operations are not atomic, so they create no new problems.  The {\cf hash-table-fold} and {\cf hash-table-for-each} procedures already have a problem, even without concurrency.

\subsection{Omit hash-table-update!}
Are the functional update procedures {\cf hash-table-update!} and 
{\cf hash-table-update!/call} justified?

\subsection{Side-effects}
There is a potential problem with the higher-order procedures, if a procedure argument mutates the hash table being operated on.  This should be addressed somehow, if only by a statement that the behavior caused by such procedures is unspecified.

\subsection{hash-table-map}
This has been omitted because a single appropriate specification is not obvious, and any reasonable specification can easily be implemented in terms of {\cf hash-table-fold}.

\subsection{Names}
Should the type name be {\cf hash-table}, {\cf hashtable}, or something else?


% FIXME References: Larceny; SRFI 69; MIT Scheme; Feeley's proposal; Serrano's proposal
% Mention SRFI 44?

\end{document}
