\documentclass[twoside]{algol60}
%\documentclass[twoside,twocolumn]{algol60}

\usepackage{verbatim}

\input{commands}

\makeindex

\begin{document}

\chapter{Hash tables and hash functions}

% FIXME: intro

\section{Hash tables}

\subsection{Constructors}

% FIXME \mainindex{hashtable}

\begin{entry}{%
\proto{make-eq-hash-table}{}{}}

Returns a newly allocated hash table that accepts arbitrary objects 
as keys, and compares those keys with eq?

\end{entry}

\begin{entry}{%
\proto{make-eqv-hash-table}{}{}}

Returns a newly allocated hash table that accepts arbitrary objects 
as keys, and compares those keys with eqv?

\end{entry}

\begin{entry}{%
\proto{make-hash-table}{ \vari{procedure} \varii{procedure}}{}}

Returns a newly allocated mutable hash table using \vari{procedure} 
as the hash function and \varii{procedure} as the procedure used to 
compare keys.  The hash function must accept a key and return a 
non-negative exact integer.

\end{entry}

\subsection{Procedures}

\begin{entry}{%
\proto{hash-table?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} was created by one of the hash table constructors, otherwise returns \schfalse.
\end{entry}

\begin{entry}{\proto{hash-table-size}{ \var{hash-table}}}
Returns the number of keys contained in \var{hash-table} as an exact integer.
\end{entry}

\begin{entry}{\proto{hash-table-ref}{ \var{hash-table} \var{key}}}
Returns the value in the hash-table associated with \var{key}.  If the hash table does not contain \var{key}, an exception is raised. [TODO: hash table exception types]
\end{entry}

\begin{entry}{\proto{hash-table-ref/default}{ \var{hash-table} \var{key} \var{default}}}
Returns the value in the hash-table associated with the \var{key}.  If the hash table does not contain \var{key}, returns \var{default}.
\end{entry}

\begin{entry}{\proto{hash-table-ref/call}{ \var{hash-table} \var{key} \var{f}}}
Returns the value associated with \var{key} in \var{hash-table} if the hash table contains \var{key}; otherwise tail-calls \var{f} on key.
\end{entry}

\begin{entry}{\proto{hash-table-ref/thunk}{ \var{hash-table} \var{key} \var{thunk}}}
Returns the value associated with \var{key} in \var{hash-table} if the hash table contains \var{key}; otherwise tail-calls \var{thunk}.
\end{entry}

\begin{entry}{\proto{hash-table-get}{ \var{hash-table} \var{key}}}
Equivalent to: \begin{scheme}(hash-table-ref/default hash-table key \schfalse)\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-set!}{ \var{hash-table} \var{key} \var{value}}}
Changes \var{hash-table} to associate \var{key} with value, replacing any existing association for \var{key}. Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-delete!}{ \var{hash-table} \var{key}}}
Removes any association for \var{key} within \var{hash-table}.  Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-contains?}{ \var{hash-table} \var{key}}}
Returns \schtrue{} if \var{hash-table} contains an entry for \var{key}, otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{\proto{hash-table-update!}{ \var{hash-table} \var{procedure}}}
Equivalent to:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref hash-table key)))
\end{scheme}
Raises an exception if \var{hash-table} does not contain an entry for \var{key}.
\end{entry}

\begin{entry}{\proto{hash-table-update!/default}{ \var{hash-table}
                                                  \var{procedure}
                                                  \var{default}}}
Equivalent to, but potentially more efficient than:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref/default
             hash-table key default)))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-update!/thunk}{ \var{hash-table} \var{procedure} \var{thunk}}}
Equivalent to, but potentially more efficient than:
\begin{scheme}
(hash-table-set! 
 hash-table key
 (procedure (hash-table-ref/thunk 
             hash-table key thunk)))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-update!/call}{ \var{hash-table} \var{procedure} \var{f}}}
Equivalent to, but potentially more efficient than:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref/call 
             hash-table key f)))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-fold}{ \var{hash-table} \var{procedure} \var{init}}}
For every association in \var{hash-table}, calls \var{procedure} with three arguments: the association key, the association value, and an accumulated value. The accumulated value is \var{init} for the first invocation of \var{procedure}, and for subsequent invocations of \var{procedure}, the return value of the previous invocation of \var{procedure}. The return value of {\cf hash-table-fold} is the value of the last invocation of procedure. If any side effect is performed on the hash table while a {\cf hash-table-fold} operation is in progress, then the behavior of {\cf hash-table-fold} is unspecified.

\end{entry}

\begin{entry}{\proto{hash-table-copy}{ \var{hash-table}}}
Returns a copy of \var{hash-table}.
\end{entry}

\begin{entry}{\proto{hash-table-clear!}{ \var{hash-table}}}
Removes all associations from \var{hash-table}.  Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-for-each}{ \var{procedure} \var{hash-table}}}
For every association in \var{hash-table}, calls \var{procedure} with two arguments: the association key and the association value. The \var{procedure} is called once for each association in hash-table. The order of these calls is indeterminate. If any side effect is performed on the hash table while a {\cf hash-table-for-each} operation is in progress, then the behavior of {\cf hash-table-for-each} is unspecified. The return value of {\cf hash-table-for-each} is the unspecified value.

Equivalent to:
\begin{scheme}
(hash-table-fold hash-table 
                 (lambda (k v a)
                   (procedure k v))
                 (unspecified))
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table->alist}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table
                 (lambda (k v a) 
                   (cons (cons k v) a))
                 '())
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-keys}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table 
                 (lambda (k v a) (cons k a)) 
                 '())
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-values}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold hash-table
                 (lambda (k v a) (cons v a)) 
                 '())
\end{scheme}
\end{entry}

\subsection{Reflection}

\begin{entry}{\proto{hash-table-equivalence-predicate}{ \var{hash-table}}}
Returns the equivalence predicate used by \var{hash-table} to compare keys.  For hash tables created with {\cf make-eq-hash-table} and {\cf make-eqv-hash-table}, returns {\cf eq?} and {\cf eqv?} respectively.
\end{entry}

\begin{entry}{\proto{hash-table-hash-function}{ \var{hash-table}}}
Returns the hash function used by hash-table.  For hash tables created by {\cf make-eq-hash-table} or {\cf make-eqv-hash-table}, \schfalse{} is returned.
\end{entry}

\begin{entry}{\proto{hash-table-mutable?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} is mutable, \schfalse{} otherwise.
\end{entry}

\section{Hash functions}

\begin{entry}{\proto{equal-hash}{ \var{obj}}}
Returns an integer hash value for \var{obj}, based on its structure and current contents.
\end{entry}

\begin{entry}{\proto{string-hash}{ \var{string}}}
Returns an integer hash value for \var{string}, based on its current contents.
\end{entry}

\begin{entry}{\proto{string-ci-hash}{ \var{string}}}
Returns an integer hash value for \var{string} based on its current contents, ignoring case.
\end{entry}

\begin{entry}{\proto{symbol-hash}{ \var{symbol}}}
Returns an integer hash value for \var{symbol}.
\end{entry}

\section{Issues}

\subsection{Limit proposal scope}
Should the specification be limited to eq and eqv hash tables, since those are the only kind which may not be implementable as a portable library?

\subsection{Immutability}
The proposal should probably support immutable hash tables, which can be constructed from a provided assoc list.  The appropriate constructor(s) need to be defined, supporting the various hash table options, preferably without doubling the number of constructors.

\subsection{Complexity}
It may be appropriate to specify constraints on complexity, such as constant time for hash-table-size, or an appropriate constraint on accessor procedures.

\subsection{Concurrency}
R6RS does not deal with concurrency.  Even if this proposal does not say anything about that, the issue should be considered.  Any implementation that supports concurrency will have to implement some kind of mutual exclusion for operations that have side effects, and some will need mutual exclusion even for {\cf hash-table-ref}.  As specified, the updating operations are not atomic, so they create no new problems.  The {\cf hash-table-fold} and {\cf hash-table-for-each} procedures already have a problem, even without concurrency.

\subsection{Omission of procedures}
Some procedures could perhaps be omitted, e.g. there are four retrieval procedures.  Which one(s) should be omitted, if any?  Procedures which take failure thunks are candidates for omission.

\subsection{Side-effects}
There is a potential problem with the higher-order procedures, if a procedure argument mutates the hash table being operated on.  This should be addressed somehow, if only by a statement that the behavior caused by such procedures is unspecified.

\subsection{hash-table-map}
This has been omitted because a single appropriate specification is not obvious, and any reasonable specification can easily be implemented in terms of {\cf hash-table-fold}.

\subsection{Names}
Should the type name be {\cf hash-table}, {\cf hashtable}, or something else?


% FIXME References: Larceny; SRFI 69; MIT Scheme; Feeley's proposal; Serrano's proposal
% Mention SRFI 44?

\end{document}
