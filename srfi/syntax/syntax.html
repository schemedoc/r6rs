<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>R6RS Syntax-Case Macros</title>

<style type="text/css">
<!--
 a:link, a:active, a:visited {color:blue}
 a:hover {color:white; background:blue}
 a.plain:link, a.plain:active, a.plain:visited {color:blue; text-decoration:none}
 a.plain:hover {color:white; text-decoration:none; background:blue}
 table.indent {margin-left: 20px}
 h1 { font-size: 1.75em }
 h2 { font-size: 1.25em }
 h3 { font-size: 1.12em }
 h4 { font-size: 1em }
-->
</style>
</head>
<body>


<p>


<p>
<h1>Title</h1>

<p>
R6RS Syntax-Case Macros

<p>
<h1>Authors</h1>

<p>
Kent Dybvig

<p>
<h1>Status</h1>

<p>
This SRFI is being submitted by a member of the Scheme Language Editor's
Committee as part of the R6RS Scheme standardization process.  The purpose
of such "R6RS SRFIs" is to inform the Scheme community of features and
design ideas under consideration by the editors and to allow the community
to give the editors some direct feedback that will be considered during
the design process.

<p>
At the end of the discussion period, this SRFI will be withdrawn.  When
the R6RS specification is finalized, the SRFI may be revised to conform to
the R6RS specification and then resubmitted with the intent to finalize
it.  This procedure aims to avoid the situation where this SRFI is
inconsistent with R6RS.  An inconsistency between R6RS and this SRFI could
confuse some users.  Moreover it could pose implementation problems for
R6RS compliant Scheme systems that aim to support this SRFI.  Note that
departures from the SRFI specification by the Scheme Language Editor's
Committee may occur due to other design constraints, such as design
consistency with other features that are not under discussion as SRFIs.

<p>
<h1>Table of Contents</h1>

<p>

<table cellpadding=0 cellspacing=0>



<tr><td align="right"><b>1.&nbsp;</b><td><b><a class=plain href="./syntax.html#g0">Abstract</a></b></td></tr>



<tr><td align="right"><b>2.&nbsp;</b><td><b><a class=plain href="./syntax.html#g1">Rationale<a name="sec:rationale"></a></a></b></td></tr>



<tr><td align="right"><b>3.&nbsp;</b><td><b><a class=plain href="./syntax.html#g2">Specification<a name="sec:specification"></a></a></b></td></tr>


<tr><td></td><td><table cellpadding=0 cellspacing=0>
<tr><td><b>3.1.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g3">Expansion Process<a name="sec:expansion"></a></a></b></td></tr>



<tr><td><b>3.2.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g4">Maintaining Hygiene<a name="sec:hygiene"></a></a></b></td></tr>



<tr><td><b>3.3.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g5">Keyword Bindings<a name="sec:bindings"></a></a></b></td></tr>



<tr><td><b>3.4.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g6">Transformers<a name="sec:transformers"></a></a></b></td></tr>



<tr><td><b>3.5.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g7">Syntax objects<a name="sec:syntaxobjects"></a></a></b></td></tr>



<tr><td><b>3.6.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g8">Parsing input and producing output<a name="sec:syntaxcase"></a></a></b></td></tr>



<tr><td><b>3.7.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g9">Identifier predicates<a name="sec:identifierpredicates"></a></a></b></td></tr>



<tr><td><b>3.8.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g10">Syntax-object and datum conversions</a></b></td></tr>



<tr><td><b>3.9.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g11">Generating lists of temporaries<a name="sec:generatingtemporaries"></a></a></b></td></tr>



<tr><td><b>3.10.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g12">Derived forms and procedures<a name="sec:derived"></a></a></b></td></tr>


</table></td></tr>
<tr><td align="right"><b>4.&nbsp;</b><td><b><a class=plain href="./syntax.html#g13">Reference Implementation<a name="sec:implementation"></a></a></b></td></tr>



<tr><td align="right"><b>5.&nbsp;</b><td><b><a class=plain href="./syntax.html#g14">Issues<a name="sec:issues"></a></a></b></td></tr>


<tr><td></td><td><table cellpadding=0 cellspacing=0>
<tr><td><b>5.1.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g15">Library interaction</a></b></td></tr>



<tr><td><b>5.2.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g16">Name changes</a></b></td></tr>



<tr><td><b>5.3.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g17">Top-level keyword bindings</a></b></td></tr>



<tr><td><b>5.4.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g18">Internal keyword definitions</a></b></td></tr>



<tr><td><b>5.5.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g19">Fluid identifiers or bindings</a></b></td></tr>



<tr><td><b>5.6.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g20">Expand-time environment</a></b></td></tr>



<tr><td><b>5.7.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g21">Quasisyntax</a></b></td></tr>



<tr><td><b>5.8.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g22">Fresh syntax</a></b></td></tr>



<tr><td><b>5.9.&nbsp;</b></td><td><b><a class=plain href="./syntax.html#g23">Degree of wrapping</a></b></td></tr>


</table></td></tr>
<tr><td align="right"><b>6.&nbsp;</b><td><b><a class=plain href="./syntax.html#g24">Acknowledgments</a></b></td></tr>



<tr><td align="right"><b>7.&nbsp;</b><td><b><a class=plain href="./syntax.html#g25">References</a></b></td></tr>



<tr><td align="right"><b>8.&nbsp;</b><td><b><a class=plain href="./syntax.html#g26">Copyright</a></b></td></tr>

  
  
 
</table>


<p>

<a name="g0"></a>

<h1><a name="./syntax:h0"></a>1. Abstract</h1>



<p>
The syntactic abstraction system described here extends the R5RS macro
system with support for writing low-level macros in a high-level style,
with automatic syntax checking, input destructuring, output restructuring,
maintenance of lexical scoping and referential transparency (hygiene), and
support for bending or breaking hygiene, with constant expansion overhead.
Because it does not require literals, including quoted lists or vectors,
to be copied or even traversed, it preserves sharing and cycles within and
among the constants of a program.
It also supports source-object correlation, the maintenance of ties
between the original source code and expanded output, allowing
implementations to provide source-level support for debuggers and other
tools.

<p>

<a name="g1"></a>

<h1><a name="./syntax:h1"></a>2. Rationale<a name="sec:rationale"></a></h1>



<p>
While many syntactic abstractions are succinctly expressed using the
high-level <tt>syntax-rules</tt> form, others are difficult or impossible
to write, including some that bend or break lexical scoping and others
that construct new identifiers.
The <tt>syntax-case</tt> system described here allows the programmer to
write arbitrary macros that respect lexical scoping and arbitrary macros
that bend or break lexical scoping, without giving up the advantages of
the high-level pattern-based syntax matching and template-based output
construction provided by R6RS <tt>syntax-rules</tt>.

<p>

<a name="g2"></a>

<h1><a name="./syntax:h2"></a>3. Specification<a name="sec:specification"></a></h1>



<p>
A syntactic abstraction typically takes the form
<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>, where <tt><i>keyword</i></tt> is the
identifier that names the syntactic abstraction.
The syntax of each <tt><i>subform</i></tt> varies from one syntactic abstraction to
another.
Syntactic abstractions can also take the form of improper lists (or even
singleton identifiers; see Section&nbsp;<a href="./syntax.html#g8">3.6</a>), although this is
less common.

<p>
New syntactic abstractions are defined by associating keywords with
<i>transformers</i>.
Keyword bindings are created using <tt>define-syntax</tt>,
<tt>let-syntax</tt>, or <tt>letrec-syntax</tt>.
Transformers are created using <tt>syntax-rules</tt> or
<tt>syntax-case</tt> and <tt>syntax</tt>, which allow transformations to
be specified via pattern matching and template reconstruction.

<p>

<a name="g3"></a>

<h2><a name="./syntax:h3"></a>3.1. Expansion Process<a name="sec:expansion"></a></h2>



<p>
Syntactic abstractions are expanded into core
forms at the start of evaluation (before compilation or interpretation)
by a syntax <i>expander</i>.
(The set of core forms is implementation-dependent, as is the
representation of these forms in the expander's output.)
The expander is invoked once for each top-level form in a program.
If the expander encounters a syntactic abstraction, it invokes
the associated transformer to expand the syntactic abstraction, then
repeats the expansion process for the form returned by the transformer.
If the expander encounters a core form, it recursively
processes the subforms, if any, and reconstructs the form from the
expanded subforms.
Information about identifier bindings is maintained during expansion
to enforce lexical scoping for variables and keywords.

<p>
To handle internal definitions, the expander
processes the initial forms in a <tt>library</tt> or <tt>lambda</tt> body
from left to right.
How the expander processes each form encountered as it does so depends
upon the kind of form.

<p>
<dl compact>
<dt>syntactic abstraction:<dd>
The expander invokes the associated transformer to expand the syntactic abstraction,
then recursively performs whichever of these actions are appropriate
for the resulting form.

<p>
<dt><tt>define-syntax</tt> form:<dd>
The expander expands and evaluates the right-hand-side expression and binds the
keyword to the resulting transformer.

<p>
<dt><tt>define</tt> form:<dd>
The expander records the fact that the defined identifier is a variable but defers
expansion of the right-hand-side expression until after all of the
definitions have been processed.

<p>
<dt><tt>begin</tt> form:<dd>
The expander splices the subforms into the list of body forms it is processing.

<p>
<dt><tt>let-syntax</tt> or <tt>letrec-syntax</tt> form:<dd>
The expander splices the inner body forms into the list of (outer) body forms it is
processing, arranging for the keywords bound by the <tt>let-syntax</tt>
and <tt>letrec-syntax</tt> to be visible only in the inner body forms.

<p>
<dt>expression, i.e., nondefinition:<dd>
The expander completes the expansion of the deferred forms and the current and
remaining expressions in the body.
</dl>

<p>
Expansion of each variable definition right-hand side is deferred until
after all of the definitions have been seen so that each keyword and
variable references within the right-hand side resolves to the local
binding, if any.

<p>
Note that this algorithm does not directly reprocess any form.
It requires a single left-to-right pass over the definitions followed by a
single pass (in any order) over the body expressions and deferred
right-hand sides.
Thus, except where reprocessing occurs independently by the recursive
expansion of transformer output, each input form is processed exactly
once.

<p>
For example, in

<p>

<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(define-syntax&nbsp;defun<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;(x&nbsp;.&nbsp;a)&nbsp;e)&nbsp;(define&nbsp;x&nbsp;(lambda&nbsp;a&nbsp;e))]))<br>

&nbsp;&nbsp;(defun&nbsp;(even?&nbsp;n)&nbsp;(or&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(odd?&nbsp;(-&nbsp;n&nbsp;1))))<br>

&nbsp;&nbsp;(define-syntax&nbsp;odd?&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;n)&nbsp;(not&nbsp;(even?&nbsp;n))]))<br>

&nbsp;&nbsp;(odd?&nbsp;(if&nbsp;(odd?&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x)&nbsp;x)))</tt>
<p>The definition of <tt>defun</tt> is encountered first, and the keyword
<tt>defun</tt> is associated with the transformer resulting from
the expansion and evaluation of the corresponding right-hand side.
A use of <tt>defun</tt> is encountered next and expands into a
<tt>define</tt> form.
Expansion of the right-hand side of this define form is deferred.
The definition of <tt>odd?</tt> is next and results in the association
of the keyword <tt>odd?</tt> with the transformer resulting from
expanding and evaluating the corresponding right-hand side.
A use of <tt>odd?</tt> appears next and is expanded; the resulting
call to <tt>not</tt> is recognized as an expression
because <tt>not</tt> is bound as a variable.
At this point, the expander completes the expansion of the current
expresion (the <tt>not</tt> call) and the defered right-hand side of the
<tt>even?</tt> definition;
the uses of <tt>odd?</tt> appearing in these expressions are expanded
using the transformer associated with the keyword <tt>odd?</tt>.
The final output is the equivalent of

<p>

<p><tt>(lambda&nbsp;(x)<br>

&nbsp;&nbsp;(letrec*&nbsp;([even?&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(not&nbsp;(even?&nbsp;(-&nbsp;n&nbsp;1)))))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;x)))</tt>
<p>although the structure of the output is implementation depenedent.

<p>

<a name="g4"></a>

<h2><a name="./syntax:h4"></a>3.2. Maintaining Hygiene<a name="sec:hygiene"></a></h2>



<p>
The expander maintains lexical scoping and referential transparency
(hygiene) with the help of <i>marks</i> and <i>substitutions</i>.
Marks are applied selectively by the expander to the output of each
transformer it invokes, and substitutions are applied to the portions
of each binding form that are supposed to be within the scope of the bound
identifiers.
Marks are used to distinguish like-named identifiers that are
introduced at different times (either present in the source or introduced
into the output of a transformer), and substitutions are used to
map identifiers to their expand-time values.

<p>
Each time the expander encounters a syntactic abstraction and invokes the
associated transformer, it creates a fresh mark and marks the
<i>introduced</i> portions of the transformer output with this mark,
leaving portions of the output that came from the input unmarked.
(This may be done by applying an <i>antimark</i> to the input, then
applying the fresh mark to the output.
When the mark is applied to antimarked input, the marks cancel, effectively
leaving the portions of the output that came from the input unmarked.)

<p>
Each time the expander encounters a binding form it creates a set of
substitutions, each mapping one of the (possibly marked) bound identifiers
to information about the binding.
(For a <tt>lambda</tt> expression, the expander might map each bound
identifier to a representation of the formal parameter in the output of
the expander.
For a <tt>let-syntax</tt> form, the expander might map each bound
identifier to the associated transformer.)
These subtitutions are applied to the portions of the input form in
which the binding is supposed to be visible.

<p>
Marks and substitutions together form a <i>wrap</i> that is layered on the
form being processed by the expander and pushed down toward the leaves as
necessary.
A wrapped form is referred to as a <i>wrapped syntax object</i>.
Ultimately, the wrap may rest on a leaf that represents an identifier, in
which case the wrapped syntax object is referred to more precisely
as an <i>identifier</i>.
An identifier contains a name along with the wrap.
(Names are typically represented by symbols.)

<p>
When a substitution is created to map an identifier to an expand-time
value, the substitution records the name of the identifier and
the set of marks that have been applied to that identifier, along
with the associated expand-time value.
The expander resolves identifier references by looking for the latest
matching substitution to be applied to the identifier, i.e., the outermost
substitution in the wrap whose name and marks match the name and
marks recorded in the substitution.
The name matches if it is the same name (if using symbols, then by
<tt>eq?</tt>), and the marks match if the marks recorded with the
substitution are the same as those that appear <i>below</i>, i.e.,
were applied <i>before</i> the subsitution in the wrap.
Marks applied after a substitution, i.e., appear over the substitution in
the wrap, are not relevant and are ignored.

<p>

<a name="g5"></a>

<h2><a name="./syntax:h5"></a>3.3. Keyword Bindings<a name="sec:bindings"></a></h2>



<p>
Keyword bindings may be established with <tt>define-syntax</tt>,
<tt>let-syntax</tt>, or <tt>letrec-syntax</tt>.

<p>
A <tt>define-syntax</tt> form is a <tt><i>definition</i></tt> and may appear
anywhere other definitions may appear.
The syntax

<p>

<p><tt>(define-syntax&nbsp;<i>keyword</i>&nbsp;<i>transformer-expr</i>)</tt>
<p>binds <tt><i>keyword</i></tt> to the result of evaluating, at expansion time,
the expression <tt><i>transformer-expr</i></tt>, which must evaluate
to a <i>transformer</i> (Section&nbsp;<a href="./syntax.html#g6">3.4</a>).

<p>
The example below defines <tt>let*</tt> as a syntactic abstraction,
specifying the transformer with <tt>syntax-rules</tt> (see
Section&nbsp;<a href="./syntax.html#g12">3.10</a>).

<p>

<p><tt>(define-syntax&nbsp;let*<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(let&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;([i1&nbsp;v1]&nbsp;[i2&nbsp;v2]&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([i1&nbsp;v1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([i2&nbsp;v2]&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...))]))</tt>
<p>Keyword bindings established by <tt>define-syntax</tt> are visible
throughout the body in which they appear, except where shadowed by
other bindings, and nowhere else, just like variable bindings established
by <tt>define</tt>.
All bindings established by a set of internal definitions, whether
keyword or variable definitions, are visible within the definitions
themselves.
For example, the expression

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1)))))<br>

&nbsp;&nbsp;(define-syntax&nbsp;odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(not&nbsp;(even?&nbsp;x))]))<br>

&nbsp;&nbsp;(even?&nbsp;10))</tt>
<p>is valid and should return <tt>#t</tt>.

<p>
An implication of the left-to-right processing order
(Section&nbsp;<a href="./syntax.html#g3">3.1</a>) is that one internal definition can affect
whether a subsequent form is also a definition.
For example, the expression

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define-syntax&nbsp;bind-to-zero<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;id)&nbsp;(define&nbsp;id&nbsp;0)]))<br>

&nbsp;&nbsp;(bind-to-zero&nbsp;x)<br>

&nbsp;&nbsp;x)</tt>
<p>evaluates to <tt>0</tt>, regardless of any binding for
<tt>bind-to-zero</tt> that might appear outside of the <tt>let</tt>
expression.

<p>
<tt>let-syntax</tt> and <tt>letrec-syntax</tt> are analogous to <tt>let</tt>
and <tt>letrec</tt> but bind keywords rather than variables.
Like <tt>begin</tt>, a <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form
may appear in a definition context, in which case it is treated as a
definition, and the forms in the body of the form must also be
definitions.
A <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.

<p>
The syntax

<p>

<p><tt>(let-syntax&nbsp;((<i>keyword</i>&nbsp;<i>transformer-expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt>
<p>binds the keywords <tt><i>keyword</i>&nbsp;...</tt> to the results of
evaluating, at expansion time, the expressions
<tt><i>transformer-expr</i>&nbsp;...</tt>, which must evaluate to
transformers (Section&nbsp;<a href="./syntax.html#g6">3.4</a>).

<p>
Keyword bindings established by <tt>let-syntax</tt> are visible
throughout the forms in the body of the <tt>let-syntax</tt> form,
except where shadowed, and nowhere else.

<p>
The syntax

<p>

<p><tt>(letrec-syntax&nbsp;((<i>keyword</i>&nbsp;<i>transformer-expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt>
<p>is similar, but the bindings established by <tt>let-syntax</tt> are
also visible within <tt><i>transformer-expr</i>&nbsp;...</tt>.

<p>
The forms in the of a <tt>let-syntax</tt> or <tt>letrec-syntax</tt> are
treated, whether in definition or expression context, as if wrapped in
an implicit <tt>begin</tt>.

<p>
The following example highlights how <tt>let-syntax</tt>
and <tt>letrec-syntax</tt> differ.

<p>

<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(let-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2)
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(letrec-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(1&nbsp;1)</tt>
<p>The two expressions are identical except that the <tt>let-syntax</tt> form
in the first expression is a <tt>letrec-syntax</tt> form in the second.
In the first expression, the <tt>f</tt> occurring in <tt>g</tt> refers to
the <tt>let</tt>-bound variable <tt>f</tt>, whereas in the second it refers
to the keyword <tt>f</tt> whose binding is established by the
<tt>letrec-syntax</tt> form.

<p>
Keywords occupy the same name space as variables, i.e., within the same
scope, an identifier can be bound as a variable or keyword, or neither, but
not both.

<p>

<a name="g6"></a>

<h2><a name="./syntax:h6"></a>3.4. Transformers<a name="sec:transformers"></a></h2>



<p>
A transformer is a <i>transformation procedure</i> or a
<tt><i>variable transformer</i></tt>.
A transformation procedure is a procedure that must accept one
argument, a wrapped syntax object (Section&nbsp;<a href="./syntax.html#g7">3.5</a>)
representing the input, and return a <i>syntax object</i>
(Section&nbsp;<a href="./syntax.html#g7">3.5</a>) representing the output.
The procedure is called by the expander whenever a reference to
a keyword with which it has been associated is found.
If the keyword appears in the first position of a list-structured
input form, the transformer receives the entire list-structured
form, and its output replaces the entire form.
If the keyword is found in any other definition or expression
context, the transformer receives just the keyword reference,
and its output replaces just the reference.
A <tt>&amp;syntax</tt> exception is raised if the keyword appears on the
left-hand side of a <tt>set!</tt> expression.

<p>
Variable transformers are similar.
If a keyword associated with a variable transformer appears on
the left-hand side of a <tt>set!</tt> expression, however, an error
is not signaled.
Instead, the transformer receives a wrapped syntax object representing the
entire <tt>set!</tt> expression as its argument, and its output
replaces the entire <tt>set!</tt> expression.
A variable transformer is created by passing a transformation
procedure to <tt>make-variable-transformer</tt>:

<p>

<p><tt>(make-variable-transformer&nbsp;<i>procedure</i>)</tt>
<p><tt>make-variable-transformer</tt> returns
an implementation-dependent encapsulation of the transformation
procedure that allows the expander to recognize that it is a
variable transformer.

<p>

<a name="g7"></a>

<h2><a name="./syntax:h7"></a>3.5. Syntax objects<a name="sec:syntaxobjects"></a></h2>



<p>
A syntax object is a representation of a Scheme form that contains
contextual information about the form in addition to its structure.
This contextual information is used by the expander to maintain
lexical scoping and may also be used by an implementation to maintain
source-object correlation.

<p>
Syntax objects may be wrapped or unwrapped.
A wrapped syntax object (Section&nbsp;<a href="./syntax.html#g4">3.2</a>), consists of a
<i>wrap</i> (Section&nbsp;<a href="./syntax.html#g4">3.2</a>) and some internal representation
of a Scheme form.
(The internal representation is unspecified, but is typically a Scheme
s-expression or s-expression annotated with source information.)
A wrapped syntax object representing an identifier is itself referred to as
an identifier; thus, the term <i>identifier</i> may refer either to
the syntactic entity (symbol, variable, or keyword) or to the
concrete representation of the syntactic entity as a syntax object.
Wrapped syntax objects are distinct from other types of values.


<p>
An unwrapped syntax object is one that is unwrapped, fully or partially,
i.e., consists at least partly of list, vector, and non-symbol values.

<p>
The term <i>syntax object</i> is used in this document to refer to
a syntax object that is either wrapped or unwrapped.
More formally, a syntax object is:

<p>
<ul>
<li>a pair or list of syntax objects,
<li>a vector of syntax objects,
<li>a nonlist, novector, nonsymbol value, or
<li>a wrapped syntax object.
</ul>

<p>
The distinction between the terms "syntax object" and "wrapped syntax
object" is important.
For example, when invoked by the expander, a transformer
(Section&nbsp;<a href="./syntax.html#g6">3.4</a>) must accept a wrapped syntax object but
may return any syntax object, including an unwrapped syntax object.

<p>

<a name="g8"></a>

<h2><a name="./syntax:h8"></a>3.6. Parsing input and producing output<a name="sec:syntaxcase"></a></h2>



<p>
Transformers destructure their input with <tt>syntax-case</tt> and rebuild
their output with <tt>syntax</tt>.

<p>
A <tt>syntax-case</tt> expression has the following syntax.

<p>

<p><tt>(syntax-case&nbsp;<i>expr</i>&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</i>&nbsp;...)</tt>
<p>Each <tt><i>literal</i></tt> must be an identifier.
Each <tt><i>clause</i></tt> must take one of the following two forms.

<p>

<p><tt>(<i>pattern</i>&nbsp;<i>output-expr</i>)<br>

(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>output-expr</i>)</tt>
<p>A <tt><i>pattern</i></tt> is an identifier, constant, or one of the following.

<p>
<tt>(</tt><tt><i>pattern</i></tt>*<tt>)</tt><br>

<tt>(</tt><tt><i>pattern</i></tt><sup>+</sup> . <tt><i>pattern</i></tt><tt>)</tt><br>

<tt>(</tt><tt><i>pattern</i></tt>* <tt><i>pattern</i></tt> <tt><i>ellipsis</i></tt> <tt><i>pattern</i></tt>*<tt>)</tt><br>

<tt>(</tt><tt><i>pattern</i></tt>* <tt><i>pattern</i></tt> <tt><i>ellipsis</i></tt> <tt><i>pattern</i></tt>* . <tt><i>pattern</i></tt><tt>)</tt><br>

<tt>#(</tt><tt><i>pattern</i></tt>*<tt>)</tt><br>

<tt>#(</tt><tt><i>pattern</i></tt>* <tt><i>pattern</i></tt> <tt><i>ellipsis</i></tt> <tt><i>pattern</i></tt>*<tt>)</tt>

<p>
An identifier appearing within a <tt><i>pattern</i></tt> may be an underscore
(&nbsp;<tt>_</tt>&nbsp;), a literal identifier listed in the list of literals
<tt>(<i>literal</i>&nbsp;...)</tt>, or an ellipsis (&nbsp;<tt>...</tt>&nbsp;).
All other identifiers appearing within a <tt><i>pattern</i></tt> are
<i>pattern variables</i>.
An ellipsis or underscore may not appear in <tt>(<i>literal</i>&nbsp;...)</tt>.

<p>
Pattern variables match arbitrary input subforms and
are used to refer to elements of the input.
The same pattern variable may not appear more than once in a
<tt><i>pattern</i></tt>.

<p>
Underscores also match arbitrary input subforms but are not pattern variables
and so cannot be used to refer to those elements.
Multiple underscores may appear in a <tt><i>pattern</i></tt>.

<p>
A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers are equal and both have no lexical
binding.

<p>
A subpattern followed by an ellipsis can match zero or more elements of
the input.

<p>
More formally, an input form <tt><i>F</i></tt> matches a pattern <tt><i>P</i></tt> if and only if

<p>
<ul>
<li><tt><i>P</i></tt> is an underscore (&nbsp;<tt>_</tt>&nbsp;),

<p>
<li><tt><i>P</i></tt> is a pattern variable,

<p>
<li><tt><i>P</i></tt> is a literal identifier
and <tt><i>F</i></tt> is an equivalent identifier in the
sense of <tt>free-identifier=?</tt>
(Section&nbsp;<a href="./syntax.html#g9">3.7</a>),

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>
and <tt><i>F</i></tt> is a list of <i>n</i> elements that match <tt><i>P<sub>1</sub></i></tt> through
<tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</tt>
and <tt><i>F</i></tt> is a list or improper list of <i>n</i> or more elements
whose first <i>n</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>
and
whose <i>n</i>th cdr matches <tt><i>P<sub>x</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a proper list of <i>n</i>
elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
and
whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a list or improper list of <i>n</i>
elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
whose next <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,
and 
whose <i>n</i>th and final cdr matches <tt><i>P<sub>x</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>
and <tt><i>F</i></tt> is a vector of <i>n</i> elements that match <tt><i>P<sub>1</sub></i></tt> through
<tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a vector of <i>n</i> or more elements
whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
and
whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,
or

<p>
<li><tt><i>P</i></tt> is a pattern datum (any nonlist, nonvector, nonsymbol
object) and <tt><i>F</i></tt> is equal to <tt><i>P</i></tt> in the sense of the
<tt>equal?</tt> procedure.
</ul>

<p>
<tt>syntax-case</tt> first evaluates <tt><i>expr</i></tt>.
It then attempts to match
the <tt><i>pattern</i></tt> from the first <tt><i>clause</i></tt> against the resulting value,
which is unwrapped as necessary to perform the match.
If the pattern matches the value and no
<tt><i>fender</i></tt> is present,
<tt><i>output-expr</i></tt> is evaluated and its value returned as the
value of the <tt>syntax-case</tt> expression.
If the pattern does not match the value, <tt>syntax-case</tt> tries
the second <tt><i>clause</i></tt>, then the third, and so on.
An error is signaled if the value does not match any of the patterns.

<p>
If the optional <tt><i>fender</i></tt> is present, it serves as an additional
constraint on acceptance of a clause.
If the <tt><i>pattern</i></tt> of a given <tt><i>clause</i></tt> matches the input value,
the corresponding <tt><i>fender</i></tt> is evaluated.
If <tt><i>fender</i></tt> evaluates to a true value, the clause is accepted;
otherwise, the clause is rejected as if the pattern had failed to match
the value.
Fenders are logically a part of the matching process, i.e., they
specify additional matching constraints beyond the basic structure of
the input.

<p>
Pattern variables contained within a clause's
<tt><i>pattern</i></tt> are bound to the corresponding pieces of the input
value within the clause's <tt><i>fender</i></tt> (if present) and
<tt><i>output-expr</i></tt>.
Pattern variables can be referenced only within <tt>syntax</tt>
expressions (see below).
Pattern variables occupy the same name space as program variables and
keywords.

<p>
See the examples following the description of <tt>syntax</tt>.

<p>
A <tt>syntax</tt> form has the following syntax.

<p>

<p><tt>(syntax&nbsp;<i>template</i>)</tt>
<p><tt>#'<i>template</i></tt> is equivalent to <tt>(syntax&nbsp;<i>template</i>)</tt>.
The abbreviated form is converted into the longer form when the expression
is read, i.e., prior to expansion.

<p>
A <tt>syntax</tt> expression is similar to a <tt>quote</tt> expression
except that (1) the values of pattern variables appearing within
<tt><i>template</i></tt> are inserted into <tt><i>template</i></tt>, (2) contextual
information associated both with the input and with the template is
retained in the output to support lexical scoping, and (3) the value
of a <tt>syntax</tt> expression is a syntax object.

<p>
A <tt><i>template</i></tt> is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, or one of the following.

<p>
<tt>(</tt><tt><i>subtemplate</i></tt>*<tt>)</tt><br>

<tt>(</tt><tt><i>subtemplate</i></tt><sup>+</sup> . <tt><i>template</i></tt><tt>)</tt><br>

<tt>#(</tt><tt><i>subtemplate</i></tt>*<tt>)</tt>

<p>
A <tt><i>subtemplate</i></tt> is a <tt><i>template</i></tt> followed by zero or more ellipses.

<p>
The value of a <tt><i>syntax</i></tt> form is a copy of <tt><i>template</i></tt> in which
the pattern variables appearing within the template are replaced with
the input subforms to which they are bound.
Pattern data and identifiers that are not pattern variables
are copied directly into the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
The subtemplate
must contain at least one pattern variable from a subpattern
followed by an ellipsis.
(Otherwise, the expander would not be able to determine how many times the
subform should be repeated in the output.)
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the template
than in the associated pattern, the input form is replicated as
necessary.

<p>
A template of the form
<tt>(...&nbsp;<i>template</i>)</tt> is identical to <tt><i>template</i></tt>, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within <tt><i>template</i></tt> are
treated as ordinary identifiers.
In particular, the template <tt>(...&nbsp;...)</tt> produces a single
ellipsis, <tt>...</tt>.
This allows syntactic abstractions to expand into forms containing
ellipses.

<p>
<a name="wrappingrules"></a>
The output produced by <tt><i>syntax</i></tt> is wrapped or unwrapped according to
the following rules.

<p>
<ul>
<li>the copy of <tt>(<i>t<sub>1</sub></i>&nbsp;.&nbsp;&nbsp;<i>t<sub>2</sub></i>)</tt> is a pair if <tt><i>t<sub>1</sub></i></tt>
      or <tt><i>t<sub>2</sub></i></tt> contain any pattern variables,
<li>the copy of <tt>(<i>t</i>&nbsp;<i>ellipses</i>)</tt> is a list if <tt><i>t</i></tt>
      contains any pattern variables,
<li>the copy of <tt>#(<i>t<sub>1</sub></i>&nbsp;...&nbsp;<i>t<sub>n</sub></i>)</tt> is a vector if any of
      <tt><i>t<sub>1</sub></i></tt>,&nbsp;...,&nbsp;<tt><i>t<sub>n</sub></i></tt> contain any pattern variables, and
<li>the copy of any portion of <tt><i>t</i></tt> not containing any pattern variables
      is a wrapped syntax object.
</ul>

<p>
The input subforms inserted in place of the pattern variables are wrapped
if and only if the corresponding input subforms are wrapped.

<p>
The following definitions of <tt>or</tt> illustrate <tt>syntax-case</tt>
and <tt>syntax</tt>.
The second is equivalent to the first but uses the the <tt>#'</tt>
prefix instead of the full <tt>syntax</tt> form.

<p>

<p><tt>(define-syntax&nbsp;or<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;(syntax&nbsp;#f)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;(syntax&nbsp;e)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax&nbsp;(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...))))])))
<br>
<br>
(define-syntax&nbsp;or<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#'#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;#'e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))])))
<br>
<br>
(define-syntax&nbsp;case<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(else)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;[(k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...]&nbsp;...&nbsp;[else&nbsp;else-e1&nbsp;else-e2&nbsp;...])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;e1&nbsp;e2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;else-e1&nbsp;else-e2&nbsp;...]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;[(ka&nbsp;...)&nbsp;e1a&nbsp;e2a&nbsp;...]&nbsp;[(kb&nbsp;...)&nbsp;e1b&nbsp;e2b&nbsp;...]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(ka&nbsp;...))&nbsp;e1a&nbsp;e2a&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(kb&nbsp;...))&nbsp;e1b&nbsp;e2b&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))])))</tt>
<p>The examples below define <i>identifier macros</i>, syntactic abstractions
supporting keyword references that do not necessarily appear in the first
position of a list-structured form.
The second example uses <tt>make-variable-transformer</tt> to handle the case
where the keyword appears on the left-hand side of a
<tt>set!</tt> expression.

<p>

<p><tt>(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>

(define-syntax&nbsp;p.car<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;.&nbsp;rest)&nbsp;#'((car&nbsp;p)&nbsp;.&nbsp;rest)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;&nbsp;#'(car&nbsp;p)])))<br>

p.car&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;4<br>

(set!&nbsp;p.car&nbsp;15)&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;error</i>
<br>
<br>
(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>

(define-syntax&nbsp;p.car<br>

&nbsp;&nbsp;(make-variable-transformer<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;_&nbsp;e)&nbsp;#'(set-car!&nbsp;p&nbsp;e)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;.&nbsp;rest)&nbsp;#'((car&nbsp;p)&nbsp;.&nbsp;rest)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;&nbsp;#'(car&nbsp;p)]))))<br>

(set!&nbsp;p.car&nbsp;15)<br>

p.car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;15<br>

p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(15&nbsp;5)</tt>
<p>A derived <tt>identifier-syntax</tt> form that simplifies the definition
of identifier macros is described in Section&nbsp;<a href="./syntax.html#g12">3.10</a>.

<p>

<a name="g9"></a>

<h2><a name="./syntax:h9"></a>3.7. Identifier predicates<a name="sec:identifierpredicates"></a></h2>



<p>
The procedure <tt>identifier?</tt> is used to determine if a value is
an identifier.

<p>

<p><tt>(identifier?&nbsp;<i>x</i>)</tt>
<p>It returns <tt>#t</tt> if its argument <tt><i>x</i></tt> is an identifier, i.e., a
syntax object representing an identifier, and <tt>#f</tt> otherwise.

<p>
<tt>identifier?</tt> is often used within a fender to verify
that certain subforms of an input form are identifiers, as in the
definition of <tt>rec</tt>, which creates self-contained
recursive objects, below.

<p>

<p><tt>(define-syntax&nbsp;rec<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(identifier?&nbsp;#'x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(letrec&nbsp;([x&nbsp;e])&nbsp;x)])))
<br>
<br>
(map&nbsp;(rec&nbsp;fact<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;6&nbsp;24&nbsp;120)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))
<br>
<br>
(rec&nbsp;5&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;error</i></tt>
<p>The procedures <tt>bound-identifier=?</tt> and <tt>free-identifier=?</tt>
each take two identifier arguments and return <tt>#t</tt> if their
arguments are equivalent and <tt>#f</tt> otherwise.
These predicates are used to compare identifiers according to their
<i>intended use</i> as free references or bound identifiers in a given
context.

<p>

<p><tt>(bound-identifier=?&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></i>)</tt>
<p>The procedure <tt>bound-identifier=?</tt> returns true if and only if a
binding for one would capture a reference to the other in the output of
the transformer, assuming that the reference appears within the scope of
the binding.
In general, two identifiers are <tt>bound-identifier=?</tt> only if
both are present in the original program or both are introduced by the
same transformer application
(perhaps implicitly---see <tt>datum-&gt;syntax</tt>).
Operationally, two identifiers are
considered equivalent by <tt>bound-identifier=?</tt> if and only if they
have the same name and same marks (Section&nbsp;<a href="./syntax.html#g4">3.2</a>).

<p>
<tt>bound-identifier=?</tt> can be used for detecting
duplicate identifiers in a binding construct or for other
preprocessing of a binding construct that requires detecting instances
of the bound identifiers.

<p>

<p><tt>(free-identifier=?&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></i>)</tt>
<p>The procedure <tt>free-identifier=?</tt> returns <tt>#t</tt> if and
only if the two identifiers would resolve to the same binding if both were
to appear in the output of a transformer outside of any bindings inserted
by the transformer.
Two like-named identifiers are considered to resolve to the same binding
if both are unbound.
Operationally, two identifiers are considered equivalent by
<tt>free-identifier=?</tt> if and only the topmost matching
substitution for each maps to the same binding (Section&nbsp;<a href="./syntax.html#g4">3.2</a>)
or the identifiers have the same name and no matching substitution.

<p>
<tt>syntax-case</tt> and <tt>syntax-rules</tt> use
<tt>free-identifier=?</tt> to compare identifiers listed in the literals
list against input identifiers.

<p>
The following definition of unnamed <tt>let</tt>
uses <tt>bound-identifier=?</tt> to detect duplicate identifiers.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;unique-ids?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(let&nbsp;notmem?&nbsp;([x&nbsp;(car&nbsp;ls)]&nbsp;[ls&nbsp;(cdr&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(bound-identifier=?&nbsp;x&nbsp;(car&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(notmem?&nbsp;x&nbsp;(cdr&nbsp;ls)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unique-ids?&nbsp;(cdr&nbsp;ls))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unique-ids?&nbsp;#'(i&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...)])))</tt>
<p>The argument <tt>#'(i&nbsp;...)</tt> to <tt>unique-ids?</tt> is guaranteed
to be a list by the rules given in the description of <tt>syntax</tt>
above.

<p>
With this definition of <tt>let</tt>, the expression

<p>

<p><tt>(let&nbsp;([a&nbsp;3]&nbsp;[a&nbsp;4])&nbsp;(+&nbsp;a&nbsp;a))</tt>
<p>causes a syntax error exception to be raised, whereas

<p>

<p><tt>(let-syntax&nbsp;([dolet&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([a&nbsp;3]&nbsp;[b&nbsp;4])&nbsp;(+&nbsp;a&nbsp;b))]))])<br>

&nbsp;&nbsp;(dolet&nbsp;a))</tt>
<p>evaluates to <tt>7</tt>, since the identifier <tt>a</tt> introduced by <tt>dolet</tt>
and the identifier <tt>a</tt> extracted from the input form are not
<tt>bound-identifier=?</tt>.

<p>
The following definition of <tt>case</tt> is equivalent to the one in
Section&nbsp;<a href="./syntax.html#g8">3.6</a>.
Rather than including <tt>else</tt> in the literals list as before,
this version explicitly tests for <tt>else</tt> using
<tt>free-identifier=?</tt>.

<p>

<p><tt>(define-syntax&nbsp;case<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;[(k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...]&nbsp;...&nbsp;[else-key&nbsp;else-e1&nbsp;else-e2&nbsp;...])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;#'else-key)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(free-identifier=?&nbsp;#'else-key&nbsp;#'else))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;e1&nbsp;e2&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;else-e1&nbsp;else-e2&nbsp;...]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;[(ka&nbsp;...)&nbsp;e1a&nbsp;e2a&nbsp;...]&nbsp;[(kb&nbsp;...)&nbsp;e1b&nbsp;e2b&nbsp;...]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(ka&nbsp;...))&nbsp;e1a&nbsp;e2a&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memv&nbsp;t&nbsp;'(kb&nbsp;...))&nbsp;e1b&nbsp;e2b&nbsp;...]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))])))</tt>
<p>With either definition of <tt>case</tt>, <tt>else</tt> is not
recognized as an auxiliary
keyword if an enclosing lexical binding for <tt>else</tt> exists.
For example,

<p>

<p><tt>(let&nbsp;([else&nbsp;#f])<br>

&nbsp;&nbsp;(case&nbsp;0&nbsp;[else&nbsp;(write&nbsp;"oops")]))</tt>
<p>results in a syntax error, since <tt>else</tt> is bound
lexically and is
therefore not the same <tt>else</tt> that appears in the definition of
<tt>case</tt>.

<p>

<a name="g10"></a>

<h2><a name="./syntax:h10"></a>3.8. Syntax-object and datum conversions</h2>



<p>
The procedure <tt>syntax-&gt;datum</tt>
strips all syntactic information from a syntax
object and returns the corresponding Scheme "datum."

<p>

<p><tt>(syntax-&gt;datum&nbsp;<i>syntax-object</i>)</tt>
<p>Identifiers stripped in this manner are converted to their symbolic
names, which can then be compared with <tt>eq?</tt>.
Thus, a predicate <tt>symbolic-identifier=?</tt> might be defined as follows.

<p>

<p><tt>(define&nbsp;symbolic-identifier=?<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(syntax-&gt;datum&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;y))))</tt>
<p>The procedure <tt>datum-&gt;syntax</tt> accepts two arguments, a
template identifier <tt><i>template-id</i></tt> and an arbitrary value
<tt><i>datum</i></tt>.

<p>

<p><tt>(datum-&gt;syntax&nbsp;<i>template-id</i>&nbsp;<i>datum</i>)</tt>
<p>It returns a syntax object representation of <tt><i>datum</i></tt> that
contains the same contextual information as
<tt><i>template-id</i></tt>, with the effect that the
syntax object behaves
as if it were introduced into the code when
<tt><i>datum</i></tt> was introduced.

<p>
<tt>datum-&gt;syntax</tt> allows a transformer to "bend" lexical
scoping rules by creating <i>implicit identifiers</i>
that behave as if they were present in the input form,
thus permitting the definition of syntactic
abstractions that introduce visible bindings for or references to
identifiers that do not appear explicitly in the input form.
For example, the following defines a <tt>loop</tt> expression that
binds the variable <tt>break</tt> to an escape procedure
within the loop body.
(The derived <tt>with-syntax</tt> form is like <tt>let</tt> but binds
pattern variables---see Section&nbsp;<a href="./syntax.html#g12">3.10</a>.)

<p>

<p><tt>(define-syntax&nbsp;loop<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([break&nbsp;(datum-&gt;syntax&nbsp;#'k&nbsp;'break)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call-with-current-continuation<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f)))))])))
<br>
<br>
(let&nbsp;((n&nbsp;3)&nbsp;(ls&nbsp;'()))<br>

&nbsp;&nbsp;(loop<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(break&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;'a&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(-&nbsp;n&nbsp;1))))&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(a&nbsp;a&nbsp;a)</tt>
<p>Were <tt>loop</tt> to be defined as

<p>

<p><tt>(define-syntax&nbsp;loop<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call-with-current-continuation<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f))))])))</tt>
<p>the variable <tt>break</tt> would not be visible in <tt>e&nbsp;...</tt>.

<p>
The datum argument <tt><i>datum</i></tt> may also represent an arbitrary
Scheme form, as demonstrated by the following definition of
<tt>include</tt>, an expand-time version of <tt>load</tt>.

<p>

<p><tt>(define-syntax&nbsp;include<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;read-file<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(fn&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-input-file&nbsp;fn)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(close-input-port&nbsp;p)&nbsp;'())<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(datum-&gt;syntax&nbsp;k&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(read&nbsp;p))))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;filename)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fn&nbsp;(syntax-&gt;datum&nbsp;#'filename)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(exp&nbsp;...)&nbsp;(read-file&nbsp;fn&nbsp;#'k)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin&nbsp;exp&nbsp;...)))])))</tt>
<p><tt>(include&nbsp;"filename")</tt> expands into a <tt>begin</tt> expression
containing the forms found in the file named by
<tt>"filename"</tt>.
For example, if the file <tt>flib.ss</tt> contains
<tt>(define&nbsp;f&nbsp;(lambda&nbsp;(x)&nbsp;(g&nbsp;(*&nbsp;x&nbsp;x))))</tt>, and the file
<tt>glib.ss</tt> contains
<tt>(define&nbsp;g&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x)))</tt>,
the expression

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(include&nbsp;"flib.ss")<br>

&nbsp;&nbsp;(include&nbsp;"glib.ss")<br>

&nbsp;&nbsp;(f&nbsp;5))</tt>
<p>evaluates to <tt>50</tt>.

<p>
The definition of <tt>include</tt> uses <tt>datum-&gt;syntax</tt> to convert
the objects read from the file into syntax objects in the proper
lexical context, so that identifier references and definitions within
those expressions are scoped where the <tt>include</tt> form appears.

<p>
Using <tt>datum-&gt;syntax</tt>, it is even possible to break hygiene
entirely and write macros in the style of old Lisp macros.
The <tt>lisp-transformer</tt> procedure defined below creates a transformer
that converts its input into a datum, calls the programmer's procedure on
this datum, and converts the result back into a syntax object that is
scoped at top level (or, more accurately, wherever
<tt>lisp-transformer</tt> is defined).

<p>

<p><tt>(define&nbsp;lisp-transformer<br>

&nbsp;&nbsp;(lambda&nbsp;(p)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;#'lisp-transformer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p&nbsp;(syntax-&gt;datum&nbsp;x))))))</tt>
<p>Using <tt>lisp-transformer</tt>, defining a basic version of Common Lisp's
<tt>defmacro</tt> is a straightforward exercise.

<p>

<a name="g11"></a>

<h2><a name="./syntax:h11"></a>3.9. Generating lists of temporaries<a name="sec:generatingtemporaries"></a></h2>



<p>
Transformers can introduce a fixed number of identifiers into their
output simply by naming each identifier.
In some cases, however, the number of identifiers to be introduced depends
upon some characteristic of the input expression.
A straightforward definition of <tt>letrec</tt>, for example,
requires as many
temporary identifiers as there are binding pairs in the
input expression.
The procedure <tt>generate-temporaries</tt> is used to construct
lists of temporary identifiers.

<p>

<p><tt>(generate-temporaries&nbsp;<i>list</i>)</tt>
<p><tt><i>list</i></tt> may be any list or syntax object representing a list-structured
form; its contents are not important.
The number of temporaries generated is the number of elements in <tt><i>list</i></tt>.
Each temporary is guaranteed to be unique, i.e., different from all other
identifiers.

<p>
A definition of <tt>letrec</tt> that
uses <tt>generate-temporaries</tt> is shown below.

<p>

<p><tt>(define-syntax&nbsp;letrec<a name="defn:letrec"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_&nbsp;((i&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;(((t&nbsp;...)&nbsp;(generate-temporaries&nbsp;(syntax&nbsp;(i&nbsp;...)))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax&nbsp;(let&nbsp;((i&nbsp;#f)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((t&nbsp;v)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;i&nbsp;t)&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)))))))))</tt>
<p>Any transformer that uses <tt>generate-temporaries</tt> in this fashion can
be rewritten to avoid using it, albeit with a loss of clarity.
The trick is to use a recursively defined intermediate form that
generates one temporary per expansion step and completes the
expansion after enough temporaries have been generated.

<p>

<a name="g12"></a>

<h2><a name="./syntax:h12"></a>3.10. Derived forms and procedures<a name="sec:derived"></a></h2>



<p>
The forms and procedures described in this section are <i>derived</i>,
i.e., they can defined in terms of the forms and procedures described
in earlier sections of this document.

<p>
The R5RS <tt>syntax-rules</tt> form is supported as a derived form,
with the following extensions:

<p>
<ul>
 <li>Patterns are generalized slightly to allow a fixed number of   
   subpatterns to appear after an ellipsis, e.g.,
   <tt>(<i>p<sub>1</sub></i>&nbsp;...&nbsp;<i>p<sub>2</sub></i>&nbsp;<i>p<sub>3</sub></i>)</tt>.

 <p>
<li>Underscores (&nbsp;<tt>_</tt>&nbsp;) may appear within the pattern
   and match any input, but are not pattern variables and so
   are not bound in the output <tt><i>template</i></tt>.

 <p>
<li>The first position of a syntax-rules pattern may be any
   identifier, including an underscore, i.e., it need not be the name
   of the macro being defined.
   This position is always ignored.

 <p>
<li>An optional fender may appear between the pattern and
   template of any clause and has the same meaning as a
   <tt>syntax-case</tt> fender.
</ul>

<p>
A <tt>syntax-rules</tt> form has the syntax

<p>

<p><tt>(syntax-rules&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</i>&nbsp;...)</tt>
<p>Each <tt><i>literal</i></tt> must be an identifier.
Each <tt><i>clause</i></tt> must take one of the following two forms.

<p>

<p><tt>(<i>pattern</i>&nbsp;<i>template</i>)<br>

(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>template</i>)</tt>
<p>Each <tt><i>pattern</i></tt> and <tt><i>fender</i></tt> are as in <tt>syntax-case</tt>,
and each <tt><i>template</i></tt>
is as in <tt>syntax</tt>.
(See Section&nbsp;<a href="./syntax.html#g8">3.6</a>.)

<p>
The definition of <tt>or</tt> below is like the ones given in
Section&nbsp;<a href="./syntax.html#g8">3.6</a>, except
that <tt>syntax-rules</tt> is used in place of <tt>syntax-case</tt>
and <tt>syntax</tt>.

<p>

<p><tt>(define-syntax&nbsp;or<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))]))</tt>
<p>The <tt>lambda</tt> expression used to produce the transformer is
implicit, as are the <tt>syntax</tt> forms used to construct the
output.

<p>
Any <tt>syntax-rules</tt> form can be expressed with
<tt>syntax-case</tt> by making the <tt>lambda</tt> expression and
<tt>syntax</tt> expressions explicit, and
<tt>syntax-rules</tt> may be defined in terms of <tt>syntax-case</tt>
as follows.

<p>

<p><tt>(define-syntax&nbsp;syntax-rules<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(k&nbsp;...)&nbsp;[(_&nbsp;.&nbsp;p)&nbsp;f&nbsp;...&nbsp;t]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(k&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;.&nbsp;p)&nbsp;f&nbsp;...&nbsp;#'t]&nbsp;...))])))</tt>
<p>A more robust implementation would verify that the literals
<tt><i>k</i>&nbsp;...</tt> are all identifiers, that the first position
of each pattern is an identifier, and that at most one fender
is present in each clause.

<p>
Since the <tt>lambda</tt> and <tt>syntax</tt> expressions are implicit in
a <tt>syntax-rules</tt> form, definitions expressed with
<tt>syntax-rules</tt> are shorter than the equivalent definitions
expressed with <tt>syntax-case</tt>.
The choice of which to use when either suffices is a matter of taste, but
some transformers that can be written easily with <tt>syntax-case</tt>
cannot be written easily or at all with <tt>syntax-rules</tt>.


<p>
The definitions of <tt>p.car</tt> in Section&nbsp;<a href="./syntax.html#g8">3.6</a>
demonstrated how identifier macros might be written using
<tt>syntax-case</tt>.
Many identifier macros can be defined more succinctly using
the derived <tt>identifier-syntax</tt> form.
An <tt>identifier-syntax</tt> form has one of the following syntaxes:

<p>

<p><tt>(identifier-syntax&nbsp;<i>template</i>)<br>

(identifier-syntax&nbsp;(<i>id<sub>1</sub></i>&nbsp;<i>template<sub>1</sub></i>)&nbsp;((set!&nbsp;<i>id<sub>2</sub></i>&nbsp;<i>pattern</i>)&nbsp;<i>template<sub>2</sub></i>))</tt>
<p>When a keyword is bound to a transformer produced by the first form of
<tt>identifier-syntax</tt>, references to the keyword within the scope
of the binding are replaced by <tt><i>template</i></tt>.

<p>

<p><tt>(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>

(define-syntax&nbsp;p.car&nbsp;(identifier-syntax&nbsp;(car&nbsp;p)))<br>

p.car&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;4<br>

(set!&nbsp;p.car&nbsp;15)&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;error</i></tt>
<p>The second, more general, form of <tt>identifier-syntax</tt> permits
the transformer to determine what happens when <tt>set!</tt> is used.

<p>

<p><tt>(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>

(define-syntax&nbsp;p.car<br>

&nbsp;&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(car&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;_&nbsp;e)&nbsp;(set-car!&nbsp;p&nbsp;e)]))<br>

(set!&nbsp;p.car&nbsp;15)<br>

p.car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;15<br>

p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/syntax/0.gif" alt="<graphic>">&nbsp;(15&nbsp;5)</tt>
<p><tt>identifier-syntax</tt> may be defined in terms of <tt>syntax-case</tt>,
<tt>syntax</tt>, and <tt>make-variable-transformer</tt> as follows.

<p>

<p><tt>(define-syntax&nbsp;identifier-syntax<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(set!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(e&nbsp;x&nbsp;(...&nbsp;...))]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(id&nbsp;exp1)&nbsp;((set!&nbsp;var&nbsp;val)&nbsp;exp2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;#'id)&nbsp;(identifier?&nbsp;#'var))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-variable-transformer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;var&nbsp;val)&nbsp;#'exp2]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(id&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(exp1&nbsp;x&nbsp;(...&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'exp1])))]))</tt>
<p>The derived <tt>with-syntax</tt> form is used to bind pattern variables,
just as <tt>let</tt> is used to bind variables.
This allows a transformer to construct its output in separate
pieces, then put the pieces together.

<p>
A <tt>with-syntax</tt> form has the following syntax.

<p>

<p><tt>(with-syntax&nbsp;((<i>pattern</i>&nbsp;<i>expr<sub>0</sub></i>)&nbsp;...)&nbsp;<i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...)</tt>
<p>Each <tt><i>pattern</i></tt> is identical in form to a <tt>syntax-case</tt> pattern.
The value of each <tt><i>expr<sub>0</sub></i></tt> is computed and destructured according
to the corresponding <tt><i>pattern</i></tt>, and pattern variables within
the <tt><i>pattern</i></tt> are bound as with <tt>syntax-case</tt> to the
corresponding portions of the value within
<tt><i>expr<sub>1</sub></i>&nbsp;<i>expr<sub>2</sub></i>&nbsp;...</tt>.

<p>
<tt>with-syntax</tt> may be defined in terms of <tt>syntax-case</tt> as
follows.

<p>

<p><tt>(define-syntax&nbsp;with-syntax<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_&nbsp;((p&nbsp;e0)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax&nbsp;(syntax-case&nbsp;(list&nbsp;e0&nbsp;...)&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((p&nbsp;...)&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))))))))</tt>
<p>The following definition of <tt>cond</tt> demonstrates the use of
<tt>with-syntax</tt> to support transformers that employ recursion
internally to construct their output.
It handles all <tt>cond</tt> clause variations and takes care to produce
one-armed <tt>if</tt> expressions where appropriate.

<p>

<p><tt>(define-syntax&nbsp;cond<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;c1&nbsp;c2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([c1&nbsp;#'c1]&nbsp;[c2*&nbsp;#'(c2&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c2*&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(else&nbsp;=&gt;)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;t))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(c2&nbsp;c3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([rest&nbsp;(f&nbsp;#'c2&nbsp;#'(c3&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(=&gt;)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;t&nbsp;rest))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)&nbsp;rest))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;rest)]))]))])))</tt>
<p>
<a name="g13"></a>

<h1><a name="./syntax:h13"></a>4. Reference Implementation<a name="sec:implementation"></a></h1>



<p>
A reference implementation is available in source
(<a class=ref href="implementation/syntax.ss">syntax.ss</a>) and expanded
(<a class=ref href="implementation/syntax.pp">syntax.pp</a>) forms.
The source form is the more readable of the two but uses
<tt>syntax-case</tt> and thus must be bootstrapped using the expanded
form.

<p>

<a name="g14"></a>

<h1><a name="./syntax:h14"></a>5. Issues<a name="sec:issues"></a></h1>






<p>

<a name="g15"></a>

<h2><a name="./syntax:h15"></a>5.1. Library interaction</h2>



<p>
This SRFI does not fully address the interaction between the proposed R6RS
library system and the macro system, nor does it specify the environment
in which a transformer is run.
These issues are still open to some extent, but we anticipate that the
environment in which a transformer runs will be dictated by the set of
libraries imported "for syntax" and possibly the "meta level" at
which the transformer is evaluated.



<p>

<a name="g16"></a>

<h2><a name="./syntax:h16"></a>5.2. Name changes</h2>



<p>
We have chosen the SRFI&nbsp;72 names <tt>syntax-&gt;datum</tt> and
<tt>datum-&gt;syntax</tt> for the procedures that
Chez Scheme, MzScheme, and most other systems call
<tt>syntax-object-&gt;datum</tt> and <tt>datum-&gt;syntax-object</tt>,
because the SRFI&nbsp;72 names are shorter.
While this change is incompatible with a large amount of existing code, it
is easy to identify and fix the incompatible code.

<p>

<a name="g17"></a>

<h2><a name="./syntax:h17"></a>5.3. Top-level keyword bindings</h2>



<p>
This SRFI has nothing to say about top-level keyword bindings. 
Implementations that allow variable definitions at top level, however, are
encouraged to allow syntax definitions at top level as well.

<p>

<a name="g18"></a>

<h2><a name="./syntax:h18"></a>5.4. Internal keyword definitions</h2>



<p>
Internal syntax definitions can appear anywhere that other internal
definitions can appear, i.e., at the top level of a library or within a
<tt>lambda</tt> (or <tt>lambda</tt>-derived) body.
To accommodate internal syntax definitions as well as to address
weaknesses in the specification of R5RS internal variable definitions,
the operational semantics of <tt>library</tt> and <tt>lambda</tt> body
expansion has been specified more precisely.
While this complicates the treatment of <tt>lambda</tt> bodies somewhat
relative to R5RS, it makes the semantics of <tt>library</tt> and
<tt>lambda</tt> bodies more consistent and, of course, provides added
functionality.

<p>

<a name="g19"></a>

<h2><a name="./syntax:h19"></a>5.5. Fluid identifiers or bindings</h2>



<p>
Chez Scheme, MzScheme, and various other systems support a
<tt>fluid-let-syntax</tt> construct that dynamically (at expansion time)
rebinds an existing syntactic binding.
SRFI&nbsp;72 supports a more general concept of fluid identifiers.
Should we include either feature in R6RS?

<p>

<a name="g20"></a>

<h2><a name="./syntax:h20"></a>5.6. Expand-time environment</h2>



<p>
Chez Scheme and various other systems allow arbitrary bindings to be added
to the expand-time environment and provide a mechanism for retrieving
those bindings.
Chez Scheme uses this feature, for example, to record information about
record definitions for use in subordinate record definitions.
Should we include such a feature in R6RS?

<p>

<a name="g21"></a>

<h2><a name="./syntax:h21"></a>5.7. Quasisyntax</h2>



<p>
MzScheme provides <tt>quasisyntax</tt>, <tt>unsyntax</tt>, and
<tt>unsyntax-splicing</tt> forms,
analogous to <tt>quasiquote</tt>, <tt>unquote</tt>, and <tt>unquote-splicing</tt>,
with the reader syntax <tt>#`</tt>, <tt>#,</tt>, and <tt>#,@</tt>.
SRFI&nbsp;72 also includes <tt>quasisyntax</tt> but overloads <tt>unquote</tt>
and <tt>unquote-splicing</tt>, which reduces the number of additional
constructs but complicates the use of
<tt>quasisyntax</tt> for generating <tt>quasiquote</tt> expressions.
Should we include either variant in R6RS?

<p>

<a name="g22"></a>

<h2><a name="./syntax:h22"></a>5.8. Fresh syntax</h2>



<p>
SRFI&nbsp;72 proposes that <tt>syntax</tt> apply a fresh mark, so that
identifiers contained within two different <tt>syntax</tt> forms are not
<tt>bound-identifier=?</tt>.
(It makes an exception, however, for identifiers that appear nested within
the same <tt>quasisyntax</tt> form.)
We have opted to keep the traditional semantics in which a fresh mark is
applied to all introduced portions of a transformer's output, as
described in Section&nbsp;<a href="./syntax.html#g4">3.2</a>.
Ignoring the SRFI&nbsp;72 <tt>quasisyntax</tt> exception, which muddies the
SRFI&nbsp;72 semantics somewhat, both models are straightforward, logical
points in the design space.
The SRFI&nbsp;72 semantics allows transformation helpers defined in
separate libraries to introduce their own unique identifier bindings.
On the other hand, the traditional semantics requires less work in the
common case where a macro and its transformation helpers are
self-contained and there is no reason to introduce two different
identifiers with the same name.
Of less concern but still relevant, the SRFI&nbsp;72 semantics is also
potentially incompatible with a large amount of existing
<tt>syntax-case</tt> code, and identifying the affected code is not
straightforward.

<p>
This SRFI's <tt>generate-temporaries</tt>, while intended to generate
lists of temporaries as illustrated in the <tt>letrec</tt> example
of Section&nbsp;<a href="./syntax.html#g11">3.9</a>, can of course be used to generate
single identifiers as well, and library helpers can use that feature
to introduce their own unique bindings if necessary.
Should we consider instead a variant of <tt>syntax</tt>, say
<tt>fresh-syntax</tt>, that applies a unique mark to its output?
Should we consider something more general, like MzScheme's
<tt>make-syntax-introducer</tt>, which creates a procedure that applies
the same mark to a syntax object each time it is applied?
Either can be used to define <tt>generate-temporaries</tt>, which can
then be considered a derived procedure.

<p>

<a name="g23"></a>

<h2><a name="./syntax:h23"></a>5.9. Degree of wrapping</h2>



<p>
This SRFI strikes a middle ground between two extremes in the degree
to which syntax objects are wrapped.
At one extreme, syntax objects are always fully wrapped.
That is, the expander passes transformers fully wrapped input,
transformers must return fully wrapped output to the expander,
<tt>syntax-case</tt> must be receive a fully wrapped input
value, and <tt>syntax</tt> forms always produce fully wrapped
output values.
Transformers and their helpers must use <tt>syntax-case</tt>
to destructure their input and <tt>syntax</tt> to produce their
output.
At the other extreme, syntax objects are mostly unwrapped: only the
identifiers occurring within a syntax object are wrapped.
Transformers and their helpers can use arbitrary list operations
to destructure their input or produce their output.

<p>
Each extreme has advantages. 
The fully wrapped representation frees an implementation to choose an
appropriate internal representation that allows the implementation to
provide more functionality and/or efficiency. 
In particular, it allows an implementation to avoid traversals of list-
and vector-structured constants to record binding information in embedded
identifiers that will end up being stripped of this information in the
end.
Because constants need not be traversed or copied, shared structure and
cycles among and within constants (more precisely, parts of the input that
will end up being constant in the final output) can be preserved for
free.
Also, again because constants need not be traversed or copied, the
expander can be written in such a way that it is linear in the size of the
input and new nodes added by transformers.
Since fully wrapped syntax objects can be destructured only via
syntax-case, which automates matching and syntax checking, it encourages a
safe, high-level style of transformer code, like syntax-rules. 

<p>
On the other hand, the unwrapped representation provides more flexibility
to the programmer, who can use familiar list-processing operations, like
map, to process portions of a transformer's input.

<p>
The flexibility of the unwrapped representation can obviously lead to an
undisciplined style in which appropriate matching is not done before a
transformer goes grabbing for a piece of the input or ignores extra pieces
of the input that should not be there. 
This is counter to one of the main goals of <tt>syntax-case</tt>, which is
to encourage a high-level style of transformer code, i.e., a style that is
both more readable and robust.
An important facet of this high-level style is that syntax checking is
performed automatically.
Such checking in low-level hand-written code is tedious and all too likely
to be incomplete.

<p>
Ironically, the fully wrapped representation can lead to similar problems.
With the fully wrapped representation, programmers are compelled to use
a procedure like MzScheme's <tt>syntax-&gt;list</tt> to convert wrapped syntax
objects into lists in order to map helpers over portions of the input.
When <tt>syntax-&gt;list</tt> is applied to properly matched input, there
is no problem, but <tt>syntax-&gt;list</tt> can also be applied to arbitrary
subforms for which no matching has been done.

<p>
The middle point described in this SRFI strikes a balance between the two
extremes, yielding the advantages of both without the shortcomings.
The <a href="./syntax.html#wrappingrules">rules for the degree to which the output of a
syntax form is unwrapped</a> are the key to this middle point between the two
extremes. 
They allow the programmer to use list- and vector-processing operations,
but only on portions of the transformer input that have been properly
matched. 
For example, if a transformer's input is matched using the following
<tt>syntax-case</tt> input pattern:

<p>

<p><tt>(_&nbsp;([x&nbsp;e]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)</tt>
<p>the corresponding output expression can treat <tt>#'(x&nbsp;...)</tt>,
<tt>#'(e&nbsp;...)</tt>, <tt>#'([x&nbsp;e]&nbsp;...)</tt>, and <tt>#'(b1&nbsp;b2&nbsp;...)</tt> as
lists, but cannot delve into the <tt>x</tt>'s, <tt>e</tt>'s, <tt>b1</tt>,
or <tt>b2</tt>'s without using syntax-case to further destructure them.

<p>
Compared with the fully wrapped extreme, the middle point eliminates the
need for potentially problematic helpers like <tt>syntax-&gt;list</tt>. 
Because a transformer can return partially unwrapped output, it also
eliminates the need for corresponding output constructors like
<tt>list-&gt;syntax</tt>. 
Compared with the mostly unwrapped extreme, the middle point ties the
implementation down less without unduly restricting the programmer from
using list- and vector-processing operations. 
It also encourages a safer, higher-level style of transformer code.

<p>
While the middle point is not as simple as either extreme and does not
provide quite as much implementation freedom as the fully wrapped extreme,
it is a natural and appropriate compromise between the two extremes.

<p>
Note:  Programmers wishing to employ the fully unwrapped representation
can define and use the following procedures that convert from the fully
wrapped to the unwrapped representation and back.

<p>

<p><tt>(define&nbsp;syntax-&gt;sexpr<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(a&nbsp;.&nbsp;d)&nbsp;(cons&nbsp;(syntax-&gt;sexpr&nbsp;#'a)&nbsp;(syntax-&gt;sexpr&nbsp;#'d))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[#(a&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;vector<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;syntax-&gt;sexpr&nbsp;(syntax-&gt;sexpr&nbsp;#'(a&nbsp;...))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(if&nbsp;(identifier?&nbsp;x)&nbsp;x&nbsp;(syntax-&gt;datum&nbsp;x))])))
<br>
<br>
(define&nbsp;sexpr-&gt;syntax<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(pair?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([a&nbsp;(sexpr-&gt;syntax&nbsp;(car&nbsp;x))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[d&nbsp;(sexpr-&gt;syntax&nbsp;(cdr&nbsp;x))])&nbsp;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(a&nbsp;.&nbsp;d))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(vector?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(x&nbsp;...)&nbsp;(map&nbsp;sexpr-&gt;syntax&nbsp;(vector-&gt;list&nbsp;x))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'#(x&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(if&nbsp;(identifier?&nbsp;x)&nbsp;x&nbsp;(datum-&gt;syntax&nbsp;#'*&nbsp;x))])))</tt>
<p>A library that exports versions of <tt>define-syntax</tt>,
<tt>make-variable-expander</tt>, and <tt>syntax</tt> to make these
operations transparent is left as an exercise for the reader.

<p>
It is cleaner and possibly much more efficient, however, for a transformer
to traverse only those parts of the input that it needs to traverse and to
treat as s-expressions only those parts that it has matched.

<p>

<a name="g24"></a>

<h1><a name="./syntax:h24"></a>6. Acknowledgments</h1>



<p>
This SRFI was written in consultation with the full set of R6RS editors: 
Will Clinger, Kent Dybvig, Matthew Flatt, Michael Sperber, and Anton
van&nbsp;Straaten.

<p>
Much of this document has been copied from or adapted from Chapter&nbsp;10 of the
<i>Chez Scheme Version&nbsp;7 User's Guide</i>, some of which also appears in
Chapter&nbsp;8 of <i>The Scheme Programming Language, 3rd edition</i>.

<p>

<a name="g25"></a>

<h1><a name="./syntax:h25"></a>7. References</h1>



<p>
R.&nbsp;Kent Dybvig, Robert Hieb, and Carl Bruggeman,
"<a class=ref href="http://www.cs.indiana.edu/~dyb/pubs/LaSC-5-4-pp295-326.pdf">Syntactic
Abstraction in Scheme</a>"
Lisp and Symbolic Computation 5, 4, 1993.

<p>
R.&nbsp;Kent Dybvig, <i>Chez Scheme Version 7 User's Guide</i>, Chapter 10:
"<a class=ref href="http://www.scheme.com/csug7/syntax.html">Syntactic Extension</a>,"
Cadence Research Systems, 2005.

<p>
Matthew Flatt, <i>PLT MzScheme: Language Manual</i>, No.&nbsp;301,
Chapter 12:
"<a class=ref href="http://download.plt-scheme.org/doc/301/html/mzscheme/mzscheme-Z-H-12.html#node_chap_12">Syntax
and Macros</a>,"
2006.

<p>
Andr&eacute; van&nbsp;Tonder, <a class=ref href="http://srfi.schemers.org/srfi-72/srfi-72.html">SRFI&nbsp;72: Hygienic macros</a>,
2005.

<p>

<a name="g26"></a>

<h1><a name="./syntax:h26"></a>8. Copyright</h1>



<p>
Copyright &copy; R. Kent Dybvig (2006). All Rights Reserved.

<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE. 

<p>

 
 </body>
</html>
