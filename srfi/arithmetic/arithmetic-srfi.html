<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html40/loose.dtd">
<html><head>
<title>
SRFI ??: Preliminary Proposal for R6RS Arithmetic
</title></head>
<body>

<H1>Title</H1>

Preliminary Proposal for R6RS Arithmetic

<H2>Authors</H2>

William D Clinger and Michael Sperber

<p>
<strong>
(FIXME: R6RS/SRFI boilerplate goes here)
</strong>
</p>

<h2>Abstract</h2>

<p>
Scheme's arithmetic system was designed to allow a wide variety
of implementations.  After many years of implementation experience,
however, most implementations now fall into a small number of
categories, and the benefits of continued experimentation no longer
justify the confusion and portability problems that have resulted
from giving implementations so much freedom in this area.
</p>

<p>
In addition, several details of the R5RS are inconsistent or
incomplete with respect to the IEEE standards for binary floating
point arithmetic, which are generally used to implement Scheme's
inexact real arithmetic.  Furthermore some details of the R5RS
make it unnecessarily difficult to implement Scheme's arithmetic
efficiently.
</p>

<p>
The portability problems can most easily be solved by requiring
all implementations to support the full numeric tower.  To
prevent that requirement from making Scheme substantially more
difficult to implement, we can provide reference implementations
that construct the full numeric tower from a fixnum/flonum base.
To ensure the portability of these reference implementations,
the fixnum/flonum base must be described and (at least partially)
standardized.
</p>

<p>
Fixnum/flonum arithmetic is already supported by many systems,
mainly for efficiency.  Standardization of fixnum/flonum
arithmetic would increase the portability of code that uses it,
but we cannot standardize the precision of fixnum/flonum arithmetic
without making it inefficient on some systems, which would defeat
its purpose.  We therefore propose to specify the syntax and much
of the semantics of fixnum/flonum arithmetic, but to make the
precision a parameter of the specification.
</p>

<p>
This SRFI proposes to revise section 6.2 ("Numbers") of R5RS by:
</p>
<ul>
<li>requiring the a Scheme implementation to provide the full tower,
    including exact rationals of arbitrary precision, exact
    rectangular complex numbers where with rational real and imaginary
    parts, and inexact real and complex arithmetic
<li>defining fixnum arithmetic (parameterized by precision)
<li>defining flonum arithmetic (inexactly)
<li>defining new procedures for performing exact arithmetic
<li>defining new procedures for performing inexact arithmetic
<li>describing the external representation and semantics of
    0.0, -0.0, +inf.0, -inf.0, +nan.0, and -nan.0 for systems
    that implement inexact real arithmetic using IEEE binary
    floating point
<li>changing the specification of <code>eqv?</code> to
    behave more sensibly with inexact numbers
<li>defining Scheme's real numbers to be the complex numbers
    whose imaginary part is an exact zero
<li>adding an external representation for inexact numbers
    that expresses the precision of a binary floating point
    representation
<li>restricting the domains of some R5RS procedures
<li>clarifying the semantics of some R5RS procedures
</ul>


<h2>Issues</h2>

<ul>
<li>Instead of requiring the full numeric tower, the R6RS could
    require only the fixnum/flonum base, and make the full tower
    available as modules in the standard library.
<li>The main problem with banishing the full tower to a library
    is that <code>read</code>, <code>write</code>, and several
    other procedures must know about the external representations
    of all numbers.
<li>Should a minimum precision be required for fixnums or flonums?
<li>Should the range of a fixnum be restricted to a power of two?
    To a two's complement range?
<li>Should the binary fixnum/flonums operations allow other than
    two arguments?
<li>What are the semantics of "safe mode" and "unsafe mode"?
    (This is a much larger question that the R6RS should address.)
<li>Should the R5RS procedures for generic arithmetic (e.g. <code>+</code>)
    remain in R6RS?  Here are five possible answers, phrased in
    terms of the <code>+</code> procedure:
    <ol>
    <li><code>+</code> is not defined in R6RS.
    <li><code>+</code> is defined to be a synonym for the <code>ex+</code>,
        so its domain is restricted to exact arguments, and always
        returns an exact result.
    <li><code>+</code> is defined as the union of the <code>ex+</code>
        and <code>in+</code> procedures, so all of its arguments are
        required to have the same exactness, and the exactness of its
        result is the same as the exactness of its arguments.
    <li><code>+</code> is defined as in R5RS, but with the increased
        portability provided by requiring the full numeric tower.
    <li><code>+</code> is defined to return an exact result in all
        cases, even if one or more of its arguments is inexact.
    </ol>
    Will Clinger prefers the 4th possibility, Mike Sperber the 5th.
    Members of the Scheme community should express themselves on this
    issue.
<li>The external representations of 0.0, -0.0, +inf.0, -inf.0, +nan.0,
    and -nan.0 must be specified.  The notations used here are used
    by several other languages, and have been adopted by several
    implementations of Scheme, but other notations are possible.
<li>The fixnum, flonum, and inexact arithmetic come with a full deck
    of operations, including some that are defined in terms of
    integers (such as <code>div+mod</code> and
    <code>quotient+remainder</code>), and others that are easily abused
    (such as <code>fxabs</code>).  Should these be pruned?
<li>The <code>real</code>, <code>rational?</code>, and <code>integer?</code> predicates must
    return <code>#f</code> for complex numbers with an imaginary part
    of inexact zero, as non-realness is now contagious.
    This causes possibly unexpected behavior: <SAMP>`(zero?
    0+0.0i)'</SAMP> returns true despite <SAMP>`(integer?
    0+0.0i)'</SAMP> returning zero.
    In the arithmetic model preferred by Mike, this makes even less
    sense, because inexact complex numbers are implicitly coerced to
    exact ones.
    Possibly, new predicates <code>realistic?</code>,
    <code>rationalistic?</code>, and <code>integral?</code> should be
    added to say that a number can be coerced to the specified type
    (and back) without loss.  It's a mess.
<li>What should <code>flonum->fixnum</code> return for a NaN argument?
<li>The fixnum operations provide efficient fixnums that "wrap."
    However, they do not give efficient access to the hardware facilities
    for carry and overflow.  This would be desirable to implement
    efficient generic arithmetic on fixnums portably.  On the other hand,
    there isn't much experience with formulating an interface to these
    facilities.
<li>The division between regular procedures and library procedures is
    somewhat arbitrary.
<li><strong> (FIXME: several more issues should go here)</strong>
</ul>

<h2>Rationale</h2>

<strong>
(FIXME: most of the rationale is in the abstract)
</strong>

<p>
One of us (Sperber) has argued that Scheme's arithmetic requires
radical overhaul.  The other (Clinger) agrees that revisions are
needed.  This SRFI describes revisions that would satisfy both
of us.  Whether these revisions qualify as radical is best left
to the judgement of individual readers.
</p>

<p>
Most implementations of Scheme fall into
one of the following categories:
</p>
<ul>
<li>fixnums only (now rare except in toy implementations)
<li>fixnums and flonums only
<li>exact rationals and flonums only (no imaginary numbers)
<li>the complete numeric tower
</ul>
Under the R5RS, it is hard to write programs whose arithmetic
is portable across the above categories, and it is unnecessarily
difficult even to write programs whose arithmetic is portable
between different implementations in the same category.

<p>
Many of these portability problems could be made to disappear
by requiring implementations to support the complete numeric
tower, as in Common Lisp.
There has been concern that some implementors might ignore such
a requirement, giving us arithmetic that's portable in theory
but not in practice.
This proposal addresses that concern by defining fixnum and
flonum arithmetic with enough detail to support a portable
implementation of the complete numeric tower.
This approach recognizes the usefulness of fast fixnum/flonum
arithmetic, and fixes some of the things that have made it hard to
construct R5RS-compliant implementations with fast fixnum/flonum
arithmetic.
These changes should benefit both implementors and programmers.
</p>

<p>
This SRFI is incompatible with SRFI-70 in several ways, including:
</p>
<ul>
<li>This SRFI defines a real number to be a complex number whose
    imaginary part is an exact zero.
<li>This SRFI regards +nan.0 as a real number whose value is so
    indeterminate that it might represent any real number within
    the closed interval [-inf.0,+inf.0].
</ul>
Both of the above differences are motivated by closure properties
that make it easier for an implementation to generate efficient
numerical code.

<p>
Moreover, unlike SRFI 70, this SRFI doesn't extend
<code>quotient</code>, <code>remainder</code>, and <code>modulo</code>
to real numbers, but instead provides additional operations
<code>div</code> and <code>mod</code>, which are slightly more
generally applicable and easier to specify.

<h2>Specification</h2>


<h3>External Representations</h3>

<p>
This SRFI adds the following external representations to Scheme:
</p>
<ul>
<li><code>+inf.0</code> represents the result of
    <code>(/ 1.0 0.0)</code>
<li><code>-inf.0</code> represents the result of
    <code>(/ -1.0 0.0)</code>
<li><code>+nan.0</code> represents the result of
    <code>(/ 0.0 0.0)</code>, and may represent other NaNs as well.
    (This SRFI does not require read/write invariance for NaNs.)
<li>If <var>x</var> is an external representation of an inexact
    real number according to the R5RS, and <var>p</var> is a
    sequence of 1 or more decimal digits, then
    <var>x</var>|<var>p</var>
    is an external representation that denotes the
    best binary floating point approximation to <var>x</var>
    using a <var>p</var>-bit significand.
    For example, 1.1|53 is an external representation for the
    best approximation to 1.1 in IEEE double precision.
<li>If <var>x</var> is an external representation of an inexact
    real number according to the R5RS, then <var>x</var> by
    itself should be regarded as equivalent to
    <code><var>x</var>|53</code>.
</ul>

<p>
Implementations that use binary floating point representations
of real numbers should represent <var>x</var>|<var>p</var>
using a <var>p</var>-bit significand if practical, or by a greater
precision if a <var>p</var>-bit significand is not practical, or
by the largest available precision if <var>p</var> or more bits
of significand is not practical within the implementation.
</p>

<BLOCKQUOTE>
<p>
<em>Note:</em>
The precision of a significand should not be confused with the
number of bits used to represent the significand.  In the IEEE
floating point standards, for example, the significand's most
significant bit is implicit in single and double precision but
is explicit in extended precision.  Whether that bit is implicit
or explicit does not affect the mathematical precision.
In implementations that use binary floating point, the default
precision can calculated by calling the following procedure:
</p>
<pre>
    (define (precision)
      (do ((n 0 (+ n 1))
           (x 1.0 (/ x 2.0)))
        ((= 1.0 (+ 1.0 x)) n)))
</pre>
</BLOCKQUOTE>

<BLOCKQUOTE>
<p>
<em>Note:</em>
When the underlying floating-point representation is IEEE double
precision, the |<var>p</var> suffix cannot be omitted for all cases:
Denormalized numbers have diminished precision, and therefore must
carry a |<var>p</var> suffix with the actual width of the signficand.
</BLOCKQUOTE>


<p>
The <code>number-&gt;string</code> procedure should be generalized
to support the <var>x</var>|<var>p</var> notation.
<strong>(FIXME: details, please)</strong>
</p>

<p>
The <code>write</code> procedure should be required to write
inexact numbers in the external representation produced by
<code>number-&gt;string</code> with one argument.
</p>

<h3>Safe and Unsafe Mode</h3>

<p>
The SRFI uses the phrase "all bets are off" to describe that the
behavior of a procedure is unspecified for certain arguments in unsafe
mode.  Specifically, a procedure call for which all bets are off is
free to crash the system.
</p>

<h3><a name="integer-division">Integer Division</a></h3>

<P>
For various kinds of arithmetic (fixnum, flonum, exact, inexact, and
generic), this SRFI provides operations for performing integer
division.  Their variants differ mainly in the domains they operate
on, not in substance.  The following specification is of the general
variant.  Later section will link back to this one where appropriate.
</P>

<P>
<DL>
<DT><U>procedure:</U> <CODE>div+mod</CODE> <I>x1 x2</I>
<DT><U>library procedure:</U> <CODE>div</CODE> <I>x1 x2</I>
<DT><U>library procedure:</U> <CODE>mod</CODE> <I>x1 x2</I>
<DD>

These implement integer division and remainder on real numbers.  
<VAR>x2</VAR> should be non-zero. <CODE>div</CODE> returns an integer.

<PRE>
(div <VAR>x1</VAR> <VAR>x2</VAR>)                  ==&#62; <VAR>n_d</VAR>
(mod <VAR>x1</VAR> <VAR>x2</VAR>)                  ==&#62; <VAR>x_m</VAR>
</PRE>

where:
	<ol>
	  <li><VAR>x1</VAR> = <VAR>n_d</VAR> * <VAR>x2</VAR> +
	  <VAR>x_m</VAR>.</li>
	  <li>0 &lt;= <VAR>x_m</VAR> &lt; <VAR>x2</VAR> if <VAR>y</VAR>
	  &gt; 0</li>
	  <li><VAR>x2</VAR>/2 &lt;= <VAR>x_m</VAR> &lt;
	  -<VAR>x2</VAR>/2 if <VAR>x2</VAR> &lt; 0</li>
	</ol>
Moreover:
<PRE>
(div <VAR>x1</VAR> 0)                  ==&#62; 0
</PRE>	

</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>quotient+remainder</CODE> <I>n1 n2</I>
<DT><U>library procedure:</U> <CODE>quotient</CODE> <I>n1 n2</I>
<DT><U>library procedure:</U> <CODE>remainder</CODE> <I>n1 n2</I>
<DT><U>library procedure:</U> <CODE>modulo</CODE> <I>n1 n2</I>
<DD>

<P>
These procedures implement number-theoretic (integer)
division.  <VAR>n2</VAR> should be non-zero.
All three procedures return integers.
<SAMP>quotient</SAMP>
returns an integer.  If <VAR>n1</VAR>/<VAR>n2</VAR> is an integer:

<PRE>
(quotient <VAR>n1</VAR> <VAR>n2</VAR>)                   ==&#62; <VAR>n1</VAR>/<VAR>n2</VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)                  ==&#62; 0
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)                     ==&#62; 0
</PRE>

If <VAR>n1</VAR>/<VAR>n2</VAR> is not an integer:

<PRE>
(quotient <VAR>n1</VAR> <VAR>n2</VAR>)                   ==&#62; <VAR>n_q</VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)                  ==&#62; <VAR>n_r</VAR>
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)                     ==&#62; <VAR>n_m</VAR>
</PRE>

<P>
where <VAR>n_q</VAR> is <VAR>n1</VAR>/<VAR>n2</VAR> rounded towards zero,
0 &#60; |<VAR>n_r</VAR>| &#60; |<VAR>n2</VAR>|, 0 &#60; |<VAR>n_m</VAR>| &#60; |<VAR>n2</VAR>|,
<VAR>n_r</VAR> and <VAR>n_m</VAR> differ from <VAR>n1</VAR> by a multiple of <VAR>n2</VAR>,
<VAR>n_r</VAR> has the same sign as <VAR>n1</VAR>, and
<VAR>n_m</VAR> has the same sign as <VAR>n2</VAR>.

<P>
From this we can conclude that for integers <VAR>n1</VAR> and <VAR>n2</VAR> with
<VAR>n2</VAR> not equal to 0,

<PRE>
     (= <VAR>n1</VAR> (+ (* <VAR>n2</VAR> (quotient <VAR>n1</VAR> <VAR>n2</VAR>))
           (remainder <VAR>x1</VAR> <VAR>x2</VAR>)))
                                       ==&#62;  #t
</PRE>

provided all numbers involved in that computation are exact.


<PRE>
(quotient+remainder 13 4)              ==&#62;  3 1
(modulo 13 4)                          ==&#62;  1
(remainder 13 4)                       ==&#62;  1

(quotient+remainder -13 4)             ==&#62;  -3 -1
(modulo -13 4)                         ==&#62;  3
(remainder -13 4)                      ==&#62;  -1

(quotient+remainder -13 4)             ==&#62;  -3 1
(modulo 13 -4)                         ==&#62;  -3
(remainder 13 -4)                      ==&#62;  1

(modulo -13 -4)                        ==&#62;  -1
(remainder -13 -4)                     ==&#62;  -1

(quotient+remainder -13 -4.0)          ==&#62;  3.0 -1.0 ; inexact
(remainder -13 -4.0)                   ==&#62;  -1.0     ; inexact
</PRE>

</DD>
</DL>



<h3>Numerical Type Predicates</h3>

<font color=red>
The following description is a revised form of the description
given in SRFI-70.  Changes from SRFI-70 are highlighted in red.
</font>


<P>
<DL>
<DT><U>procedure:</U> <CODE>number?</CODE> <I>obj</I>
<DD>
<DT><U>procedure:</U> <CODE>complex?</CODE> <I>obj</I>
<DD>
<DT><U>procedure:</U> <CODE>real?</CODE> <I>obj</I>
<DD>
<DT><U>procedure:</U> <CODE>rational?</CODE> <I>obj</I>
<DD>
<DT><U>procedure:</U> <CODE>integer?</CODE> <I>obj</I>
<DD>


<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.


<p>
If <VAR>z</VAR> is
<font color=red>a <strike>inexact</strike></font> complex number, then
<SAMP>`(real? <VAR>z</VAR>)'</SAMP> is true if and only if
<SAMP>`(zero? (imag-part <VAR>z</VAR>))'</SAMP>
<font color=red>
and <SAMP>`(exact? (imag-part <VAR>z</VAR>))'</SAMP> are both true</font>.
</p>

<p>
<font color=red>
If <VAR>x</VAR> is a real number, then
<SAMP>`(rational? <VAR>z</VAR>)'</SAMP> is true if and only if
there exist exact integers <var>k1</var> and <var>k2</var>
such that
<SAMP>`(= <var>z</var> (/ <var>k1</var> <var>k2</var>))'</SAMP>
and
<SAMP>`(= (numerator <var>z</var>) <var>k1</var>)'</SAMP>
and
<SAMP>`(= (denominator <var>z</var>) <var>k2</var>)'</SAMP>
are all true.
Thus infinities and NaNs are not rational numbers.
</font>
</p>

If <VAR>r1</VAR> is <font color=red>a rational</font> number, then
<SAMP>`(integer? <VAR>x</VAR>)'</SAMP> is true if and only if
<font color=red>
<SAMP>`(= (denominator <VAR>r1</VAR>) 1)'</SAMP>
is true.
</font>

<PRE>
(complex? 3+4i)                        ==&#62;  #t
(complex? 3)                           ==&#62;  #t
(real? 3)                              ==&#62;  #t
(real? -2.5+0.0i)                      ==&#62;  <font color=red>#f</font>
<font color=red>(real? -2.5+0i)                        ==&#62;  #t</font>
(real? -2.5)                           ==&#62;  #t
(real? #e1e10)                         ==&#62;  #t
<font color=red>(real? -inf.0)                         ==&#62;  #t</font>
<font color=red>(real? +nan.0)                         ==&#62;  #t</font>
<font color=red>(rational? -inf.0)                     ==&#62;  #f</font>
<font color=red>(rational? +nan.0)                     ==&#62;  #f</font>
(rational? 6/10)                       ==&#62;  #t
(rational? 6/3)                        ==&#62;  #t
(integer? 3+0i)                        ==&#62;  #t
(integer? 3.0)                         ==&#62;  #t
(integer? 8/4)                         ==&#62;  #t

(number? <font color=red>+nan.0</font>)                       ==>  #t
(complex? <font color=red>+nan.0</font>)                      ==>  <font color=red>#t</font>
(complex? <font color=red>+inf.0</font>)                      ==>  #t
(real? <font color=red>+nan.0</font>)                         ==>  <font color=red>#t</font>
(real? <font color=red>-inf.0</font>)                         ==>  #t
(rational? <font color=red>+inf.0</font>)                     ==>  #f
(rational? <font color=red>+nan.0</font>)                     ==>  #f
(integer? <font color=red>-inf.0</font>)                      ==>  #f
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
The behavior of these type predicates on inexact numbers is
unreliable, because any inaccuracy may
affect the result.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<strike>
<font color=red>
<EM>Note:</EM>
In many implementations the <CODE>rational?</CODE> procedure will be the same

as <CODE>real?</CODE>, and the <CODE>complex?</CODE> procedure will be the same as


<CODE>number?</CODE>, but unusual implementations may be able to represent

some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.
</font>
</strike>
</BLOCKQUOTE>

</DL>






<h3>Fixnums</h3>

<p>
Every implementation must define its fixnum range as a closed
interval [<var>lo</var>, <var>hi</var>] such that <var>lo</var>
and <var>hi</var> are (mathematical) integers with
<var>lo</var> &lt;= 0 &lt; 1 &lt;= <var>hi</var>.
Every mathematical integer within an implementation's fixnum
range must correspond to an exact integer that is representable
within the implementation.
The fixnum operations of an implementation will perform
arithmetic modulo <var>hi-lo+1</var>.
</p>

<p>
<strong>Definition.</strong>
A fixnum is an exact integer whose value lies within the fixnum
range.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fixnum?</CODE> <I>obj</I>
<DD>

<P>This returns <TT>#t</TT> if <I>obj</I> is a fixnum, and
otherwise returns <TT>#f</TT>.
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>least-fixnum</CODE>
<DT><U>procedure:</U> <CODE>greatest-fixnum</CODE>
<DD>

<P>These procedures return <var>lo</var> and <var>hi</var>, the
minimum and the maximum value of the fixnum range, respectively.
</DL>


<P>
We will use <var>fx</var>, <var>fx1</var> and <var>fx2</var> as metavariables
that range over fixnums.
</P>
<p>
If an argument to following procedures that corresponding to a fixnum
metavariable is not actually a fixnum, then these procedures signal an
error, unless the implementation is running in unsafe mode, in which
case all bets are off.
</p>


<P>
<DL>
<DT><U>procedure:</U> <CODE>fx=</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fx&gt;</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fx&lt;</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fx&gt;=</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fx&lt;=</CODE> <I>fx1 fx2</I>
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>fxzero?</CODE> <I><VAR>fx</VAR></I>
<DD>
<DT><U>library procedure:</U> <CODE>fxpositive?</CODE> <I><VAR>fx</VAR></I>
<DD>
<DT><U>library procedure:</U> <CODE>fxnegative?</CODE> <I><VAR>fx</VAR></I>
<DD>
<DT><U>library procedure:</U> <CODE>fxodd?</CODE> <VAR>fx</VAR>
<DD>
<DT><U>library procedure:</U> <CODE>fxeven?</CODE> <VAR>fx</VAR>
<DD>


<P>
These numerical predicates test a fixnum for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxmax</CODE> <I>fx1 fx2</I>
<DD>
<DT><U>library procedure:</U> <CODE>fxmin</CODE> <I>fx1 fx2</I>
<DD>


<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fx+</CODE> <I>fx1 fx2</I>
<DD>
<DT><U>procedure:</U> <CODE>fx-</CODE> <I>fx1 fx2</I>
<DD>
<DT><U>procedure:</U> <CODE>fx*</CODE> <I>fx1 fx2</I>
<DD>

<P>
These procedures return the unique fixnum that is congruent
mod <var>hi-lo+1</var> to the sum, difference, or product of
their arguments.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxabs</CODE> <VAR>fx</VAR>
<DD>

<P>
This procedure returns <SAMP>`(fx- 0 <VAR>fx</VAR>)'</SAMP> if
<VAR>fx</VAR> is negative, <VAR>fx</VAR> otherwise.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxdiv+mod</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxdiv</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxmod</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxquotient</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxmodulo+remainder</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxmodulo</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxremainder</CODE> <I>fx1 fx2</I>
<DD>

<P>
These procedures implement number-theoretic integer division congruent
mod <var>hi-lo+1</var>.  See <a href="#integer-division">the
Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxgcd</CODE> <I>fx1 fx2</I>
<DT><U>library procedure:</U> <CODE>fxlcm</CODE> <I>fx1 fx2</I>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments congruent
mod <var>hi-lo+1</var>.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxbitwise-not</CODE> <I>fx</I>
<DD>
<P>
Returns the fixnum which is the one's-complement of its argument.
congruent mod <var>hi-lo+1</var>.
</DD>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>fxbitwise-and</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fxbitwise-ior</CODE> <I>fx1 fx2</I>
<DT><U>procedure:</U> <CODE>fxbitwise-xor</CODE> <I>fx1 fx2</I>
<DD>
<P>
The <CODE>fxbitwise-and</CODE> procedure returns the fixnum which is the bit-wise "and" of its
arguments congruent mod <var>hi-lo+1</var>.
The <CODE>fxbitwise-ior</CODE> procedure returns the fixnum which is the bit-wise "or" of its
arguments congruent mod <var>hi-lo+1</var>.
The <CODE>fxbitwise-xor</CODE> procedure returns the fixnum which is the
bit-wise "exlusive or" of its arguments congruent mod <var>hi-lo+1</var>.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxarithmetic-shift</CODE> <I>fx1</I> <I>fx2</I>
<DD>
<P>
Conceptually shifts the two's complement representation of
<VAR>fx1</VAR> <VAR>fx2</VAR> bits left when <VAR>fx2</VAR> &gt; 0,
and -<VAR>fx2</VAR> bits right when <VAR>fx2</VAR> &lt; 0, extending
the sign.  (It returns <VAR>fx1</VAR> when <VAR>fx2</VAR> = 0.)  It
returns the result of that shift congruent mod <var>hi-lo+1</var>.
</DD>
</DL>


<h3>Flonums</h3>

<p>
<strong>Definition.</strong>
A flonum is an inexact real.
</p>

<p>
Please note that this definition does not imply any particular
representation for a flonum.  In particular, it does not imply
that flonums are represented by any kind of floating point
format.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flonum?</CODE> <I>obj</I>
<DD>

<P>This returns <TT>#t</TT> if <I>obj</I> is a flonum, and
otherwise returns <TT>#f</TT>.
</DL>


<p>
We will use <var>fl</var>, <var>fl1</var> and <var>fl2</var> as
metavariables that range over flonums, and <var>ifl</var>,
<var>ifl1</var> and <var>ifl2</var> as metavariables that range over
integral flonums, i.e. flonums that represent integers.
</p>
<p>
If an argument to following procedures that corresponding to a
(integral) flonum metavariable is not actually a (integral) flonum,
then these procedures signal an error, unless the implementation is
running in unsafe mode, in which case all bets are off.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fl=</CODE> <I>fl1 fl2</I>
<DD>
<DT><U>procedure:</U> <CODE>fl&lt;</CODE> <I>fl1 fl2</I>
<DD>
<DT><U>procedure:</U> <CODE>fl&lt;=</CODE> <I>fl1 fl2</I>
<DD>
<DT><U>procedure:</U> <CODE>fl&gt;</CODE> <I>fl1 fl2</I>
<DD>
<DT><U>procedure:</U> <CODE>fl&gt;=</CODE> <I>fl1 fl2</I>
<DD>


<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.  These
predicates are required to be transitive.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flinteger?</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flzero?</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flpositive?</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flnegative?</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flodd?</CODE> <I>ifl</I>
<DT><U>procedure:</U> <CODE>fleven?</CODE> <I>ifl</I>
<DT><U>procedure:</U> <CODE>flnan?</CODE> <I>ifl</I>
<DD>


<P>
These numerical predicates test a fixnum for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flmax</CODE> <I>fl1 fl2</I>
<DT><U>procedure:</U> <CODE>flmin</CODE> <I>fl1 fl2</I>
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fl+</CODE> <I>fl1 fl2</I>
<DT><U>procedure:</U> <CODE>fl-</CODE> <I>fl1 fl2</I>
<DT><U>procedure:</U> <CODE>fl*</CODE> <I>fl1 fl2</I>
<DT><U>procedure:</U> <CODE>fl/</CODE> <I>fl1 fl2</I>
<DD>


<P>
These procedures return the inexact real sum, difference,
product, or quotient of their inexact real arguments.
In general, they should return the flonum that best
approximates the mathematical sum of their arguments.
(For implementations that represent flonums as IEEE
binary floating point numbers, the meaning of "best"
is reasonably well-defined by the IEEE standards.)
</P>

<P>
For undefined quotients, <code>fl-</code> behaves as specified by the
IEEE standards:

<PRE>
(fl/ 1.0 0.0)  ==> +inf.0
(fl/ -1.0 0.0) ==> -inf.0
(fl/ 0.0 0.0)  ==> +nan.0
</PRE>
</dl>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flabs</CODE> <I>fl</I>
<DD>
<P>
This returns the absolute value of its argument.
<P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fldiv+mod</CODE> <I>fl1 fl2</I>
<DT><U>library procedure:</U> <CODE>fldiv</CODE> <I>fl1 fl2</I>
<DT><U>library procedure:</U> <CODE>flmod</CODE> <I>fl1 fl2</I>
<DT><U>library procedure:</U> <CODE>flquotient</CODE> <I>ifl1 ifl2</I>
<DT><U>library procedure:</U> <CODE>flmodulo+remainder</CODE> <I>ifl1 ifl2</I>
<DT><U>library procedure:</U> <CODE>flmodulo</CODE> <I>ifl1 ifl2</I>
<DT><U>library procedure:</U> <CODE>flremainder</CODE> <I>ifl1 ifl2</I>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>flgcd</CODE> <I>ifl1 ifl2</I>
<DT><U>library procedure:</U> <CODE>fllcm</CODE> <I>ifl1 ifl2</I>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>flnumerator</CODE> <I>ifl</I>
<DT><U>library procedure:</U> <CODE>fldenominator</CODE> <I>ifl</I>
<DD>
<P>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flfloor</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flceiling</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>fltruncate</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flround</CODE> <I>fl</I>
<DD>
<P>
These procedures return integral flonums.
<CODE>Flfloor</CODE> returns the largest integral flonum not larger than <VAR>fl</VAR>.
<CODE>Flceiling</CODE> returns the smallest integral flonum not smaller than <VAR>fl</VAR>.
<CODE>Fltruncate</CODE> returns the integral flonum closest to <VAR>fl</VAR> whose absolute
value is not larger than the absolute value of <VAR>fl</VAR>.  <CODE>Flround</CODE> returns the
closest integral flonum to <VAR>fl</VAR>, rounding to even when <VAR>fl</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Flround</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>

</dl>


<P>
<DL>
<DT><U>procedure:</U> <CODE>flexp</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>fllog</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flsin</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flcos</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>fltan</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flasin</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flatan1</CODE> <I>fl</I>
<DT><U>procedure:</U> <CODE>flatan2</CODE> <I>fl1 fl2</I>
<DD>

<P>
These procedures compute the usual transcendental functions.  <CODE>Fllog</CODE>
computes the natural logarithm of <VAR>fl</VAR> (not the base ten logarithm).
<CODE>Flasin</CODE>, <CODE>Flacos</CODE>, and <CODE>Flatan1</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant <CODE>flatan2</CODE> computes <SAMP>`(inangle
(inmake-rectangular <VAR>fl1</VAR> <VAR>fl2</VAR>))'</SAMP> (see below)<font
color="red"><STRIKE>, even in implementations
that don't support general complex numbers</STRIKE></font>.


<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>fl</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>fl</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)

<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to <SAMP>+inf.0</SAMP>.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to <SAMP>-inf.0</SAMP>.


The procedures <CODE>flsin</CODE>, <CODE>flcos</CODE>, <CODE>fltan</CODE>,
<CODE>flasin</CODE>, and <CODE>flacos</CODE> <font color="red"><STRIKE>either</STRIKE></FONT> return
<CODE>+nan.0</CODE><font color="red"><STRIKE> or
report a violation of an implementation restriction</STRIKE></FONT>
<font color="red">return some meaningless inexact real number</FONT> when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>
In the event that these formulae do
not yield a real result for the given arguments, the
result may be <code>+nan.0</code>, or may be some meaningless flonum.

<P>
Implementations that use IEEE binary floating point
arithmetic are encouraged to follow the relevant
standards for these procedures.

<P>
The above specification follows <A HREF="r5rs_13.html#BIB27">[CLtL]</A>, which in turn
cites <A HREF="r5rs_13.html#BIB19">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.

<PRE>
(flexp +inf.0)                ==&gt; +inf.0
(flexp -inf.0)                ==&gt; 0.0
(fllog +inf.0)                ==&gt; +inf.0
(fllog 0.0)                   ==&gt; -inf.0
(fllog -inf.0)                ==&gt; +nan.0
(flatan1 -inf.0)              ==&gt; -1.5707963267948965
(flatan2 +inf.0)              ==&gt; 1.5707963267948965
</PRE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flsqrt</CODE> <I>fl</I>
<DD>
<P>
Returns the principal square root of <VAR>z</VAR>.  The result is
undefined for negative arguments.
Implementations that use IEEE binary floating point
arithmetic are encouraged to return <SAMP>+nan.0</SAMP> in this case.

<PRE>
(flsqrt +inf.0)               ==>  inf.0
</PRE>

</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>flexpt</CODE> <I>fl1</I> <I>fl2</I>
<DD>
<p>
Returns <VAR>fl1</VAR> raised to the power <VAR>fl2</VAR>.
For <VAR>fl1</VAR><SUB>1</SUB> ~= 0

<P>
<VAR>fl1</VAR><SUP><VAR>fl2</VAR></SUP> = e<SUP><VAR>z2</VAR> log <VAR>z1</VAR></SUP>

<P>
0<SUP><VAR>fl</VAR></SUP> is 1 if <VAR>z</VAR> = 0, and 0 if
<VAR>fl</VAR> is positive.  
Otherwise, this procedure reports a violation of an implementation restriction
or returns an unspecified number.
</DL>

<h3>Conversions</h3>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fixnum-&gt;flonum</CODE> <I>fx1</I>
<DD>
<DT><U>procedure:</U> <CODE>flonum-&gt;fixnum</CODE> <I>fl1</I>
<DD>

<p>
The <code>fixnum-&gt;flonum</code>
and <code>flonum-&gt;fixnum</code>
procedures provide for explicit conversions
between fixnums and flonums.
Programmers should understand that these procedures
cannot be expected to return results that are
numerically equal to their arguments.
</p>

<p>
For example, suppose the fixnum range is [-8388608,8388607]
and flonums are represented in IEEE double precision.  Then
</p>
<pre>
(fixnum-&gt;flonum 8388608)         =&gt; 8388608.0
(flonum-&gt;fixnum 3.14159265)      =&gt; 3
(flonum-&gt;fixnum -inf.0)          =&gt; -8388608
(flonum-&gt;fixnum 1e20)            =&gt; 8388607
</pre>

<p>
If the argument to these procedures is not actually
a flonum, then these procedures signal an error, unless
the implementation is running in unsafe mode, in which
case all bets are off.
</p>

</dl>

<h3>
IEEE Binary Floating Arithmetic
</h3>

<p>
Although the R6RS should not require IEEE floating point arithmetic,
it should address certain specific issues of IEEE arithmetic.  In
particular, the R6RS should explain that
</p>
<pre>
    0.0
   -0.0
   +inf.0
   -inf.0
   +nan.0
</pre>
<p>
are likely to be distinct flonums.  The first two are inexact
rationals, but <code>+inf.0</code>, <code>-inf.0</code>, and
<code>+nan.0</code> are not rationals.
The R6RS should also explain that
</p>
<pre>
    (fl= 0.0 -0.0)                                =&gt;  #t
    (fl< -0.0 0.0)                                =&gt;  #f
    (fl= +nan.0 +nan.0)                           =&gt;  #f
</pre>
<p>
is required by the IEEE standards, and is strongly recommended
but not required by the R6RS.
</p>

<p>
The R6RS specification of eqv? should be changed so that
</p>
<pre>
    (eqv? -0.0 0.0)                             =&gt;  #f
</pre>
<p>
and to allow (but not require)
<code>(eqv? <var>x y</var>)</code> to evaluate to <code>#t</code>
when <var>x</var> and <var>y</var> are NaNs.
</p>

<p>
Note that <code>(flnegative? -0.0)</code> must return <code>#f</code>,
else it would lose the correspondence with
<code>(fl< -0.0 0.0)</code>, which is <code>#f</code>
according to the IEEE standards.
</p>


<h3>Exact Arithmetic</h3>

<p>
The exact arithmetic provides generic operations on exact numbers;
these operations correspond to their mathematical counterparts.  The
exact numbers include rationals of arbitrary precision, and exact
rectangular complex numbers.  A rational number with a denominator of
1 is indistinguishable from its numerator.  An exact rectangular
complex number with a zero imaginary part is indistinguishable from
its real part.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exnumber?</CODE> <I>ex</I>
<DT><U>procedure:</U> <CODE>excomplex?</CODE> <I>ex</I>
<DT><U>procedure:</U> <CODE>exrational?</CODE> <I>ex</I>
<DT><U>procedure:</U> <CODE>exinteger?</CODE> <I>ex</I>
<DD>
<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
an exact number of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
</P>
</DL>

<p>
We will use <var>ex</var>, <var>ex1</var>, <var>ex2</var>, and
<var>ex3</var> as metavariables that range over the exact complex
numbers,
<var>ef</var>, <var>ef1</var>, <var>ef2</var>, and
<var>ef3</var> as metavariables that range over the exact rational
numbers,
and
<var>ei</var>, <var>ei1</var>, <var>ei2</var>, and
<var>ei3</var> as metavariables that range over the exact rational
numbers,
</p>

<p>
If an argument to following procedures that corresponding to an exact
metavariable is not actually an exact number, then these procedures signal an
error.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex=</CODE> <I>ex1 ex2 ex3 ...</I>
<DT><U>procedure:</U> <CODE>ex&gt;</CODE> <I>er1 er2 er3 ...</I>
<DT><U>procedure:</U> <CODE>ex&lt;</CODE> <I>er1 er2 er3 ...</I>
<DT><U>procedure:</U> <CODE>ex&gt;=</CODE> <I>er1 er2 er3 ...</I>
<DT><U>procedure:</U> <CODE>ex&lt;=</CODE> <I>er1 er2 er3 ...</I>
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>exzero?</CODE> <I><VAR>ex</VAR></I>
<DT><U>library procedure:</U> <CODE>expositive?</CODE> <I><VAR>ef</VAR></I>
<DT><U>library procedure:</U> <CODE>exnegative?</CODE> <I><VAR>ef</VAR></I>
<DT><U>library procedure:</U> <CODE>exodd?</CODE> <VAR>ei</VAR>
<DT><U>library procedure:</U> <CODE>exeven?</CODE> <VAR>ei</VAR>
<DD>

<P>
These numerical predicates test an exact number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exmax</CODE> <I>ef1 ef2 ...</I>
<DT><U>library procedure:</U> <CODE>exmin</CODE> <I>ef1 ef2 ...</I>
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex+</CODE> <I>ex1 ex2 ...</I>
<DT><U>procedure:</U> <CODE>ex*</CODE> <I>ex1 ex2 ...</I>
<DD>

<P>
These procedures return the sum or product of their arguments.
</p>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex-</CODE> <I>ex1 ex2 ...</I>
<DT><U>procedure:</U> <CODE>ex-</CODE> <I>ex</I>
<DT><U>procedure:</U> <CODE>ex/</CODE> <I>ex1 ex2 ...</I>
<DT><U>procedure:</U> <CODE>ex/</CODE> <I>ex</I>
<DD>

<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exabs</CODE> <VAR>ef</VAR>
<DD>

<P>
This procedure returns the absolute value of its argument.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exdiv+mod</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>exdiv</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>exmod</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>exquotient</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>exmodulo+remainder</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>exmodulo</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>exremainder</CODE> <I>ei1 ei2</I>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exgcd</CODE> <I>ei1 ei2 ...</I>
<DT><U>library procedure:</U> <CODE>exlcm</CODE> <I>ei1 ei2 ...</I>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments, which must be exact integers.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exnumerator</CODE> <I>ef</I>
<DT><U>library procedure:</U> <CODE>exdenominator</CODE> <I>ef</I>
<DD>
<P>
The procedures return the numerator or denominator of their argument.
The result is computed as if the argument was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exfloor</CODE> <I>ef</I>
<DT><U>procedure:</U> <CODE>exceiling</CODE> <I>ef</I>
<DT><U>procedure:</U> <CODE>extruncate</CODE> <I>ef</I>
<DT><U>procedure:</U> <CODE>exround</CODE> <I>ef</I>
<DD>
<P>
These procedures return exact integers.
<CODE>Exfloor</CODE> returns the largest integer not larger than <VAR>ef</VAR>.
<CODE>Exceiling</CODE> returns the smallest integer not smaller than <VAR>ef</VAR>.
<CODE>Extruncate</CODE> returns the integer closest to <VAR>ef</VAR> whose absolute
value is not larger than the absolute value of <VAR>ef</VAR>.  <CODE>Exround</CODE> returns the
closest integer to <VAR>ef</VAR>, rounding to even when <VAR>ef</VAR> is halfway between two
integers.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>exexpt</CODE> <I>ex1</I> <I>ex2</I>
<DD>
<p>
Returns <VAR>ex1</VAR> raised to the power <VAR>ex2</VAR>.
<VAR>ex1</VAR> must be an exact rational, and <VAR>ex2</VAR> an exact
integer.
0<SUP><VAR>x</VAR></SUP> is 1 if <VAR>x</VAR> = 0 and 0 otherwise.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>exmake-rectangular</CODE> <I>ef1</I> <I>ef2</I>
<DT><U>procedure:</U> <CODE>exreal-part</CODE> <I>ex</I>
<DT><U>procedure:</U> <CODE>eximag-part</CODE> <I>ex</I>
<DD>
<p>
The arguments of <code>exmake-rectangular</code> must be exact
rationals.  Suppose <VAR>z</VAR> is a complex number such that
<VAR>z</VAR> = <VAR>ef1</VAR> + <VAR>ef1</VAR>*i.  Then:
<PRE>
(make-rectangular <VAR>ef1</VAR> <VAR>ef2</VAR>) =&gt; <VAR>z</VAR>
(real-part <VAR>z</VAR>)              =&gt; <VAR>ef1</VAR>
(imag-part <VAR>z</VAR>)              =&gt; <VAR>ef2</VAR>
</PRE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exbitwise-not</CODE> <I>ei</I>
<DD>
<P>
Returns the one's-complement of its argument.
</DD>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>exbitwise-and</CODE> <I>ei1 ei2 ...</I> 
<DT><U>procedure:</U> <CODE>exbitwise-ior</CODE> <I>ei1 ei2 ...</I>
<DT><U>procedure:</U> <CODE>exbitwise-xor</CODE> <I>ei1 ei2 ...</I>
<DD>
<P>
The arguments for these procedures must be exact integers; an error is
signalled if any argument is not.
The <code>exbitwise-and</code> procedure returns the exact integer which is the bit-wise "and" of its
arguments.
The <code>exbitwise-ior</code> procedure returns the exact integer which is the bit-wise "or" of its
arguments.
The <code>exbitwise-xor</code> procedure returns the exact integer which is the
bit-wise "exlusive or" of its arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exarithmetic-shift</CODE> <I>ei1</I> <I>ei2</I>
<DD>
<P>
Both arguments must be exact integers; an error is signalled if either
argument is not.
Conceptually shifts the two's complement representation of
<VAR>ei1</VAR> <VAR>ei2</VAR> bits left when <VAR>ex2</VAR> &gt; 0,
and -<VAR>ei2</VAR> bits right when <VAR>ei2</VAR> &lt; 0, extending
the sign.  It returns <VAR>ei1</VAR> when <VAR>ei2</VAR> = 0.
</DD>
</DL>

<h3>Inexact Arithmetic</h3>

<p>
The inexact arithmetic provides generic operations on inexact numbers.  The
inexact numbers include reals and inexact complex numbers, both of
which are distinguishable from the exact numbers.  The inexact reals
include the flonums, and the procedures described here behave
consistently with the corresponding flonum procedures if passed flonum
arguments.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>innumber?</CODE> <I>obj</I>
<DT><U>procedure:</U> <CODE>incomplex?</CODE> <I>obj</I>
<DT><U>procedure:</U> <CODE>inreal?</CODE> <I>obj</I>
<DT><U>procedure:</U> <CODE>inrational?</CODE> <I>obj</I>
<DT><U>procedure:</U> <CODE>ininteger?</CODE> <I>obj</I>
<DD>
<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
an inexact number of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
</P>
</DL>

<p>
We will use <var>in</var>, <var>in1</var>, <var>in2</var>, and
<var>in3</var> as metavariables that range over the inexact numbers,
<var>ir</var>, <var>ir1</var>, <var>ir2</var>, and <var>ir3</var> as
metavariables that range over the inexact real numbers,
<var>if</var>, <var>if1</var>, <var>if2</var>, and <var>if3</var> as
metavariables that range over the inexact rationals. and
<var>ii</var>, <var>ii1</var>, <var>ii2</var>, and <var>ii3</var> as
metavariables that range over the inexact integers.
</p>

<p>
If an argument to following procedures that corresponding to an inexact
metavariable is not actually an inexact number, then these procedures signal an
error.  The same holds true for arguments corresponding to inexact
real metavariables.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in=</CODE> <I>in1 in2 in3 ...</I>
<DT><U>procedure:</U> <CODE>in&gt;</CODE> <I>ir1 ir2 ir3 ...</I>
<DT><U>procedure:</U> <CODE>in&lt;</CODE> <I>ir1 ir2 ir3 ...</I>
<DT><U>procedure:</U> <CODE>in&gt;=</CODE> <I>ir1 ir2 ir3 ...</I>
<DT><U>procedure:</U> <CODE>in&lt;=</CODE> <I>ir1 ir2 ir3 ...</I>
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>inzero?</CODE> <I>in</I>
<DT><U>library procedure:</U> <CODE>inpositive?</CODE> <I>ir</I>
<DT><U>library procedure:</U> <CODE>innegative?</CODE> <I>ir</I>
<DT><U>library procedure:</U> <CODE>inodd?</CODE> <I>ii</I>
<DT><U>library procedure:</U> <CODE>ineven?</CODE> <I>ii</I>
<DD>

<P>
These numerical predicates test an inexact number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>inmax</CODE> <I>ir1 ir2 ...</I>
<DT><U>library procedure:</U> <CODE>inmin</CODE> <I>ir1 ir2 ...</I>
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in+</CODE> <I>in1 in2 ...</I>
<DT><U>procedure:</U> <CODE>in*</CODE> <I>in1 in2 ...</I>
<DD>

<P>
These procedures return the sum or product of their arguments.
</p>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in-</CODE> <I>in1 in2 ...</I>
<DT><U>procedure:</U> <CODE>in-</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>in/</CODE> <I>in1 in2 ...</I>
<DT><U>procedure:</U> <CODE>in/</CODE> <I>in</I>
<DD>

<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>inabs</CODE> <VAR>in</VAR>
<DD>

<P>
This procedure returns the absolute value of its argument.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>indiv+mod</CODE> <I>ir1 ir2</I>
<DT><U>library procedure:</U> <CODE>indiv</CODE> <I>ir1 ir2</I>
<DT><U>library procedure:</U> <CODE>inmod</CODE> <I>ir1 ir2</I>
<DT><U>library procedure:</U> <CODE>inquotient</CODE> <I>ii1 ii2</I>
<DT><U>library procedure:</U> <CODE>inmodulo+remainder</CODE> <I>ii1 ii2</I>
<DT><U>library procedure:</U> <CODE>inmodulo</CODE> <I>ii1 ii2</I>
<DT><U>library procedure:</U> <CODE>inremainder</CODE> <I>ii1 ii2</I>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>ingcd</CODE> <I>ii1 ii2 ...</I>
<DT><U>library procedure:</U> <CODE>inlcm</CODE> <I>ii1 ii2 ...</I>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>innumerator</CODE> <I>if</I>
<DT><U>library procedure:</U> <CODE>indenominator</CODE> <I>if</I>
<DD>
<P>
The procedures return the numerator or denominator of their argument.
The result is computed as if the argument was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>infloor</CODE> <I>ir</I>
<DT><U>procedure:</U> <CODE>inceiling</CODE> <I>ir</I>
<DT><U>procedure:</U> <CODE>intruncate</CODE> <I>ir</I>
<DT><U>procedure:</U> <CODE>inround</CODE> <I>ir</I>
<DD>
<P>
These procedures return inexact integers on inexact rational
arguments.

<CODE>Infloor</CODE> returns the largest integer not larger than <VAR>ir</VAR>.
<CODE>Inceiling</CODE> returns the smallest integer not smaller than <VAR>ir</VAR>.
<CODE>Intruncate</CODE> returns the integer closest to <VAR>in</VAR> whose absolute
value is not larger than the absolute value of <VAR>in</VAR>.  <CODE>Inround</CODE> returns the
closest integer to <VAR>in</VAR>, rounding to even when <VAR>in</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Round</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>inexp</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inlog</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>insin</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>incos</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>intan</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inasin</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inatan</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inatan</CODE> <I>ir1 ir2</I>
<DD>

<P>
These procedures compute the usual transcendental functions.  <CODE>Inlog</CODE>
computes the natural logarithm of <VAR>in</VAR> (not the base ten logarithm).
<CODE>Inasin</CODE>, <CODE>Inacos</CODE>, and <CODE>Inatan</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant of <CODE>Inatan</CODE> computes <SAMP>`(inangle
(inmake-rectangular <VAR>ir1</VAR> <VAR>ir2</VAR>))'</SAMP> (see below).

<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>z</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>z</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)

<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to <SAMP>+inf.0</SAMP>.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to <SAMP>-inf.0</SAMP>.


The procedures <CODE>insin</CODE>, <CODE>incos</CODE>, <CODE>intan</CODE>,
<CODE>inasin</CODE>, and <CODE>inacos</CODE> <font color="red"><STRIKE>either</STRIKE></FONT> return
<CODE>+nan.0</CODE><font color="red"><STRIKE> or
report a violation of an implementation restriction</STRIKE></FONT>
<font color="red">return some meaningless inexact real number</FONT> when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>
Implementations that use IEEE binary floating point
arithmetic are encouraged to follow the relevant
standards for these procedures.

<P>
The above specification follows <A HREF="r5rs_13.html#BIB27">[CLtL]</A>, which in turn
cites <A HREF="r5rs_13.html#BIB19">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>inexpt</CODE> <I>in1</I> <I>in2</I>
<DD>
<p>
Returns <VAR>in1</VAR> raised to the power <VAR>in2</VAR>.
The result is
undefined for <VAR>fl1</VAR> = 0 and <VAR>fl2</VAR> = 0
Implementations that use IEEE binary floating point
arithmetic are encouraged to return <SAMP>+nan.0</SAMP> in this case.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>inmake-rectangular</CODE> <I>ir1</I> <I>ir2</I>
<DT><U>procedure:</U> <CODE>inmake-polar</CODE> <I>ir1</I> <I>ir2</I>
<DT><U>procedure:</U> <CODE>inreal-part</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inimag-part</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inmagnitude</CODE> <I>in</I>
<DT><U>procedure:</U> <CODE>inangle</CODE> <I>in</I>
<DD>
<p>
Suppose 
<VAR>in1</VAR>, <VAR>in2</VAR>, <VAR>in3</VAR>, and <VAR>in4</VAR>
are inexact rational numbers, and
<VAR>z</VAR> is a complex number,
such that
<VAR>z</VAR> = <VAR>in1</VAR> + <VAR>in1</VAR>*i = <VAR>in3</VAR> *
e<SUP>i*<VAR>in4</VAR></SUP>.  Then (inexactly):
<PRE>
(inmake-rectangular <VAR>in1</VAR> <VAR>in2</VAR>) =&gt; <VAR>z</VAR>
(inmake-rectangular <VAR>in3</VAR> <VAR>in4</VAR>) =&gt; <VAR>z</VAR>
(inreal-part <VAR>z</VAR>)              =&gt; <VAR>in1</VAR>
(inimag-part <VAR>z</VAR>)              =&gt; <VAR>in2</VAR>
(inmagnitude <VAR>z</VAR>)              =&gt; |<VAR>in3</VAR>|
(inangle <VAR>z</VAR>)                  =&gt; <VAR>in<SUB>angle</SUB></VAR>
</PRE>
where -pi &lt; x_angle &lt;= pi with <VAR>in<SUB>angle</SUB></VAR> = <VAR>in4</VAR> + 2pi <VAR>n</VAR>
for some integer <VAR>n</VAR>.

<P>
The behavior of <CODE>inmake-rectangular</CODE> and
<CODE>inmake-polar</CODE> given non-rational arguments is unspecified.
</DL>

<h3>R5RS-style Generic Arithmetic</h3>

<font color=red>
The following description is a revised form of the description
given in SRFI 70.  Changes from SRFI 70 are highlighted in red.
</font>

<P>
<DL>
<DT><U>procedure:</U> <CODE>=</CODE> <I>z1 z2 z3 ...</I>
<DT><U>procedure:</U> <CODE>&#60;</CODE> <I>x1 x2 x3 ...</I>
<DT><U>procedure:</U> <CODE>&#62;</CODE> <I>x1 x2 x3 ...</I>
<DT><U>procedure:</U> <CODE>&#60;=</CODE> <I>x1 x2 x3 ...</I>
<DT><U>procedure:</U> <CODE>&#62;=</CODE> <I>x1 x2 x3 ...</I>
<DD>


<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

<PRE>
(= +inf.0 +inf.0)           ==&gt;  #t
(= -inf.0 +inf.0)           ==&gt;  #f
(= -inf.0 -inf.0)           ==&gt;  #t
<FONT COLOR=red><STRIKE>(= 0/0 0/0)                 ==>  #t</STRIKE></FONT>
</PRE>

For any rational number <VAR>x</VAR>:

<PRE>
(&lt -inf.0 <VAR>x</VAR> +inf.0))        ==>  #t
(&gt +inf.0 <VAR>x</VAR> -inf.0))        ==>  #t
</PRE>

<P>
These predicates are required to be transitive.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
While it is not an error to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of <CODE>=</CODE> and <CODE>zero?</CODE>.


When in doubt, consult a numerical analyst.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>zero?</CODE> <I><VAR>z</VAR></I>
<DT><U>library procedure:</U> <CODE>positive?</CODE> <I><VAR>x</VAR></I>
<DT><U>library procedure:</U> <CODE>negative?</CODE> <I><VAR>x</VAR></I>
<DT><U>library procedure:</U> <CODE>odd?</CODE> <VAR>n</VAR>
<DT><U>library procedure:</U> <CODE>even?</CODE> <VAR>n</VAR>
<DD>


<P>
These numerical predicates test a number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.  See note above.

<PRE>
(positive? +inf.0)            ==>  #t
(negative? -inf.0)            ==>  #t
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>max</CODE> <I>x1 x2 ...</I>
<DT><U>library procedure:</U> <CODE>min</CODE> <I>x1 x2 ...</I>
<DD>


<P>
These procedures return the maximum or minimum of their arguments.



<PRE>
(max 3 4)                              ==&#62;  4    ; exact
(max 3.9 4)                            ==&#62;  4.0  ; inexact
</PRE>

For any real number <VAR>x</VAR>:

<PRE>
(max +inf.0 <VAR>x</VAR>)                         ==&gt;  +inf.0
(min -inf.0 <VAR>x</VAR>)                         ==&gt;  -inf.0
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If <CODE>min</CODE> or
<CODE>max</CODE> is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>+</CODE> <I>z1 ...</I>
<DT><U>procedure:</U> <CODE>*</CODE> <I>z1 ...</I>
<DD>

<P>
These procedures return the sum or product of their arguments.

<PRE>
(+ 3 4)                                ==&#62;  7
(+ 3)                                  ==&#62;  3
(+)                                    ==&#62;  0
(+ inf.0 +inf.0)                       ==&gt;  +inf.0
(+ +inf.0 -inf.0)                      ==&gt;  +nan.0

(* 4)                                  ==&#62;  4
(*)                                    ==&#62;  1
(* 5 +inf.0)                           ==&gt;  +inf.0
(* -5 +inf.0)                          ==&gt;  -inf.0
(* +inf.0 +inf.0)                      ==&gt;  +inf.0
(* +inf.0 -inf.0)                      ==&gt;  -inf.0
(* 0 +inf.0)                           ==&gt;  +nan.0
</PRE>

For any <FONT COLOR=red><STRIKE>finite</STRIKE> rational</FONT> number <VAR><FONT COLOR=red>x</FONT></VAR><FONT COLOR=red>:</FONT>

<PRE>
(+ +inf.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +inf.0
(+ -inf.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  -inf.0
</PRE>

For any <FONT COLOR=red>rational</FONT> number <FONT COLOR="red"><VAR>x</VAR></FONT>:

<PRE>
(+ +nan.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +nan.0
(* +nan.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +nan.0
</PRE>

<P>
If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either report a violation of an implementation restriction
or return an unspecified number.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>-</CODE> <I>z1 z2</I>
<DT><U>procedure:</U> <CODE>-</CODE> <I><VAR>z</VAR></I>
<DT><U><FONT COLOR="red"><STRIKE>optional</STRIKE></FONT> procedure:</U> <CODE>-</CODE> <I>z1 z2 ...</I>
<DT><U>procedure:</U> <CODE>/</CODE> <I>z1 z2</I>
<DT><U>procedure:</U> <CODE>/</CODE> <I><VAR>z</VAR></I>
<DT><U><FONT COLOR="red"><STRIKE>optional</STRIKE></FONT> procedure:</U> <CODE>/</CODE> <I>z1 z2 ...</I>
<DD>


<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.



<PRE>
(- 3 4)                                ==&#62;  -1
(- 3 4 5)                              ==&#62;  -6
(- 3)                                  ==&#62;  -3
(- +inf.0 +inf.0)                      ==&gt;  +nan.0

(/ 3 4 5)                              ==&#62;  3/20
(/ 3)                                  ==&#62;  1/3
(/ 0.0)                                ==&gt;  +nan.0
(/ 1.0 0)                              ==&gt;  +inf.0
(/ -1 0.0)                             ==&gt;  -inf.0
(/ +inf.0)                             ==&gt;  0.0
(/ 0 0.0)                              ==&gt;  +nan.0
(/ 0.0 0)                              ==&gt;  +nan.0
(/ 0.0 0.0)                            ==&gt;  +nan.0
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>abs</CODE> <I>x</I>
<DD>


<P>
<CODE>Abs</CODE> returns the absolute value of its argument.



<PRE>
(abs -7)                               ==&#62;  7
(abs -inf.0)                           ==&gt;  +inf.0
</PRE>

</DL>

<FONT COLOR="red">
<P>
<DL>
<DT><U>procedure:</U> <CODE>div+mod</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>div</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>mod</CODE> <I>er1 er2</I>
<DT><U>library procedure:</U> <CODE>quotient</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>modulo+remainder</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>modulo</CODE> <I>ei1 ei2</I>
<DT><U>library procedure:</U> <CODE>remainder</CODE> <I>ei1 ei2</I>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>
</FONT>

<P><STRONG>FIXME: LOOK AT HIS AGAIN LATER</STRONG>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>gcd</CODE> <I><STRIKE>n1</STRIKE> <FONT COLOR=red>r1 </FONT>...</I>
<DT><U>library procedure:</U> <CODE>lcm</CODE> <I><STRIKE>n1</STRIKE> <FONT COLOR=red>r1 </FONT>...</I>
<DD>


<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.
<P>
<FONT COLOR=red>For exact integer arguments, these procedures are the familiar number</FONT>
<FONT COLOR=red>theoretic operators:</FONT>

<PRE>
(gcd 32 -36)                           ==&#62;  4
(gcd)                                  ==&#62;  0
(lcm 32 -36)                           ==&#62;  288
(lcm)                                  ==&#62;  1
</PRE>

<FONT COLOR=red>For exact rational arguments, </FONT><CODE><FONT COLOR=red>gcd</FONT></CODE> <FONT COLOR=red>returns the largest</FONT>
<FONT COLOR=red>rational that divides into each of its arguments a whole number of</FONT>
<FONT COLOR=red>times, while </FONT><CODE><FONT COLOR=red>lcm</FONT></CODE> <FONT COLOR=red>returns the smallest rational that is an</FONT>
<FONT COLOR=red>integer multiple of its arguments.</FONT>

<PRE>
<FONT COLOR=red>(gcd 1/6 1/4)                          ==>  1/12</FONT>
<FONT COLOR=red>(lcm 1/6 1/4)                          ==>  1/2</FONT>
<FONT COLOR=red>(gcd 1/6 5/4)                          ==>  1/12</FONT>
<FONT COLOR=red>(lcm 1/6 5/4)                          ==>  5/2</FONT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>numerator</CODE> <I><VAR>q</VAR></I>
<DT><U>procedure:</U> <CODE>denominator</CODE> <I><VAR>q</VAR></I>
<DD>

<P>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.



<PRE>
<TT>(numerator (/ 6 4))                    ==&#62;  3
(denominator (/ 6 4))                  ==&#62;  2
(denominator
  (exact-&#62;inexact (/ 6 4)))            ==&#62; 2.0
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>floor</CODE> <I>x</I>
<DT><U>procedure:</U> <CODE>ceiling</CODE> <I>x</I>
<DT><U>procedure:</U> <CODE>truncate</CODE> <I>x</I>
<DT><U>procedure:</U> <CODE>round</CODE> <I>x</I>
<DD>
<P>
These procedures return inexact integers on inexact rational
arguments, and exact integers on rational arguments.

<P>
<CODE>Floor</CODE> returns the largest integer not larger than <VAR>x</VAR>.
<CODE>Ceiling</CODE> returns the smallest integer not smaller than <VAR>x</VAR>.
<CODE>Truncate</CODE> returns the integer closest to <VAR>x</VAR> whose absolute
value is not larger than the absolute value of <VAR>x</VAR>.  <CODE>Round'</CODE> returns the
closest integer to <VAR>x</VAR>, rounding to even when <VAR>x</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Round</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the <CODE>inexact-&#62;exact</CODE> procedure.
</BLOCKQUOTE>


<PRE>
(floor -4.3)                           ==&#62;  -5.0
(ceiling -4.3)                         ==&#62;  -4.0
(truncate -4.3)                        ==&#62;  -4.0
(round -4.3)                           ==&#62;  -4.0

(floor 3.5)                            ==&#62;  3.0
(ceiling 3.5)                          ==&#62;  4.0
(truncate 3.5)                         ==&#62;  3.0
(round 3.5)                            ==&#62;  4.0  ; inexact

(round 7/2)                            ==&#62;  4    ; exact
(round 7)                              ==&#62;  7

(floor +inf.0)                         ==&gt;  +inf.0
(ceiling -inf.0)                       ==&gt;  -inf.0
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>rationalize</CODE> <I>x y</I>
<DD>

<P>
<CODE>Rationalize</CODE> returns the <EM>simplest</EM> rational number
differing from <VAR>x</VAR> by no more than <VAR>y</VAR>.  A rational number r<SUB>1</SUB> is
<EM>simpler</EM>  than another rational number

r<SUB>2</SUB> if r<SUB>1</SUB> = p<SUB>1</SUB>/q<SUB>1</SUB> and r<SUB>2</SUB> = p<SUB>2</SUB>/q<SUB>2</SUB> 
(in lowest terms) and |p<SUB>1</SUB>|&#60;= |p<SUB>2</SUB>| and |q<SUB>1</SUB>| &#60;= |q<SUB>2</SUB>|.
Thus 3/5 is simpler than 4/7.
Although not all rationals are comparable in this ordering (consider 2/7
and 3/5) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler 2/5 lies
between 2/7 and 3/5).  Note that 0 = 0/1 is the simplest rational of
all.



<PRE>
(rationalize
  (inexact-&#62;exact .3) 1/10)            ==&#62; 1/3    ; exact
(rationalize .3 1/10)                  ==&#62; #i1/3  ; inexact

(rationalize +inf.0 3)                 ==&gt;  +inf.0
(rationalize +inf.0 +inf.0)            ==&gt;  +nan.0
(rationalize 3 +inf.0)                 ==&gt;  0
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exp</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>log</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>sin</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>cos</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>tan</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>asin</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>acos</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>atan</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>atan</CODE> <I><VAR>y</VAR> <VAR>x</VAR></I>
<DD>


<P>
These procedures are part of every implementation that supports
general
real numbers; they compute the usual transcendental functions.  <CODE>Log</CODE>
computes the natural logarithm of <VAR>z</VAR> (not the base ten logarithm).
<CODE>Asin</CODE>, <CODE>acos</CODE>, and <CODE>atan</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant of <SAMP>`atan'</SAMP> computes <TT>(angle
(make-rectangular <VAR>x</VAR> <VAR>y</VAR>))</TT> (see below), even in implementations
that don't support general complex numbers.


<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>z</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>z</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)


<P>
The above specification follows <A HREF="r5rs_13.html#BIB27">[CLtL]</A>, which in turn
cites <A HREF="r5rs_13.html#BIB19">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.
<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to +inf.0.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to -inf.0.

<PRE>
(exp +inf.0)                   ==&gt; +inf.0
(exp -inf.0)                   ==&gt; 0.0
(log +inf.0)                   ==&gt; +inf.0
(log 0.0)                      ==&gt; -inf.0
(log -inf.0)                   ==&gt; <FONT color="red"><STRIKE>+nan.0</STRIKE> <I>unspecified</I></FONT>
(atan -inf.0)                  ==&gt; -1.5707963267948965
(atan +inf.0)                  ==&gt; 1.5707963267948965
</PRE>

The functions <CODE>sin</CODE>, <CODE>cos</CODE>, <CODE>tan</CODE>,
<CODE>asin</CODE>, and <CODE>acos</CODE> either return
<CODE>+nan.0</CODE> or
report a violation of an implementation restriction
when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>sqrt</CODE> <I><VAR>z</VAR></I>
<DD>


<P>
Returns the principal square root of <VAR>z</VAR>.  For <FONT
color="red"><STRIKE>real</STRIKE> rational</FONT> <VAR>z</VAR>, the
result will have either positive real part, or zero real part and
non-negative imaginary part.

<PRE>
(sqrt -5)                   ==&gt;  0.0+2.23606797749979i
(sqrt +inf.0)               ==&gt;  +inf.0
(sqrt -inf.0)               ==&gt;  <FONT COLOR="red"><STRIKE>+nan.0</STRIKE> <I>unspecified</I></FONT>
</PRE>

</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>expt</CODE> <I>z1 z2</I>
<DD>


<P>
Returns <VAR>z1</VAR> raised to the power <VAR>z2</VAR>.
For <VAR>z</VAR><SUB>1</SUB> ~= 0

<P>
<VAR>z<SUB>1</SUB></VAR><SUP><VAR>z<SUB>2</SUB></VAR></SUP> = e<SUP><VAR>z<SUB>2</SUB></VAR> log <VAR>z<SUB>1</SUB></VAR></SUP>


<P>
0<SUP><VAR>z</VAR></SUP> is 1 if <VAR>z</VAR> = 0, and 0 if
<SAMP>`(real-part <VAR>z</VAR>)'</SAMP> is positive.  
Otherwise, this procedure reports a violation of an implementation restriction
or returns an unspecified number.


<PRE>
(expt 5 3)                  ==&gt;  125
(expt 5 -3)                 ==&gt;  8.0e-3
(expt 5 0)                  ==&gt;  1>
(expt 0 5)                  ==&gt;  0
(expt 0 5+.0000312i)        ==&gt;  0
(expt 0 -5)                 ==&gt;  <FONT color="red"><STRIKE>+inf.0</STRIKE> <I>unspecified</I></FONT>
(expt 0 -5+.0000312i)       ==&gt;  <FONT color="red"><STRIKE>+inf.0</STRIKE> <I>unspecified</I></FONT>
(expt 0 0)                  ==&gt;  <FONT color="red"><STRIKE>+nan.0</STRIKE> 1</FONT>
(expt 0.0 0.0)              ==&gt;  <FONT color="red"><STRIKE>+nan.0</STRIKE> 1.0</FONT>
</PRE>


</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>make-rectangular</CODE> <I>x1 x2</I>
<DT><U>procedure:</U> <CODE>make-polar</CODE> <I>x3 x4</I>
<DT><U>procedure:</U> <CODE>real-part</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>imag-part</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>magnitude</CODE> <I><VAR>z</VAR></I>
<DT><U>procedure:</U> <CODE>angle</CODE> <I><VAR>z</VAR></I>
<DD>


<P>
<FONT color="red"><STRIKE>These procedures are part of every implementation that supports
general
complex numbers.</STRIKE></FONT>  Suppose <VAR>x1</VAR>, <VAR>x2</VAR>, <VAR>x3</VAR>, and <VAR>x4</VAR> are
real numbers and <VAR>z</VAR> is a complex number such that



<P>
<VAR>z</VAR> = <VAR>x1</VAR> + i <VAR>x2</VAR> = <VAR>x3</VAR> e<SUP>i <VAR>x4</VAR></SUP>


<P>
Then



<PRE>
(make-rectangular <VAR>x1</VAR> <VAR>x2</VAR>)               ==&#62; <VAR>z</VAR>
(make-polar <VAR>x3</VAR> <VAR>x4</VAR>)                     ==&#62; <VAR>z</VAR>
(real-part <VAR>z</VAR>)                          ==&#62; <VAR>x1</VAR>
(imag-part <VAR>z</VAR>)                          ==&#62; <VAR>x2</VAR>
(magnitude <VAR>z</VAR>)                          ==&#62; |<VAR>x3</VAR>|
(angle <VAR>z</VAR>)                              ==&#62; x<SUB>angle</SUB>
</PRE>

<P>
where -pi &#60; x<SUB>angle</SUB> &#60;= pi with x<SUB>angle</SUB> = <VAR>x4</VAR> + 2pi n
for some integer n.

<PRE>
(angle +inf.0)                ==> 0.0
(angle -inf.0)                ==> 3.141592653589793
</PRE>

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Magnitude</CODE> is the same as <CODE>abs</CODE> for a real argument<FONT COLOR="red"><STRIKE>,

but <CODE>abs</CODE> must be present in all implementations, whereas
<CODE>magnitude</CODE> need only be present in implementations that support
general complex numbers</STRIKE></FONT>.
</BLOCKQUOTE>

</DL>


<h3>Backward Compatibility</h3>

<p>
<strong>
(FIXME: I'm leaving this section for you, Mike.)
</strong>
</p>


<h2>References</h2>

<h2>Acknowledgements</h2>

We thank Anton van Straaten, Kent Dyvig, Sebastian Egner, Aubrey
Jaffer, Marc Feeley, Matthew Flatt, Manuel Serrano for direct and
indirect assistance producing this draft.


<h2>Copyright</h2>

<p>
<strong>
(FIXME: I'm leaving this section for you, Mike.)
</strong>
</p>

</body></html>
