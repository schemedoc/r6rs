<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html40/loose.dtd">
<html><head>
<title>
SRFI ??: Preliminary Proposal for R6RS Arithmetic
</title></head>
<body>

<H1>Title</H1>

Preliminary Proposal for R6RS Arithmetic

<H2>Authors</H2>

William D Clinger and Michael Sperber

<p>
<strong>
(FIXME: R6RS/SRFI boilerplate goes here)
</strong>
</p>

<h2>Abstract</h2>

<p>
Scheme's arithmetic system was designed to allow a wide variety of
implementations.  After many years of implementation experience,
however, most implementations now fall into a small number of
categories, and the benefits of continued experimentation no longer
justify the confusion and portability problems that have resulted from
giving implementations so much freedom in this area.  Moreover, The
R5RS generic arithmetic is difficult to implement as efficiently as
purely fixnum or purely flonum arithmetic.  This SRFI is an effort to
extend and clarify the R5RS arithmetic to make it more portable, more
comprehensive, and enable faster programs.

<P>
Furthermore, one of us (Sperber) has argued that Scheme's arithmetic
requires radical overhaul.  The other (Clinger) agrees that revisions
are needed.  This SRFI describes revisions that would satisfy both of
us and states the choice between both of them as an issue to be
resolved in the discussion period of this SRFI.  Whether these
revisions qualify as radical is best left to the judgement of
individual readers.

<p>
This SRFI proposes to revise section 6.2 ("Numbers") of R5RS by:
</p>
<ul>
<li>requiring the a Scheme implementation to provide the full tower,
    including exact rationals of arbitrary precision, exact
    rectangular complex numbers where with rational real and imaginary
    parts, and inexact real and complex arithmetic
<li>defining fixnum arithmetic (parameterized by precision)
<li>defining flonum arithmetic (inexactly)
<li>defining new procedures for performing exact arithmetic
<li>defining new procedures for performing inexact arithmetic
<li>describing the external representation and semantics of
    0.0, -0.0, +inf.0, -inf.0, +nan.0, and -nan.0 for systems
    that implement inexact real arithmetic using IEEE binary
    floating point
<li>changing the specification of <code>eqv?</code> to
    behave more sensibly with inexact numbers
<li>defining Scheme's real numbers to be the complex numbers
    whose imaginary part is an exact zero
<li>adding an external representation for inexact numbers
    that expresses the precision of a binary floating point
    representation
<li>restricting the domains of some R5RS procedures
<li>clarifying the semantics of some R5RS procedures
<li>possibly changing the semantics of some R5RS procedures
</ul>


<h2>Issues</h2>

<ul>
<li>Instead of requiring the full numeric tower, the R6RS could
    require only the fixnum/flonum base, and make the full tower
    available as modules in the standard library.
<li>The main problem with banishing the full tower to a library
    is that <code>read</code>, <code>write</code>, and several
    other procedures must know about the external representations
    of all numbers.
<li>Should a minimum precision be required for fixnums or flonums?
<li>Should the range of a fixnum be restricted to a power of two?
    To a two's complement range?
<li>Should the binary fixnum/flonums operations allow other than
    two arguments?
<li>What are the semantics of "safe mode" and "unsafe mode"?
    (This is a much larger question that the R6RS should address.)
<li>Should the R5RS procedures for generic arithmetic (e.g. <code>+</code>)
    remain in R6RS?  Here are five possible answers, phrased in
    terms of the <code>+</code> procedure:
    <ol>
    <li><code>+</code> is not defined in R6RS.
    <li><code>+</code> is defined to be a synonym for the <code>ex+</code>,
        so its domain is restricted to exact arguments, and always
        returns an exact result.
    <li><code>+</code> is defined as the union of the <code>ex+</code>
        and <code>in+</code> procedures, so all of its arguments are
        required to have the same exactness, and the exactness of its
        result is the same as the exactness of its arguments.
    <li><code>+</code> is defined as in R5RS, but with the increased
        portability provided by requiring the full numeric tower.
        This alternative is described in the section 
	<a href="#r5rs-generic">R5RS-style Generic Arithmetic</a>.
    <li><code>+</code> is defined to return an exact result in all
        cases, even if one or more of its arguments is inexact.
        This alternative is described in the section 
	<a href="#exact-generic">Generic Exact Arithmetic</a>.
    </ol>
    Will Clinger prefers the 4th possibility, Mike Sperber the 5th.
    Members of the Scheme community should express themselves on this
    issue.
<li>If the R6RS adopts a R5RS-style model for the generic arithmetic,
    should it still provide more R5RS-compatible generic arithmetic as
    a library?
<li>The external representations of 0.0, -0.0, +inf.0, -inf.0, +nan.0,
    and -nan.0 must be specified.  The notations used here are used
    by several other languages, and have been adopted by several
    implementations of Scheme, but other notations are possible.
<li>The fixnum, flonum, and inexact arithmetic come with a full deck
    of operations, including some that are defined in terms of
    integers (such as <code>div+mod</code> and
    <code>quotient+remainder</code>), and others that are easily abused
    (such as <code>fxabs</code>).  Should these be pruned?
<li>The <code>real</code>, <code>rational?</code>, and <code>integer?</code> predicates must
    return <code>#f</code> for complex numbers with an imaginary part
    of inexact zero, as non-realness is now contagious.
    This causes possibly unexpected behavior: <SAMP>`(zero?
    0+0.0i)'</SAMP> returns true despite <SAMP>`(integer?
    0+0.0i)'</SAMP> returning zero.
    In the arithmetic model preferred by Mike, this makes even less
    sense, because inexact complex numbers are implicitly coerced to
    exact ones.
    Possibly, new predicates <code>realistic?</code>,
    <code>rationalistic?</code>, and <code>integral?</code> should be
    added to say that a number can be coerced to the specified type
    (and back) without loss.  It's a mess.
<li>The fixnum operations provide efficient fixnums that "wrap."
    However, they do not give efficient access to the hardware facilities
    for carry and overflow.  This would be desirable to implement
    efficient generic arithmetic on fixnums portably.  On the other hand,
    there isn't much experience with formulating an interface to these
    facilities.
<li>The division between regular procedures and library procedures is
    somewhat arbitrary.
</ul>

<h2>Rationale</h2>

<p>
Most implementations of Scheme fall into
one of the following categories:
</p>
<ul>
<li>fixnums only (now rare except in toy implementations)
<li>fixnums and flonums only
<li>exact rationals and flonums only (no imaginary numbers)
<li>the complete numeric tower
</ul>
Under the R5RS, it is hard to write programs whose arithmetic
is portable across the above categories, and it is unnecessarily
difficult even to write programs whose arithmetic is portable
between different implementations in the same category.

<p>
The portability problems can most easily be solved by requiring
all implementations to support the full numeric tower.  To
prevent that requirement from making Scheme substantially more
difficult to implement, we provide a reference implementation
that constructs the full numeric tower from a fixnum/flonum base.
To ensure the portability of such reference implementations,
the fixnum/flonum base must be described and (at least partially)
standardized.
</p>

<p>
Fixnum/flonum arithmetic is already supported by many systems,
mainly for efficiency.  Standardization of fixnum/flonum
arithmetic would increase the portability of code that uses it,
but we cannot standardize the precision of fixnum/flonum arithmetic
without making it inefficient on some systems, which would defeat
its purpose.  We therefore propose to specify the syntax and much
of the semantics of fixnum/flonum arithmetic, but to make the
precision a parameter of the specification.
</p>

<p>
Several details of the R5RS are inconsistent or incomplete with
respect to the IEEE standards for binary floating point arithmetic,
which are generally used to implement Scheme's inexact real
arithmetic.  Furthermore some details of the R5RS make it
unnecessarily difficult to implement Scheme's arithmetic efficiently.
</p>

This SRFI is incompatible with <a href="http://srfi.schemers.org/srfi-70/">SRFI 70</a> 
<a href="#jaffer-2005">[Jaffer 2005]</a> in several ways, including:
</p>
<ul>
<li>This SRFI defines a real number to be a complex number whose
    imaginary part is an exact zero.
<li>This SRFI regards +nan.0 as a real number whose value is so
    indeterminate that it might represent any real number within
    the closed interval [-inf.0,+inf.0].
</ul>
Both of the above differences are motivated by closure properties
that make it easier for an implementation to generate efficient
numerical code.

<p>
Moreover, unlike SRFI 70, this SRFI doesn't extend
<code>quotient</code>, <code>remainder</code>, and <code>modulo</code>
to real numbers, but instead provides additional operations
<code>div</code> and <code>mod</code>, which are slightly more
generally applicable and easier to specify.  It also does not extend
the <code>gcd</code> and <code>lcm</code> to rational numbers.  

<P>
There are more minor differences with SRFI 70 highlighted in the hypertext.

<P>
This SRFI describes several alternative approaches to completely
generic arithmetic.  The alternative described in the section <a
href="#r5rs-generic">R5RS-style Generic Arithmetic</a> follows the
essence of the R5RS, with the advantage of continuity and
contagiousness of inexact operations.  The alternative described in
section <a href="#exact-generic">Generic Exact Arithmetic</a> has
exactness be contagious, with the advantage of greater transparancy
over the R5RS-style generic arithmetic.  The section describing exact
arithmetic opens with a more detailed rationale.  Other alternatives
build on the exact arithmetic described in section <a href="#exact">Exact Arithmetic</a>
and the inexact arithmetic described in section <a href="#inexact">Inexact Arithmetic</a>.


<h2>Specification</h2>

<P>
We assume that Section 6.2.3 and of the R5RS remains essentially as it
stands.  The text of this SRFI describes the differences between the proposed
additions and changes to the R5RS and/or SRFI 70.

<h3>External Representations</h3>

<p>
This SRFI adds the following external representations to Scheme:
</p>
<ul>
<li><code>+inf.0</code> represents the result of
    <code>(/ 1.0 0.0)</code>
<li><code>-inf.0</code> represents the result of
    <code>(/ -1.0 0.0)</code>
<li><code>+nan.0</code> represents the result of
    <code>(/ 0.0 0.0)</code>, and may represent other NaNs as well.
    (This SRFI does not require read/write invariance for NaNs.)
<li>If <var>x</var> is an external representation of an inexact
    real number according to the R5RS, and <var>p</var> is a
    sequence of 1 or more decimal digits, then
    <var>x</var>|<var>p</var>
    is an external representation that denotes the
    best binary floating point approximation to <var>x</var>
    using a <var>p</var>-bit significand.
    For example, 1.1|53 is an external representation for the
    best approximation to 1.1 in IEEE double precision.
<li>If <var>x</var> is an external representation of an inexact
    real number according to the R5RS, then <var>x</var> by
    itself should be regarded as equivalent to
    <code><var>x</var>|53</code>.
</ul>

<p>
Implementations that use binary floating point representations
of real numbers should represent <var>x</var>|<var>p</var>
using a <var>p</var>-bit significand if practical, or by a greater
precision if a <var>p</var>-bit significand is not practical, or
by the largest available precision if <var>p</var> or more bits
of significand is not practical within the implementation.
</p>

<BLOCKQUOTE>
<p>
<em>Note:</em>
The precision of a significand should not be confused with the
number of bits used to represent the significand.  In the IEEE
floating point standards, for example, the significand's most
significant bit is implicit in single and double precision but
is explicit in extended precision.  Whether that bit is implicit
or explicit does not affect the mathematical precision.
In implementations that use binary floating point, the default
precision can calculated by calling the following procedure:
</p>
<pre>
    (define (precision)
      (do ((n 0 (+ n 1))
           (x 1.0 (/ x 2.0)))
        ((= 1.0 (+ 1.0 x)) n)))
</pre>
</BLOCKQUOTE>

<BLOCKQUOTE>
<p>
<em>Note:</em>
When the underlying floating-point representation is IEEE double
precision, the |<var>p</var> suffix cannot be omitted for all cases:
Denormalized numbers have diminished precision, and therefore must
carry a |<var>p</var> suffix with the actual width of the signficand.
</BLOCKQUOTE>

<p>
The <code>number-&gt;string</code> procedure should be generalized
to support the <var>x</var>|<var>p</var> notation.
</p>

<p>
The <code>write</code> procedure should be required to write
inexact numbers in the external representation produced by
<code>number-&gt;string</code> with one argument.
</p>

<P>The R6RS section on the lexical structure of numerical tokens should read as as
follows:
</P>

<P>
The following rules for <code>&lt;num R&gt;</code>, <code>&lt;complex R&gt;</code>,
<code>&lt;real R&gt;</code>, <code>&lt;ureal R&gt;</code>,
<code>&lt;uinteger R&gt;</code>, and <code>&lt;prefix R&gt;</code> should be replicated for R = 2, 8, 10,
and 16.  There are no rules for <code>&lt;decimal 2&gt;</code>, <code>&lt;decimal 8&gt;</code>, and
<code>&lt;decimal 16&gt;</code>, which means that numbers containing decimal points
or exponents or mantissa widths must be in decimal radix.

<PRE>
&lt;num R&gt;  --&gt; &lt;prefix R&gt; &lt;complex R&gt;
&lt;complex R&gt; --&gt; &lt;real R&gt; | &lt;real R&gt; @ &lt;real R&gt;
    | &lt;real R&gt; + &lt;ureal R&gt; i | &lt;real R&gt; - &lt;ureal R&gt; i
    | &lt;real R&gt; + i | &lt;real R&gt; - i
    | + &lt;ureal R&gt; i | - &lt;ureal R&gt; i | + i | - i
&lt;real R&gt; --&gt; &lt;sign&gt; &lt;ureal R&gt;
&lt;ureal R&gt;  --&gt;  &lt;uinteger R&gt;
    |  &lt;uinteger R&gt; / &lt;uinteger R&gt;
    |  &lt;decimal R&gt; &lt;mantissa width&gt;
    |  inf.0 | nan.0
&lt;decimal 10&gt;  --&gt;  &lt;uinteger 10&gt; &lt;suffix&gt;
    |  . &lt;digit 10&gt;+ #* &lt;suffix&gt;
    |  &lt;digit 10&gt;+ . &lt;digit 10&gt;* #* &lt;suffix&gt;
    |  &lt;digit 10&gt;+ #* . #* &lt;suffix&gt;
&lt;uinteger R&gt;  --&gt;  &lt;digit R&gt;+ #*
&lt;prefix R&gt;  --&gt;  &lt;radix R&gt; &lt;exactness&gt;
    |  &lt;exactness&gt; &lt;radix R&gt;

&lt;suffix&gt;  --&gt;  &lt;empty&gt;
    |  &lt;exponent marker&gt; &lt;sign&gt; &lt;digit 10&gt;+
&lt;exponent marker&gt;  --&gt;  e  |  s  |  f  |  d  |  l
&lt;mantissa width&gt; -&gt; &lt;empty&gt;
    | &lt;digit 10&gt;+
&lt;sign&gt;  --&gt;  &lt;empty&gt;  |  +  |  -
&lt;exactness&gt;  --&gt;  &lt;empty&gt;  |  #i  |  #e
&lt;radix 2&gt;  --&gt;  #b
&lt;radix 8&gt;  --&gt;  #o
&lt;radix 10&gt;  --&gt;  &lt;empty&gt;  |  #d
&lt;radix 16&gt;  --&gt;  #x
&lt;digit 2&gt;  --&gt;  0  |  1
&lt;digit 8&gt;  --&gt;  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7
&lt;digit 10&gt;  --&gt;  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9
&lt;digit 16&gt;  --&gt;  &lt;digit 10&gt;  |  a  |  b  |  c  |  d  |  e  |  f
</PRE>

<h3>Safe and Unsafe Mode</h3>

<P>
This SRFI allows a Scheme implementation run code in one of two global
modes: "safe" and "unsafe" mode.  These affect the fixnum and the
flonum operations.  In safe mode, these operations must check that
their arguments are actually fixnums or flonums respectively, or
perform possible additional checking as required by the specifications
of the operations.  In unsafe mode, these operations must provide no
such checking.  This distinction allows an implementation ot generate
efficient numerical code at the cost of avoiding run-time checking.
The R6RS should require a Scheme implementation to provide the safe
mode.

<p>
The SRFI uses the phrase "all bets are off" to describe that the
behavior of a procedure is unspecified for certain arguments in unsafe
mode.  Specifically, a procedure call for which all bets are off is
free to crash the system.
</p>

<h3><a name="integer-division">Integer Division</a></h3>

<P>
For various kinds of arithmetic (fixnum, flonum, exact, inexact, and
generic), this SRFI provides operations for performing integer
division.  Their variants differ mainly in the domains they operate
on, not in substance.  The following specification is of the general
variant.  Later section will link back to this one where appropriate.
</P>

<P>
<DL>
<DT><U>procedure:</U> <CODE>div+mod</CODE> <var>x1</var> <var>x2</var>
<DT><U>library procedure:</U> <CODE>div</CODE> <var>x1</var> <var>x2</var>
<DT><U>library procedure:</U> <CODE>mod</CODE> <var>x1</var> <var>x2</var>
<DD>

These implement integer division and remainder on real numbers.  
<VAR>x2</VAR> should be non-zero. <CODE>div</CODE> returns an integer.

<PRE>
(div <VAR>x1</VAR> <VAR>x2</VAR>)                  ==&gt; <VAR>n<SUB>d</SUB></VAR>
(mod <VAR>x1</VAR> <VAR>x2</VAR>)                  ==&gt; <VAR>x<SUB>m</SUB></VAR>
</PRE>

where:
	<ol>
	  <li><VAR>x1</VAR> = <VAR>n<SUB>d</SUB></VAR> * <VAR>x2</VAR> +
	  <VAR>x<SUB>m</SUB></VAR>.</li>
	  <li>0 &lt;= <VAR>x<SUB>m</SUB></VAR> &lt; <VAR>x2</VAR> if <VAR>y</VAR>
	  &gt; 0</li>
	  <li><VAR>x2</VAR>/2 &lt;= <VAR>x<SUB>m</SUB></VAR> &lt;
	  -<VAR>x2</VAR>/2 if <VAR>x2</VAR> &lt; 0</li>
	</ol>
Moreover:
<PRE>
(div <VAR>x1</VAR> 0)                  ==&gt; 0
</PRE>	

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM> These operations generalize integer division to real
numbers.  Moreover, even on integers they are better suited than
<CODE>quotient</CODE> and <CODE>remainder</CODE> to implement modular
reduction.  For details, see the paper by Egner et. al 
<A href="#egner-at-al-2004">[Egner et al. 2004]</A>.
</BLOCKQUOTE>
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>quotient+remainder</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>quotient</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>remainder</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>modulo</CODE> <var>n1</var> <var>n2</var>
<DD>

<P>
These procedures implement number-theoretic (integer)
division.  <VAR>n2</VAR> should be non-zero.
All three procedures return integers.
<SAMP>quotient</SAMP>
returns an integer.  If <VAR>n1</VAR>/<VAR>n2</VAR> is an integer:

<PRE>
(quotient <VAR>n1</VAR> <VAR>n2</VAR>)                   ==&gt; <VAR>n1</VAR>/<VAR>n2</VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)                  ==&gt; 0
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)                     ==&gt; 0
</PRE>

If <VAR>n1</VAR>/<VAR>n2</VAR> is not an integer:

<PRE>
(quotient <VAR>n1</VAR> <VAR>n2</VAR>)                   ==&gt; <VAR>n<SUB>q</SUB></VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)                  ==&gt; <VAR>n<SUB>r</SUB></VAR>
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)                     ==&gt; <VAR>n<SUB>m</SUB></VAR>
</PRE>

<P>
where <VAR>n<SUB>q</SUB></VAR> is <VAR>n1</VAR>/<VAR>n2</VAR> rounded towards zero,
0 &lt; |<VAR>n<SUB>r</SUB></VAR>| &lt; |<VAR>n2</VAR>|, 0 &lt; |<VAR>n<SUB>m</SUB></VAR>| &lt; |<VAR>n2</VAR>|,
<VAR>n<SUB>r</SUB></VAR> and <VAR>n<SUB>m</SUB></VAR> differ from <VAR>n1</VAR> by a multiple of <VAR>n2</VAR>,
<VAR>n<SUB>r</SUB></VAR> has the same sign as <VAR>n1</VAR>, and
<VAR>n<SUB>m</SUB></VAR> has the same sign as <VAR>n2</VAR>.

<P>
From this we can conclude that for integers <VAR>n1</VAR> and <VAR>n2</VAR> with
<VAR>n2</VAR> not equal to 0,

<PRE>
     (= <VAR>n1</VAR> (+ (* <VAR>n2</VAR> (quotient <VAR>n1</VAR> <VAR>n2</VAR>))
           (remainder <VAR>x1</VAR> <VAR>x2</VAR>)))
                                       ==&gt;  #t
</PRE>

provided all numbers involved in that computation are exact.


<PRE>
(quotient+remainder 13 4)              ==&gt;  3 1
(modulo 13 4)                          ==&gt;  1
(remainder 13 4)                       ==&gt;  1

(quotient+remainder -13 4)             ==&gt;  -3 -1
(modulo -13 4)                         ==&gt;  3
(remainder -13 4)                      ==&gt;  -1

(quotient+remainder -13 4)             ==&gt;  -3 1
(modulo 13 -4)                         ==&gt;  -3
(remainder 13 -4)                      ==&gt;  1

(modulo -13 -4)                        ==&gt;  -1
(remainder -13 -4)                     ==&gt;  -1

(quotient+remainder -13 -4.0)          ==&gt;  3.0 -1.0 ; inexact
(remainder -13 -4.0)                   ==&gt;  -1.0     ; inexact
</PRE>

<P>
<CODE>Quotient</CODE>, <CODE>remainder</CODE> and <CODE>modulo</CODE>
can easily be defined through <CODE>div</CODE> and <CODE>mod</CODE>:

<PRE>
(define (sign n)
  (cond
    ((positive? n) 1)
    ((negative? n) -1)
    (else 0)))

(define (quotient  n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
</PRE>


</DD>
</DL>



<h3>Numerical Type Predicates</h3>

<font color=red>
The following description is a revised form of the description
given in SRFI 70.  Changes from SRFI 70 are highlighted in red.
</font>


<P>
<DL>
<DT><U>procedure:</U> <CODE>number?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>complex?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>real?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>rational?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>integer?</CODE> <var>obj</var>
<DD>


<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.


<p>
If <VAR>z</VAR> is
<font color=red>a <strike>inexact</strike></font> complex number, then
<SAMP>`(real? <VAR>z</VAR>)'</SAMP> is true if and only if
<SAMP>`(zero? (imag-part <VAR>z</VAR>))'</SAMP>
<font color=red>
and <SAMP>`(exact? (imag-part <VAR>z</VAR>))'</SAMP> are both true</font>.
</p>

<p>
<font color=red>
If <VAR>x</VAR> is a real number, then
<SAMP>`(rational? <VAR>z</VAR>)'</SAMP> is true if and only if
there exist exact integers <var>k1</var> and <var>k2</var>
such that
<SAMP>`(= <var>z</var> (/ <var>k1</var> <var>k2</var>))'</SAMP>
and
<SAMP>`(= (numerator <var>z</var>) <var>k1</var>)'</SAMP>
and
<SAMP>`(= (denominator <var>z</var>) <var>k2</var>)'</SAMP>
are all true.
Thus infinities and NaNs are not rational numbers.
</font>
</p>

If <VAR>r1</VAR> is <font color=red>a rational</font> number, then
<SAMP>`(integer? <VAR>x</VAR>)'</SAMP> is true if and only if
<font color=red>
<SAMP>`(= (denominator <VAR>r1</VAR>) 1)'</SAMP>
is true.
</font>

<PRE>
(complex? 3+4i)                        ==&gt;  #t
(complex? 3)                           ==&gt;  #t
(real? 3)                              ==&gt;  #t
(real? -2.5+0.0i)                      ==&gt;  <font color=red>#f</font>
<font color=red>(real? -2.5+0i)                        ==&gt;  #t</font>
(real? -2.5)                           ==&gt;  #t
(real? #e1e10)                         ==&gt;  #t
<font color=red>(real? -inf.0)                         ==&gt;  #t</font>
<font color=red>(real? +nan.0)                         ==&gt;  #t</font>
<font color=red>(rational? -inf.0)                     ==&gt;  #f</font>
<font color=red>(rational? +nan.0)                     ==&gt;  #f</font>
(rational? 6/10)                       ==&gt;  #t
(rational? 6/3)                        ==&gt;  #t
(integer? 3+0i)                        ==&gt;  #t
(integer? 3.0)                         ==&gt;  #t
(integer? 8/4)                         ==&gt;  #t

(number? <font color=red>+nan.0</font>)                       ==>  #t
(complex? <font color=red>+nan.0</font>)                      ==>  <font color=red>#t</font>
(complex? <font color=red>+inf.0</font>)                      ==>  #t
(real? <font color=red>+nan.0</font>)                         ==>  <font color=red>#t</font>
(real? <font color=red>-inf.0</font>)                         ==>  #t
(rational? <font color=red>+inf.0</font>)                     ==>  #f
(rational? <font color=red>+nan.0</font>)                     ==>  #f
(integer? <font color=red>-inf.0</font>)                      ==>  #f
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
The behavior of these type predicates on inexact numbers is
unreliable, because any inaccuracy may
affect the result.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<strike>
<font color=red>
<EM>Note:</EM>
In many implementations the <CODE>rational?</CODE> procedure will be the same

as <CODE>real?</CODE>, and the <CODE>complex?</CODE> procedure will be the same as


<CODE>number?</CODE>, but unusual implementations may be able to represent

some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.
</font>
</strike>
</BLOCKQUOTE>

</DL>


<h3>Generic Conversions</h3>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exact-&gt;inexact</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>inexact-&gt;exact</CODE> <VAR>z</VAR>
<DD>
<P>
<CODE>Exact-&gt;inexact</CODE> returns an inexact representation of <VAR>z</VAR>.
The value returned is the
inexact number that is numerically closest to the argument.
If an exact argument has no reasonably close inexact equivalent,
then a violation of an implementation restriction may be reported.


<P>
<CODE>Inexact-&gt;exact</CODE> returns an exact representation of
<VAR>z</VAR>.  The value returned is the exact number that is numerically
closest to the argument.
If an inexact argument has no reasonably close exact equivalent,
then a violation of an implementation restriction may be reported.

<P>
These procedures implement the natural one-to-one correspondence between
exact and inexact integers throughout an
implementation-dependent range.
<P>
<CODE>Exact-&gt;inexact</CODE> and
<CODE>inexact-&gt;exact</CODE> are idempotent.

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>number-&gt;flonum</CODE> <VAR>z</VAR>
<DD>
<P>
<CODE>Number-&gt;flonum</CODE> returns a flonum representation of
<VAR>z</VAR>, which must be a real number or a complex number where
<SAMP>`(zero? (imag-part <VAR>z</VAR>))'</SAMP> returns
<CODE>#t</CODE>.  On other kinds of numbers, the behavior is
unspecified.

The value returned is the flonum that is numerically closest to the
argument.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM> Traditionally, <CODE>exact-&gt;>inexact</CODE> has
been used to convert numbers to a flonum representation.  However, a
Scheme system may have representations for real numbers other than
flonums.  Without <CODE>number-&gt;flonum</CODE>, a program has no
means for reliably ensuring that a number is converted to a flonum.
</BLOCKQUOTE>
</DL>

<h3>Numerical input and output</h3>

<P>
<DL>
<DT><U>procedure:</U> <CODE>number-&gt;string</CODE> <var>z</var>
<DT><U>procedure:</U> <CODE>number-&gt;string</CODE> <var>z</var> <var>radix</var>
<DD>


<P>
<VAR>Radix</VAR> must be an exact integer, either 2, 8, 10, or 16.  If omitted,
<VAR>radix</VAR> defaults to 10.
The procedure <CODE>number-&gt;string</CODE> takes a
number and a radix and returns as a string an external representation of
the given number in the given radix such that



<PRE>
(let ((number <VAR>number</VAR>)
      (radix <VAR>radix</VAR>))
  (eqv? number
        (string-&gt;number (number-&gt;string number
                                        radix)
                        radix)))
</PRE>

<P>
is true.  It is an error if no possible result makes this expression true.


<P>
If <VAR>z</VAR> is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent and trailing
zeroes) needed to make the above expression
true [<A HREF="#burger-dybvig-1996">Burger, Dybvig 1996</A>; <A HREF="#clinger-1990">Clinger 1990</A>];
otherwise the format of the result is unspecified.


<P>
The result returned by <CODE>number-&gt;string</CODE>
never contains an explicit radix prefix.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
The error case can occur only when <VAR>z</VAR> is not a complex number
or is a complex number with a non-rational real or imaginary part.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
If <VAR>z</VAR> is an inexact number represented using flonums, and
the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>string-&gt;number</CODE> <var>string</var>
<DT><U>procedure:</U> <CODE>string-&gt;number</CODE> <var>string</var> <var>radix</var>
<DD>


<P>
Returns a number of the maximally precise representation expressed by the
given <VAR>string</VAR>.  <VAR>Radix</VAR> must be an exact integer, either 2, 8, 10,
or 16.  If supplied, <VAR>radix</VAR> is a default radix that may be overridden
by an explicit radix prefix in <VAR>string</VAR> (e.g. <TT>"#o177"</TT>).  If <VAR>radix</VAR>
is not supplied, then the default radix is 10.  If <VAR>string</VAR> is not
a syntactically valid notation for a number, then <CODE>string-&gt;number</CODE>
returns <TT>#f</TT>.



<PRE>
(string-&gt;number "100")                 ==&gt;  100
(string-&gt;number "100" 16)              ==&gt;  256
(string-&gt;number "1e2")                 ==&gt;  100.0
(string-&gt;number "15##")                ==&gt;  1500.0
(string->number "+inf.0")              ==&gt; +inf.0
(string->number "-inf.0")              ==&gt; -inf.0
(string->number "+nan.0")              ==&gt; +nan.0
</PRE>


<BLOCKQUOTE>
<P>
<FONT color="red"><STRIKE>
<EM>Note:</EM>
The domain of <CODE>string-&gt;number</CODE> may be restricted by implementations
in the following ways.  <CODE>String-&gt;number</CODE> is permitted to return
<TT>#f</TT> whenever <VAR>string</VAR> contains an explicit radix prefix.
If all numbers supported by an implementation are real, then
<CODE>string-&gt;number</CODE> is permitted to return <TT>#f</TT> whenever
<VAR>string</VAR> uses the polar or rectangular notations for complex
numbers.  If all numbers are integers, then
<CODE>string-&gt;number</CODE> may return <TT>#f</TT> whenever
the fractional notation is used. If all numbers are exact, then
<CODE>string-&gt;number</CODE> may return <TT>#f</TT> whenever
an exponent marker or explicit exactness prefix is used, or if
a <TT>#</TT> appears in place of a digit.  If all inexact
numbers are integers, then
<CODE>string-&gt;number</CODE> may return <TT>#f</TT> whenever
a decimal point is used.
An implementation may return <CODE>#f</CODE> for <CODE>"+nan.0"</CODE>.</STRIKE></FONT>
</BLOCKQUOTE>

</DL>

<h3>Fixnums</h3>

<p>
Every implementation must define its fixnum range as a closed
interval [<var>lo</var>, <var>hi</var>] such that <var>lo</var>
and <var>hi</var> are (mathematical) integers with
<var>lo</var> &lt;= 0 &lt; 1 &lt;= <var>hi</var>.
Every mathematical integer within an implementation's fixnum
range must correspond to an exact integer that is representable
within the implementation.
The fixnum operations of an implementation will perform
arithmetic modulo <var>hi-lo+1</var>.
</p>

<p>
<strong>Definition.</strong>
A fixnum is an exact integer whose value lies within the fixnum
range.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fixnum?</CODE> <var>obj</var>
<DD>

<P>This returns <TT>#t</TT> if <var>obj</var> is a fixnum, and
otherwise returns <TT>#f</TT>.
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>least-fixnum</CODE>
<DT><U>procedure:</U> <CODE>greatest-fixnum</CODE>
<DD>

<P>These procedures return <var>lo</var> and <var>hi</var>, the
minimum and the maximum value of the fixnum range, respectively.
</DL>


<P>
We will use <var>fx</var>, <var>fx1</var> and <var>fx2</var> as metavariables
that range over fixnums.
</P>
<p>
If an argument to following procedures that corresponding to a fixnum
metavariable is not actually a fixnum, then these procedures signal an
error, unless the implementation is running in unsafe mode, in which
case all bets are off.
</p>


<P>
<DL>
<DT><U>procedure:</U> <CODE>fx=</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx&gt;</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx&lt;</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx&gt;=</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx&lt;=</CODE> <var>fx1</var> <var>fx2</var>
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>fxzero?</CODE> <VAR>fx</VAR>
<DT><U>library procedure:</U> <CODE>fxpositive?</CODE> <VAR>fx</VAR>
<DT><U>library procedure:</U> <CODE>fxnegative?</CODE> <VAR>fx</VAR>
<DT><U>library procedure:</U> <CODE>fxodd?</CODE> <VAR>fx</VAR>
<DT><U>library procedure:</U> <CODE>fxeven?</CODE> <VAR>fx</VAR>
<DD>


<P>
These numerical predicates test a fixnum for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxmax</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxmin</CODE> <var>fx1</var> <var>fx2</var>
<DD>


<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fx+</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx-</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fx*</CODE> <var>fx1</var> <var>fx2</var>
<DD>

<P>
These procedures return the unique fixnum that is congruent
mod <var>hi-lo+1</var> to the sum, difference, or product of
their arguments.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxabs</CODE> <VAR>fx</VAR>
<DD>

<P>
This procedure returns <SAMP>`(fx- 0 <VAR>fx</VAR>)'</SAMP> if
<VAR>fx</VAR> is negative, <VAR>fx</VAR> otherwise.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxdiv+mod</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxdiv</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxmod</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxquotient</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxmodulo+remainder</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxmodulo</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxremainder</CODE> <var>fx1</var> <var>fx2</var>
<DD>

<P>
These procedures implement number-theoretic integer division congruent
mod <var>hi-lo+1</var>.  See <a href="#integer-division">the
Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>fxgcd</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>library procedure:</U> <CODE>fxlcm</CODE> <var>fx1</var> <var>fx2</var>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments congruent
mod <var>hi-lo+1</var>.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxbitwise-not</CODE> <var>fx</var>
<DD>
<P>
Returns the fixnum which is the one's-complement of its argument.
congruent mod <var>hi-lo+1</var>.
</DD>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>fxbitwise-and</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fxbitwise-ior</CODE> <var>fx1</var> <var>fx2</var>
<DT><U>procedure:</U> <CODE>fxbitwise-xor</CODE> <var>fx1</var> <var>fx2</var>
<DD>
<P>
The <CODE>fxbitwise-and</CODE> procedure returns the fixnum which is the bit-wise "and" of 
the two's complement representations of its
arguments congruent mod <var>hi-lo+1</var>.
The <CODE>fxbitwise-ior</CODE> procedure returns the fixnum which is the bit-wise "or" of
the two's complement representations of its
arguments congruent mod <var>hi-lo+1</var>.
The <CODE>fxbitwise-xor</CODE> procedure returns the fixnum which is the
bit-wise "exlusive or" of the two's complement representations of its
arguments congruent mod <var>hi-lo+1</var>.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fxarithmetic-shift</CODE> <var>fx1</var> <var>fx2</var>
<DD>
<P>
This procedure conceptually shifts the two's complement representation of
<VAR>fx1</VAR> <VAR>fx2</VAR> bits left when <VAR>fx2</VAR> &gt; 0,
and -<VAR>fx2</VAR> bits right when <VAR>fx2</VAR> &lt; 0, extending
the sign.  (It returns <VAR>fx1</VAR> when <VAR>fx2</VAR> = 0.)  It
returns the result of that shift congruent mod <var>hi-lo+1</var>.
</DD>
</DL>


<h3>Flonums</h3>

<p>
<strong>Definition.</strong>
A flonum is an inexact real.
</p>

<p>
Please note that this definition does not imply any particular
representation for a flonum.  In particular, it does not imply
that flonums are represented by any kind of floating point
format.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flonum?</CODE> <var>obj</var>
<DD>

<P>This returns <TT>#t</TT> if <var>obj</var> is a flonum, and
otherwise returns <TT>#f</TT>.
</DL>


<p>
We will use <var>fl</var>, <var>fl1</var> and <var>fl2</var> as
metavariables that range over flonums, and <var>ifl</var>,
<var>ifl1</var> and <var>ifl2</var> as metavariables that range over
integral flonums, i.e. flonums that represent integers.
</p>
<p>
If an argument to following procedures that corresponding to a
(integral) flonum metavariable is not actually a (integral) flonum,
then these procedures signal an error, unless the implementation is
running in unsafe mode, in which case all bets are off.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fl=</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl&lt;</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl&lt;=</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl&gt;</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl&gt;=</CODE> <var>fl1</var> <var>fl2</var>
<DD>


<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.  These
predicates are required to be transitive.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flinteger?</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flzero?</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flpositive?</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flnegative?</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flodd?</CODE> <var>ifl</var>
<DT><U>procedure:</U> <CODE>fleven?</CODE> <var>ifl</var>
<DT><U>procedure:</U> <CODE>flnan?</CODE> <var>fl</var>
<DD>


<P>
These numerical predicates test a fixnum for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flmax</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>flmin</CODE> <var>fl1</var> <var>fl2</var>
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fl+</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl-</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl*</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>procedure:</U> <CODE>fl/</CODE> <var>fl1</var> <var>fl2</var>
<DD>


<P>
These procedures return the inexact real sum, difference,
product, or quotient of their inexact real arguments.
In general, they should return the flonum that best
approximates the mathematical sum of their arguments.
(For implementations that represent flonums as IEEE
binary floating point numbers, the meaning of "best"
is reasonably well-defined by the IEEE standards.)
</P>

<P>
For undefined quotients, <code>fl-</code> behaves as specified by the
IEEE standards:

<PRE>
(fl/ 1.0 0.0)  ==> +inf.0
(fl/ -1.0 0.0) ==> -inf.0
(fl/ 0.0 0.0)  ==> +nan.0
</PRE>
</dl>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flabs</CODE> <var>fl</var>
<DD>
<P>
This returns the absolute value of its argument.
<P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fldiv+mod</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>library procedure:</U> <CODE>fldiv</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>library procedure:</U> <CODE>flmod</CODE> <var>fl1</var> <var>fl2</var>
<DT><U>library procedure:</U> <CODE>flquotient</CODE> <var>ifl1</var> <var>ifl2</var>
<DT><U>library procedure:</U> <CODE>flmodulo+remainder</CODE> <var>ifl1</var> <var>ifl2</var>
<DT><U>library procedure:</U> <CODE>flmodulo</CODE> <var>ifl1</var> <var>ifl2</var>
<DT><U>library procedure:</U> <CODE>flremainder</CODE> <var>ifl1</var> <var>ifl2</var>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>flgcd</CODE> <var>ifl1</var> <var>ifl2</var>
<DT><U>library procedure:</U> <CODE>fllcm</CODE> <var>ifl1</var> <var>ifl2</var>
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>flnumerator</CODE> <var>ifl</var>
<DT><U>library procedure:</U> <CODE>fldenominator</CODE> <var>ifl</var>
<DD>
<P>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flfloor</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flceiling</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>fltruncate</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flround</CODE> <var>fl</var>
<DD>
<P>
These procedures return integral flonums.
<CODE>Flfloor</CODE> returns the largest integral flonum not larger than <VAR>fl</VAR>.
<CODE>Flceiling</CODE> returns the smallest integral flonum not smaller than <VAR>fl</VAR>.
<CODE>Fltruncate</CODE> returns the integral flonum closest to <VAR>fl</VAR> whose absolute
value is not larger than the absolute value of <VAR>fl</VAR>.  <CODE>Flround</CODE> returns the
closest integral flonum to <VAR>fl</VAR>, rounding to even when <VAR>fl</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Flround</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>

</dl>


<P>
<DL>
<DT><U>procedure:</U> <CODE>flexp</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>fllog</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flsin</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flcos</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>fltan</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flasin</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flatan1</CODE> <var>fl</var>
<DT><U>procedure:</U> <CODE>flatan2</CODE> <var>fl1</var> <var>fl2</var>
<DD>

<P>
These procedures compute the usual transcendental functions.  <CODE>Fllog</CODE>
computes the natural logarithm of <VAR>fl</VAR> (not the base ten logarithm).
<CODE>Flasin</CODE>, <CODE>Flacos</CODE>, and <CODE>Flatan1</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant <CODE>flatan2</CODE> computes <SAMP>`(inangle
(inmake-rectangular <VAR>fl1</VAR> <VAR>fl2</VAR>))'</SAMP> (see below)<font
color="red"><STRIKE>, even in implementations
that don't support general complex numbers</STRIKE></font>.


<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>fl</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>fl</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)

<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to <SAMP>+inf.0</SAMP>.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to <SAMP>-inf.0</SAMP>.


The procedures <CODE>flsin</CODE>, <CODE>flcos</CODE>, <CODE>fltan</CODE>,
<CODE>flasin</CODE>, and <CODE>flacos</CODE> <font color="red"><STRIKE>either</STRIKE></FONT> return
<CODE>+nan.0</CODE><font color="red"><STRIKE> or
report a violation of an implementation restriction</STRIKE></FONT>
<font color="red">return some meaningless inexact real number</FONT> when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>
In the event that these formulae do
not yield a real result for the given arguments, the
result may be <code>+nan.0</code>, or may be some meaningless flonum.

<P>
Implementations that use IEEE binary floating point
arithmetic are encouraged to follow the relevant
standards for these procedures.

<P>
The above specification follows <A HREF="#steele-1990">[Steele 1990]</A>, which in turn
cites <A HREF="#penfield-1981">[Penfield 1981]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.

<PRE>
(flexp +inf.0)                ==&gt; +inf.0
(flexp -inf.0)                ==&gt; 0.0
(fllog +inf.0)                ==&gt; +inf.0
(fllog 0.0)                   ==&gt; -inf.0
(fllog -inf.0)                ==&gt; +nan.0
(flatan1 -inf.0)              ==&gt; -1.5707963267948965
(flatan2 +inf.0)              ==&gt; 1.5707963267948965
</PRE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>flsqrt</CODE> <var>fl</var>
<DD>
<P>
Returns the principal square root of <VAR>z</VAR>.  The result is
undefined for negative arguments.
Implementations that use IEEE binary floating point
arithmetic are encouraged to return <SAMP>+nan.0</SAMP> in this case.

<PRE>
(flsqrt +inf.0)               ==>  +inf.0
</PRE>

</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>flexpt</CODE> <var>fl1</var> <var>fl2</var>
<DD>
<p>
Returns <VAR>fl1</VAR> raised to the power <VAR>fl2</VAR>.
For <VAR>fl1</VAR><SUB>1</SUB> ~= 0

<P>
<VAR>fl1</VAR><SUP><VAR>fl2</VAR></SUP> = e<SUP><VAR>z2</VAR> log <VAR>z1</VAR></SUP>

<P>
0<SUP><VAR>fl</VAR></SUP> is 1 if <VAR>z</VAR> = 0, and 0 if
<VAR>fl</VAR> is positive.  
Otherwise, this procedure reports a violation of an implementation restriction
or returns an unspecified number.
</DL>

<h3>Fixnum/Flonum Conversions</h3>

<P>
<DL>
<DT><U>procedure:</U> <CODE>fixnum-&gt;flonum</CODE> <var>fx</var>
<DT><U>procedure:</U> <CODE>flonum-&gt;fixnum</CODE> <var>fl</var>
<DD>

<p>
The <code>fixnum-&gt;flonum</code>
and <code>flonum-&gt;fixnum</code>
procedures provide for explicit conversions
between fixnums and flonums.
Programmers should understand that these procedures
cannot be expected to return results that are
numerically equal to their arguments.
</p>

<p>
For example, suppose the fixnum range is [-8388608,8388607]
and flonums are represented in IEEE double precision.  Then
</p>
<pre>
(fixnum-&gt;flonum 8388608)         =&gt; 8388608.0
(flonum-&gt;fixnum 3.14159265)      =&gt; 3
(flonum-&gt;fixnum -inf.0)          =&gt; -8388608
(flonum-&gt;fixnum 1e20)            =&gt; 8388607
</pre>

<p>
If the argument to these procedures is not actually
a fixnum or a flonum or NaN respectively, then these procedures signal an error, unless
the implementation is running in unsafe mode, in which
case all bets are off.
</p>

</dl>

<h3>
IEEE Binary Floating Arithmetic
</h3>

<p>
Although the R6RS should not require IEEE floating point arithmetic,
it should address certain specific issues of IEEE arithmetic.  In
particular, the R6RS should explain that
</p>
<pre>
    0.0
   -0.0
   +inf.0
   -inf.0
   +nan.0
</pre>
<p>
are likely to be distinct flonums.  The first two are inexact
rationals, but <code>+inf.0</code>, <code>-inf.0</code>, and
<code>+nan.0</code> are not rationals.
The R6RS should also explain that
</p>
<pre>
    (fl= 0.0 -0.0)                                =&gt;  #t
    (fl< -0.0 0.0)                                =&gt;  #f
    (fl= +nan.0 +nan.0)                           =&gt;  #f
</pre>
<p>
is required by the IEEE standards, and is strongly recommended
but not required by the R6RS.
</p>

<p>
The R6RS specification of eqv? should be changed so that
</p>
<pre>
    (eqv? -0.0 0.0)                             =&gt;  #f
</pre>
<p>
and to allow (but not require)
<code>(eqv? <var>x y</var>)</code> to evaluate to <code>#t</code>
when <var>x</var> and <var>y</var> are NaNs.
</p>

<p>
Note that <code>(flnegative? -0.0)</code> must return <code>#f</code>,
else it would lose the correspondence with
<code>(fl< -0.0 0.0)</code>, which is <code>#f</code>
according to the IEEE standards.
</p>


<h3><a name="exact">Exact Arithmetic</A></h3>

<p>
The exact arithmetic provides generic operations on exact numbers;
these operations correspond to their mathematical counterparts.  The
exact numbers include rationals of arbitrary precision, and exact
rectangular complex numbers.  A rational number with a denominator of
1 is indistinguishable from its numerator.  An exact rectangular
complex number with a zero imaginary part is indistinguishable from
its real part.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exnumber?</CODE> <var>ex</var>
<DT><U>procedure:</U> <CODE>excomplex?</CODE> <var>ex</var>
<DT><U>procedure:</U> <CODE>exrational?</CODE> <var>ex</var>
<DT><U>procedure:</U> <CODE>exinteger?</CODE> <var>ex</var>
<DD>
<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
an exact number of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
</P>
</DL>

<p>
We will use <var>ex</var>, <var>ex1</var>, <var>ex2</var>, and
<var>ex3</var> as metavariables that range over the exact complex
numbers,
<var>ef</var>, <var>ef1</var>, <var>ef2</var>, and
<var>ef3</var> as metavariables that range over the exact rational
numbers,
and
<var>ei</var>, <var>ei1</var>, <var>ei2</var>, and
<var>ei3</var> as metavariables that range over the exact integer
numbers.
</p>

<p>
If an argument to following procedures that corresponding to an exact
metavariable is not actually an exact number, then these procedures signal an
error.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex=</CODE> <var>ex1</var> <var>ex2</var> <var>ex3</var> ...
<DT><U>procedure:</U> <CODE>ex&gt;</CODE> <var>ef1</var> <var>ef2</var> <var>ef3</var> ...
<DT><U>procedure:</U> <CODE>ex&lt;</CODE> <var>ef1</var> <var>ef2</var> <var>ef3</var> ...
<DT><U>procedure:</U> <CODE>ex&gt;=</CODE> <var>ef1</var> <var>ef2</var> <var>ef3</var> ...
<DT><U>procedure:</U> <CODE>ex&lt;=</CODE> <var>ef1</var> <var>ef2</var> <var>ef3</var> ...
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>exzero?</CODE> <VAR>ex</VAR>
<DT><U>library procedure:</U> <CODE>expositive?</CODE> <VAR>ef</VAR>
<DT><U>library procedure:</U> <CODE>exnegative?</CODE> <VAR>ef</VAR>
<DT><U>library procedure:</U> <CODE>exodd?</CODE> <VAR>ei</VAR>
<DT><U>library procedure:</U> <CODE>exeven?</CODE> <VAR>ei</VAR>
<DD>

<P>
These numerical predicates test an exact number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exmax</CODE> <var>ef1</var> <var>ef2</var> ...
<DT><U>library procedure:</U> <CODE>exmin</CODE> <var>ef1</var> <var>ef2</var> ...
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex+</CODE> <var>ex1</var> <var>ex2</var> ...
<DT><U>procedure:</U> <CODE>ex*</CODE> <var>ex1</var> <var>ex2</var> ...
<DD>

<P>
These procedures return the sum or product of their arguments.
</p>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>ex-</CODE> <var>ex1</var> <var>ex2</var> ...
<DT><U>procedure:</U> <CODE>ex-</CODE> <var>ex</var>
<DT><U>procedure:</U> <CODE>ex/</CODE> <var>ex1</var> <var>ex2</var> ...
<DT><U>procedure:</U> <CODE>ex/</CODE> <var>ex</var>
<DD>

<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument. <CODE>Ex/</CODE> signals an error
if a divisor is 0.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exabs</CODE> <VAR>ef</VAR>
<DD>

<P>
This procedure returns the absolute value of its argument.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exdiv+mod</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>exdiv</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>exmod</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>exquotient</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>exmodulo+remainder</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>exmodulo</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>exremainder</CODE> <var>ei1</var> <var>ei2</var>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exgcd</CODE> <var>ei1</var> <var>ei2</var> ...
<DT><U>library procedure:</U> <CODE>exlcm</CODE> <var>ei1</var> <var>ei2</var> ...
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>exnumerator</CODE> <var>ef</var>
<DT><U>library procedure:</U> <CODE>exdenominator</CODE> <var>ef</var>
<DD>
<P>
These procedures return the numerator or denominator of their argument.
The result is computed as if the argument was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exfloor</CODE> <var>ef</var>
<DT><U>procedure:</U> <CODE>exceiling</CODE> <var>ef</var>
<DT><U>procedure:</U> <CODE>extruncate</CODE> <var>ef</var>
<DT><U>procedure:</U> <CODE>exround</CODE> <var>ef</var>
<DD>
<P>
These procedures return exact integers.
<CODE>Exfloor</CODE> returns the largest integer not larger than <VAR>ef</VAR>.
<CODE>Exceiling</CODE> returns the smallest integer not smaller than <VAR>ef</VAR>.
<CODE>Extruncate</CODE> returns the integer closest to <VAR>ef</VAR> whose absolute
value is not larger than the absolute value of <VAR>ef</VAR>.  <CODE>Exround</CODE> returns the
closest integer to <VAR>ef</VAR>, rounding to even when <VAR>ef</VAR> is halfway between two
integers.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>exexpt</CODE> <var>ef1</var> <var>ei2</var>
<DD>
<p>
Returns <VAR>ef1</VAR> raised to the power <VAR>ei2</VAR>.
0<SUP><VAR>ei</VAR></SUP> is 1 if <VAR>ei</VAR> = 0 and 0 if
<VAR>ei</VAR> is positive.
Otherwise, this procedure signals an error.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>exmake-rectangular</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>procedure:</U> <CODE>exreal-part</CODE> <var>ex</var>
<DT><U>procedure:</U> <CODE>eximag-part</CODE> <var>ex</var>
<DD>
<p>
The arguments of <code>exmake-rectangular</code> must be exact
rationals.  Suppose <VAR>z</VAR> is a complex number such that
<VAR>z</VAR> = <VAR>ef1</VAR> + <VAR>ef2</VAR>*i.  Then:
<PRE>
(exmake-rectangular <VAR>ef1</VAR> <VAR>ef2</VAR>) =&gt; <VAR>z</VAR>
(exreal-part <VAR>z</VAR>)              =&gt; <VAR>ef1</VAR>
(eximag-part <VAR>z</VAR>)              =&gt; <VAR>ef2</VAR>
</PRE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exbitwise-not</CODE> <var>ei</var>
<DD>
<P>
Returns the one's-complement of its argument.
</DD>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>exbitwise-and</CODE> <var>ei1</var> <var>ei2</var> ...
<DT><U>procedure:</U> <CODE>exbitwise-ior</CODE> <var>ei1</var> <var>ei2</var> ...
<DT><U>procedure:</U> <CODE>exbitwise-xor</CODE> <var>ei1</var> <var>ei2</var> ...
<DD>
<P>
The <code>exbitwise-and</code> procedure returns the exact integer which is the bit-wise "and" of the
two's complement representations of its
arguments.
The <code>exbitwise-ior</code> procedure returns the exact integer which is the bit-wise "or" of the two's
complement representations of its
arguments.
The <code>exbitwise-xor</code> procedure returns the exact integer which is the
bit-wise "exlusive or" of the two's complement representations of its arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exarithmetic-shift</CODE> <var>ei1</var> <var>ei2</var>
<DD>
<P>
This conceptually shifts the two's complement representation of
<VAR>ei1</VAR> <VAR>ei2</VAR> bits left when <VAR>ei2</VAR> &gt; 0,
and -<VAR>ei2</VAR> bits right when <VAR>ei2</VAR> &lt; 0, extending
the sign.  It returns <VAR>ei1</VAR> when <VAR>ei2</VAR> = 0.
</DD>
</DL>

<h3><a name="inexact">Inexact Arithmetic</A></h3>

<p>
The inexact arithmetic provides generic operations on inexact numbers.  The
inexact numbers include reals and inexact complex numbers, both of
which are distinguishable from the exact numbers.  The inexact reals
include the flonums, and the procedures described here behave
consistently with the corresponding flonum procedures if passed flonum
arguments.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>innumber?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>incomplex?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>inreal?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>inrational?</CODE> <var>obj</var>
<DT><U>procedure:</U> <CODE>ininteger?</CODE> <var>obj</var>
<DD>
<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <TT>#t</TT> if the object is
an inexact number of the named type, and otherwise they return <TT>#f</TT>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
</P>
</DL>

<p>
We will use <var>in</var>, <var>in1</var>, <var>in2</var>, and
<var>in3</var> as metavariables that range over the inexact numbers,
<var>ir</var>, <var>ir1</var>, <var>ir2</var>, and <var>ir3</var> as
metavariables that range over the inexact real numbers,
<var>if</var>, <var>if1</var>, <var>if2</var>, and <var>if3</var> as
metavariables that range over the inexact rationals. and
<var>ii</var>, <var>ii1</var>, <var>ii2</var>, and <var>ii3</var> as
metavariables that range over the inexact integers.
</p>

<p>
If an argument to following procedures that corresponding to an inexact
metavariable is not actually an inexact number, then these procedures signal an
error.  The same holds true for arguments corresponding to inexact
real metavariables.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in=</CODE> <var>in1</var> <var>in2</var> <var>in3</var> ...
<DT><U>procedure:</U> <CODE>in&gt;</CODE> <var>ir1</var> <var>ir2</var> <var>ir3</var> ...
<DT><U>procedure:</U> <CODE>in&lt;</CODE> <var>ir1</var> <var>ir2</var> <var>ir3</var> ...
<DT><U>procedure:</U> <CODE>in&gt;=</CODE> <var>ir1</var> <var>ir2</var> <var>ir3</var> ...
<DT><U>procedure:</U> <CODE>in&lt;=</CODE> <var>ir1</var> <var>ir2</var> <var>ir3</var> ...
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>inzero?</CODE> <var>in</var>
<DT><U>library procedure:</U> <CODE>inpositive?</CODE> <var>ir</var>
<DT><U>library procedure:</U> <CODE>innegative?</CODE> <var>ir</var>
<DT><U>library procedure:</U> <CODE>inodd?</CODE> <var>ii</var>
<DT><U>library procedure:</U> <CODE>ineven?</CODE> <var>ii</var>
<DT><U>library procedure:</U> <CODE>innan?</CODE> <var>in</var>
<DD>

<P>
These numerical predicates test an inexact number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>inmax</CODE> <var>ir1</var> <var>ir2</var> ...
<DT><U>library procedure:</U> <CODE>inmin</CODE> <var>ir1</var> <var>ir2</var> ...
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in+</CODE> <var>in1</var> <var>in2</var> ...
<DT><U>procedure:</U> <CODE>in*</CODE> <var>in1</var> <var>in2</var> ...
<DD>

<P>
These procedures return the sum or product of their arguments.
</p>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>in-</CODE> <var>in1</var> <var>in2</var> ...
<DT><U>procedure:</U> <CODE>in-</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>in/</CODE> <var>in1</var> <var>in2</var> ...
<DT><U>procedure:</U> <CODE>in/</CODE> <var>in</var>
<DD>

<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>inabs</CODE> <VAR>in</VAR>
<DD>

<P>
This procedure returns the absolute value of its argument.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>indiv+mod</CODE> <var>ir1</var> <var>ir2</var>
<DT><U>library procedure:</U> <CODE>indiv</CODE> <var>ir1</var> <var>ir2</var>
<DT><U>library procedure:</U> <CODE>inmod</CODE> <var>ir1</var> <var>ir2</var>
<DT><U>library procedure:</U> <CODE>inquotient</CODE> <var>ii1</var> <var>ii2</var>
<DT><U>library procedure:</U> <CODE>inmodulo+remainder</CODE> <var>ii1</var> <var>ii2</var>
<DT><U>library procedure:</U> <CODE>inmodulo</CODE> <var>ii1</var> <var>ii2</var>
<DT><U>library procedure:</U> <CODE>inremainder</CODE> <var>ii1</var> <var>ii2</var>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>ingcd</CODE> <var>ii1</var> <var>ii2</var> ...
<DT><U>library procedure:</U> <CODE>inlcm</CODE> <var>ii1</var> <var>ii2</var> ...
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>innumerator</CODE> <var>if</var>
<DT><U>library procedure:</U> <CODE>indenominator</CODE> <var>if</var>
<DD>
<P>
These procedures return the numerator or denominator of their argument.
The result is computed as if the argument was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>infloor</CODE> <var>ir</var>
<DT><U>procedure:</U> <CODE>inceiling</CODE> <var>ir</var>
<DT><U>procedure:</U> <CODE>intruncate</CODE> <var>ir</var>
<DT><U>procedure:</U> <CODE>inround</CODE> <var>ir</var>
<DD>
<P>
These procedures return inexact integers on inexact rational
arguments.

<CODE>Infloor</CODE> returns the largest integer not larger than <VAR>ir</VAR>.
<CODE>Inceiling</CODE> returns the smallest integer not smaller than <VAR>ir</VAR>.
<CODE>Intruncate</CODE> returns the integer closest to <VAR>in</VAR> whose absolute
value is not larger than the absolute value of <VAR>in</VAR>.  <CODE>Inround</CODE> returns the
closest integer to <VAR>in</VAR>, rounding to even when <VAR>in</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Round</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>inexp</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inlog</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>insin</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>incos</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>intan</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inasin</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inatan</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inatan</CODE> <var>ir1</var> <var>ir2</var>
<DD>

<P>
These procedures compute the usual transcendental functions.  <CODE>Inlog</CODE>
computes the natural logarithm of <VAR>in</VAR> (not the base ten logarithm).
<CODE>Inasin</CODE>, <CODE>Inacos</CODE>, and <CODE>Inatan</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant of <CODE>Inatan</CODE> computes <SAMP>`(inangle
(inmake-rectangular <VAR>ir1</VAR> <VAR>ir2</VAR>))'</SAMP> (see below).

<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>z</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>z</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)

<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to <CODE>+inf.0</CODE>.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to <CODE>-inf.0</CODE>.


The procedures <CODE>insin</CODE>, <CODE>incos</CODE>, <CODE>intan</CODE>,
<CODE>inasin</CODE>, and <CODE>inacos</CODE> <font color="red"><STRIKE>either</STRIKE></FONT> return
<CODE>+nan.0</CODE><font color="red"><STRIKE> or
report a violation of an implementation restriction</STRIKE></FONT>
<font color="red">return some meaningless inexact real number</FONT> when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>
Implementations that use IEEE binary floating point
arithmetic are encouraged to follow the relevant
standards for these procedures.

<P>
The above specification follows <A HREF="r5rs_13.html#BIB27">[CLtL]</A>, which in turn
cites <A HREF="r5rs_13.html#BIB19">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>inexpt</CODE> <var>in1</var> <var>in2</var>
<DD>
<P>
Returns <VAR>in1</VAR> raised to the power <VAR>in2</VAR>.
For <VAR>in1</VAR> ~= 0

<P>
<VAR>in1</VAR><SUP><VAR>in2</VAR></SUP> = e<SUP><VAR>in2</VAR> log <VAR>in1</VAR></SUP>


<P>
0<SUP><VAR>z</VAR></SUP> is 1 if <VAR>z</VAR> = 0, and 0 if
<SAMP>`(inreal-part <VAR>z</VAR>)'</SAMP> is positive.  
Otherwise, this procedure reports a violation of an implementation restriction
or returns an unspecified number.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>inmake-rectangular</CODE> <var>ir1</var> <var>ir2</var>
<DT><U>procedure:</U> <CODE>inmake-polar</CODE> <var>ir1</var> <var>ir2</var>
<DT><U>procedure:</U> <CODE>inreal-part</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inimag-part</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inmagnitude</CODE> <var>in</var>
<DT><U>procedure:</U> <CODE>inangle</CODE> <var>in</var>
<DD>
<p>
Suppose 
<VAR>in1</VAR>, <VAR>in2</VAR>, <VAR>in3</VAR>, and <VAR>in4</VAR>
are inexact rational numbers, and
<VAR>z</VAR> is a complex number,
such that
<VAR>z</VAR> = <VAR>in1</VAR> + <VAR>in2</VAR>*i = <VAR>in3</VAR> *
e<SUP>i*<VAR>in4</VAR></SUP>.  Then (inexactly):
<PRE>
(inmake-rectangular <VAR>in1</VAR> <VAR>in2</VAR>) =&gt; <VAR>z</VAR>
(inmake-rectangular <VAR>in3</VAR> <VAR>in4</VAR>) =&gt; <VAR>z</VAR>
(inreal-part <VAR>z</VAR>)              =&gt; <VAR>in1</VAR>
(inimag-part <VAR>z</VAR>)              =&gt; <VAR>in2</VAR>
(inmagnitude <VAR>z</VAR>)              =&gt; |<VAR>in3</VAR>|
(inangle <VAR>z</VAR>)                  =&gt; <VAR>in<SUB>angle</SUB></VAR>
</PRE>
where -pi &lt; x_angle &lt;= pi with <VAR>in<SUB>angle</SUB></VAR> = <VAR>in4</VAR> + 2pi <VAR>n</VAR>
for some integer <VAR>n</VAR>.

<P>
The behavior of <CODE>inmake-rectangular</CODE> and
<CODE>inmake-polar</CODE> given non-rational arguments is unspecified.
</DL>

<h3><a name="r5rs-generic">R5RS-style Generic Arithmetic</a></h3>

<font color=red>
The following description is a revised form of the description
given in SRFI 70.  Changes from SRFI 70 are highlighted in red.
</font>

<P>In this model of arithmetic, the section on exactness reads as follows:

<BLOCKQUOTE>
Scheme numbers are either <I>exact</I> or <I>inexact</I>.  A number is
exact if it was written as an exact constant or was derived from exact
numbers using only exact operations.  A number is inexact if it <FONT
COLOR=red><STRIKE>is infinite, if it </STRIKE></FONT>was written as an
inexact constant, if it was derived using inexact ingredients, or if
it was derived using inexact operations. Thus inexactness is a
contagious property of a number.

<P>
If two implementations produce exact results for a computation 
that did not involve inexact intermediate results <FONT COLOR="red">or the
results of numerical predicates</FONT>, the two ultimate results will be
mathematically equivalent.  This is generally not true of computations
involving inexact numbers because approximate methods such as floating
point arithmetic may be used, but it is the duty of each
implementation to make the result as close as practical to the
mathematically ideal result.

<P>
Rational operations such as <CODE>+</CODE> should always produce
exact results when given exact arguments.
<FONT COLOR=red><STRIKE>If the operation is unable to produce an exact result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an inexact value.
See section 6.2.3.
</STRIKE></FONT>
</BLOCKQUOTE>

<P>
With the exception of <CODE>inexact-&#62;exact</CODE>, the operations
described in this section must
return inexact results when given any inexact arguments.

<P>
<DL>
<DT><U>procedure:</U> <CODE>=</CODE> <var>z1</var> <var>z2</var> <var>z3</var> ...
<DT><U>procedure:</U> <CODE>&lt;</CODE> <var>x1</var> <var>x2</var> <var>x3</var> ...
<DT><U>procedure:</U> <CODE>&gt;</CODE> <var>x1</var> <var>x2</var> <var>x3</var> ...
<DT><U>procedure:</U> <CODE>&lt;=</CODE> <var>x1</var> <var>x2</var> <var>x3</var> ...
<DT><U>procedure:</U> <CODE>&gt;=</CODE> <var>x1</var> <var>x2</var> <var>x3</var> ...
<DD>


<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

<PRE>
(= +inf.0 +inf.0)           ==&gt;  #t
(= -inf.0 +inf.0)           ==&gt;  #f
(= -inf.0 -inf.0)           ==&gt;  #t
<FONT COLOR=red><STRIKE>(= +nan.0 +nan.0)                 ==>  #t</STRIKE></FONT>
</PRE>

For any rational number <VAR>x</VAR>:

<PRE>
(&lt -inf.0 <VAR>x</VAR> +inf.0))        ==>  #t
(&gt +inf.0 <VAR>x</VAR> -inf.0))        ==>  #t
</PRE>

<P>
These predicates are required to be transitive.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
While it is not an error to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of <CODE>=</CODE> and <CODE>zero?</CODE>.


When in doubt, consult a numerical analyst.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>zero?</CODE> <VAR>z</VAR>
<DT><U>library procedure:</U> <CODE>positive?</CODE> <VAR>x</VAR>
<DT><U>library procedure:</U> <CODE>negative?</CODE> <VAR>x</VAR>
<DT><U>library procedure:</U> <CODE>odd?</CODE> <VAR>n</VAR>
<DT><U>library procedure:</U> <CODE>even?</CODE> <VAR>n</VAR>
<DT><U>library procedure:</U> <CODE>nan?</CODE> <VAR>z</VAR>
<DD>


<P>
These numerical predicates test a number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.  See note above.

<PRE>
(positive? +inf.0)            ==>  #t
(negative? -inf.0)            ==>  #t
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>max</CODE> <var>x1</var> <var>x2</var> ...
<DT><U>library procedure:</U> <CODE>min</CODE> <var>x1</var> <var>x2</var> ...
<DD>


<P>
These procedures return the maximum or minimum of their arguments.



<PRE>
(max 3 4)                              ==&gt;  4    ; exact
(max 3.9 4)                            ==&gt;  4.0  ; inexact
</PRE>

For any real number <VAR>x</VAR>:

<PRE>
(max +inf.0 <VAR>x</VAR>)                         ==&gt;  +inf.0
(min -inf.0 <VAR>x</VAR>)                         ==&gt;  -inf.0
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If <CODE>min</CODE> or
<CODE>max</CODE> is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>+</CODE> <var>z1</var> ...
<DT><U>procedure:</U> <CODE>*</CODE> <var>z1</var> ...
<DD>

<P>
These procedures return the sum or product of their arguments.

<PRE>
(+ 3 4)                                ==&gt;  7
(+ 3)                                  ==&gt;  3
(+)                                    ==&gt;  0
(+ +inf.0 +inf.0)                      ==&gt;  +inf.0
(+ +inf.0 -inf.0)                      ==&gt;  +nan.0

(* 4)                                  ==&gt;  4
(*)                                    ==&gt;  1
(* 5 +inf.0)                           ==&gt;  +inf.0
(* -5 +inf.0)                          ==&gt;  -inf.0
(* +inf.0 +inf.0)                      ==&gt;  +inf.0
(* +inf.0 -inf.0)                      ==&gt;  -inf.0
(* 0 +inf.0)                           ==&gt;  +nan.0
</PRE>

For any <FONT COLOR=red><STRIKE>finite</STRIKE> rational</FONT> number <VAR><FONT COLOR=red>x</FONT></VAR><FONT COLOR=red>:</FONT>

<PRE>
(+ +inf.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +inf.0
(+ -inf.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  -inf.0
</PRE>

For any <FONT COLOR=red>rational</FONT> number <FONT COLOR="red"><VAR>x</VAR></FONT>:

<PRE>
(+ +nan.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +nan.0
(* +nan.0 <VAR><FONT COLOR=red>x</FONT></VAR>)                           ==&gt;  +nan.0
</PRE>

<P>
If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either report a violation of an implementation restriction
or return an unspecified number.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>-</CODE> <var>z1</var> <var>z2</var>
<DT><U>procedure:</U> <CODE>-</CODE> <VAR>z</VAR>
<DT><U><FONT COLOR="red"><STRIKE>optional</STRIKE></FONT> procedure:</U> <CODE>-</CODE> <var>z1</var> <var>z2</var> ...
<DT><U>procedure:</U> <CODE>/</CODE> <var>z1</var> <var>z2</var>
<DT><U>procedure:</U> <CODE>/</CODE> <VAR>z</VAR>
<DT><U><FONT COLOR="red"><STRIKE>optional</STRIKE></FONT> procedure:</U> <CODE>/</CODE> <var>z1</var> <var>z2</var> ...
<DD>


<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.
<FONT color="red"><CODE>Ex/</CODE> signals an error
if a divisor is exact 0.</FONT>


<PRE>
(- 3 4)                                ==&gt;  -1
(- 3 4 5)                              ==&gt;  -6
(- 3)                                  ==&gt;  -3
(- +inf.0 +inf.0)                      ==&gt;  +nan.0

(/ 3 4 5)                              ==&gt;  3/20
(/ 3)                                  ==&gt;  1/3
(/ 0.0)                                ==&gt;  +nan.0
(/ 1.0 0)                              ==&gt;  +inf.0
(/ -1 0.0)                             ==&gt;  -inf.0
(/ +inf.0)                             ==&gt;  0.0
(/ 0 0.0)                              ==&gt;  +nan.0
(/ 0.0 0)                              ==&gt;  +nan.0
(/ 0.0 0.0)                            ==&gt;  +nan.0
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>abs</CODE> <var>x</var>
<DD>


<P>
<CODE>Abs</CODE> returns the absolute value of its argument.



<PRE>
(abs -7)                               ==&gt;  7
(abs -inf.0)                           ==&gt;  +inf.0
</PRE>

</DL>

<FONT COLOR="red">
<P>
<DL>
<DT><U>procedure:</U> <CODE>div+mod</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>div</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>mod</CODE> <var>ef1</var> <var>ef2</var>
<DT><U>library procedure:</U> <CODE>quotient</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>modulo+remainder</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>modulo</CODE> <var>ei1</var> <var>ei2</var>
<DT><U>library procedure:</U> <CODE>remainder</CODE> <var>ei1</var> <var>ei2</var>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>
</FONT>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>gcd</CODE> <VAR><STRIKE>r1</STRIKE> <FONT COLOR=red>n1</FONT></VAR> ...
<DT><U>library procedure:</U> <CODE>lcm</CODE> <VAR><STRIKE>r1</STRIKE> <FONT COLOR=red>n1</FONT></VAR> ...
<DD>
<P>
<FONT COLOR="red">Note: This is the R5RS definition.</FONT>

<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.
<P>
<FONT COLOR=red><STRIKE>For exact integer arguments, these procedures are the familiar number
theoretic operators:</STRIKE></FONT>

<PRE>
(gcd 32 -36)                           ==&gt;  4
(gcd)                                  ==&gt;  0
(lcm 32 -36)                           ==&gt;  288
(lcm 32.0 -36)                         ==&gt;  288.0 ; inexact
(lcm)                                  ==&gt;  1
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>numerator</CODE> <VAR>q</VAR>
<DT><U>procedure:</U> <CODE>denominator</CODE> <VAR>q</VAR>
<DD>

<P>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.



<PRE>
(numerator (/ 6 4))                    ==&gt;  3
(denominator (/ 6 4))                  ==&gt;  2
(denominator
  (exact-&gt;inexact (/ 6 4)))            ==&gt; 2.0
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>floor</CODE> <var>x</var>
<DT><U>procedure:</U> <CODE>ceiling</CODE> <var>x</var>
<DT><U>procedure:</U> <CODE>truncate</CODE> <var>x</var>
<DT><U>procedure:</U> <CODE>round</CODE> <var>x</var>
<DD>
<P>
These procedures return inexact integers on inexact rational
arguments, and exact integers on rational arguments.

<P>
<CODE>Floor</CODE> returns the largest integer not larger than <VAR>x</VAR>.
<CODE>Ceiling</CODE> returns the smallest integer not smaller than <VAR>x</VAR>.
<CODE>Truncate</CODE> returns the integer closest to <VAR>x</VAR> whose absolute
value is not larger than the absolute value of <VAR>x</VAR>.  <CODE>Round'</CODE> returns the
closest integer to <VAR>x</VAR>, rounding to even when <VAR>x</VAR> is halfway between two
integers.

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Round</CODE> rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
</BLOCKQUOTE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the <CODE>inexact-&gt;exact</CODE> procedure.
</BLOCKQUOTE>


<PRE>
(floor -4.3)                           ==&gt;  -5.0
(ceiling -4.3)                         ==&gt;  -4.0
(truncate -4.3)                        ==&gt;  -4.0
(round -4.3)                           ==&gt;  -4.0

(floor 3.5)                            ==&gt;  3.0
(ceiling 3.5)                          ==&gt;  4.0
(truncate 3.5)                         ==&gt;  3.0
(round 3.5)                            ==&gt;  4.0  ; inexact

(round 7/2)                            ==&gt;  4    ; exact
(round 7)                              ==&gt;  7

(floor +inf.0)                         ==&gt;  +inf.0
(ceiling -inf.0)                       ==&gt;  -inf.0
</PRE>

</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>rationalize</CODE> <var>x</var> <var>y</var>
<DD>

<P>
<CODE>Rationalize</CODE> returns the <EM>simplest</EM> rational number
differing from <VAR>x</VAR> by no more than <VAR>y</VAR>.  A rational number r<SUB>1</SUB> is
<EM>simpler</EM>  than another rational number

r<SUB>2</SUB> if r<SUB>1</SUB> = p<SUB>1</SUB>/q<SUB>1</SUB> and r<SUB>2</SUB> = p<SUB>2</SUB>/q<SUB>2</SUB> 
(in lowest terms) and |p<SUB>1</SUB>|&lt;= |p<SUB>2</SUB>| and |q<SUB>1</SUB>| &lt;= |q<SUB>2</SUB>|.
Thus 3/5 is simpler than 4/7.
Although not all rationals are comparable in this ordering (consider 2/7
and 3/5) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler 2/5 lies
between 2/7 and 3/5).  Note that 0 = 0/1 is the simplest rational of
all.



<PRE>
(rationalize
  (inexact-&gt;exact .3) 1/10)            ==&gt; 1/3    ; exact
(rationalize .3 1/10)                  ==&gt; #i1/3  ; inexact

(rationalize +inf.0 3)                 ==&gt;  +inf.0
(rationalize +inf.0 +inf.0)            ==&gt;  +nan.0
(rationalize 3 +inf.0)                 ==&gt;  0
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>exp</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>log</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>sin</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>cos</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>tan</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>asin</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>acos</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>atan</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>atan</CODE> <VAR>y</VAR> <VAR>x</VAR>
<DD>


<P>
These procedures are part of every implementation that supports
general
real numbers; they compute the usual transcendental functions.  <CODE>Log</CODE>
computes the natural logarithm of <VAR>z</VAR> (not the base ten logarithm).
<CODE>Asin</CODE>, <CODE>acos</CODE>, and <CODE>atan</CODE> compute arcsine (sin<SUP>-1</SUP>),
arccosine (cos<SUP>-1</SUP>), and arctangent (tan<SUP>-1</SUP>), respectively.
The two-argument variant of <SAMP>`atan'</SAMP> computes <TT>(angle
(make-rectangular <VAR>x</VAR> <VAR>y</VAR>))</TT> (see below), even in implementations
that don't support general complex numbers.


<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of log <VAR>z</VAR> is defined to be the one whose imaginary
part lies in the range from -pi (exclusive) to pi (inclusive).
log 0 is undefined.
With log defined this way, the values of sin<SUP>-1</SUP> <VAR>z</VAR>, cos<SUP>-1</SUP> <VAR>z</VAR>,
and tan<SUP>-1</SUP> <VAR>z</VAR> are according to the following formulae:


<P>
sin<SUP>-1</SUP> <VAR>z</VAR> = -i log (i <VAR>z</VAR> + sqrt(1 - <VAR>z</VAR><SUP>2</SUP>))


<P>
cos<SUP>-1</SUP> <VAR>z</VAR> = pi / 2 - sin<SUP>-1</SUP> <VAR>z</VAR>


<P>
tan<SUP>-1</SUP> <VAR>z</VAR> = (log (1 + i <VAR>z</VAR>) - log (1 - i <VAR>z</VAR>)) / (2 i)


<P>
The above specification follows <A HREF="r5rs_13.html#BIB27">[CLtL]</A>, which in turn
cites <A HREF="r5rs_13.html#BIB19">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.
<P>
If the function has a real-valued limit as its argument tends toward
positive infinity, then that is the value returned by the function
applied to +inf.0.

If the function has a real-valued limit as its argument tends toward
negative infinity, then that is the value returned by the function
applied to -inf.0.

<PRE>
(exp +inf.0)                   ==&gt; +inf.0
(exp -inf.0)                   ==&gt; 0.0
(log +inf.0)                   ==&gt; +inf.0
(log 0.0)                      ==&gt; -inf.0
(log -inf.0)                   ==&gt; <FONT color="red"><STRIKE>+nan.0</STRIKE> <I>unspecified</I></FONT>
(atan -inf.0)                  ==&gt; -1.5707963267948965
(atan +inf.0)                  ==&gt; 1.5707963267948965
</PRE>

The functions <CODE>sin</CODE>, <CODE>cos</CODE>, <CODE>tan</CODE>,
<CODE>asin</CODE>, and <CODE>acos</CODE> either return
<CODE>+nan.0</CODE> or
report a violation of an implementation restriction
when given <CODE>+inf.0</CODE>,
<CODE>-inf.0</CODE>, or <CODE>+nan.0</CODE> as an argument.

<P>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>sqrt</CODE> <VAR>z</VAR>
<DD>


<P>
Returns the principal square root of <VAR>z</VAR>.  For <FONT
color="red"><STRIKE>real</STRIKE> rational</FONT> <VAR>z</VAR>, the
result will have either positive real part, or zero real part and
non-negative imaginary part.

<PRE>
(sqrt -5)                   ==&gt;  0.0+2.23606797749979i
(sqrt +inf.0)               ==&gt;  +inf.0
(sqrt -inf.0)               ==&gt;  <FONT COLOR="red"><STRIKE>+nan.0</STRIKE> <I>unspecified</I></FONT>
</PRE>

</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>expt</CODE> <var>z1</var> <var>z2</var>
<DD>


<P>
Returns <VAR>z1</VAR> raised to the power <VAR>z2</VAR>.
For <VAR>z1</VAR> ~= 0

<P>
<VAR>z1</VAR><SUP><VAR>z2</VAR></SUP> = e<SUP><VAR>z2</VAR> log <VAR>z1</VAR></SUP>


<P>
0<SUP><VAR>z</VAR></SUP> is 1 if <VAR>z</VAR> = 0, and 0 if
<SAMP>`(real-part <VAR>z</VAR>)'</SAMP> is positive.  
Otherwise, this procedure reports a violation of an implementation restriction
or returns an unspecified number.


<PRE>
(expt 5 3)                  ==&gt;  125
(expt 5 -3)                 ==&gt;  8.0e-3
(expt 5 0)                  ==&gt;  1
(expt 0 5)                  ==&gt;  0
(expt 0 5+.0000312i)        ==&gt;  0
(expt 0 -5)                 ==&gt;  <FONT color="red"><STRIKE>+inf.0</STRIKE> <I>unspecified</I></FONT>
(expt 0 -5+.0000312i)       ==&gt;  <FONT color="red"><STRIKE>+inf.0</STRIKE> <I>unspecified</I></FONT>
(expt 0 0)                  ==&gt;  <FONT color="red"><STRIKE>+nan.0</STRIKE> 1</FONT>
(expt 0.0 0.0)              ==&gt;  <FONT color="red"><STRIKE>+nan.0</STRIKE> 1.0</FONT>
</PRE>


</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>make-rectangular</CODE> <var>x1</var> <var>x2</var>
<DT><U>procedure:</U> <CODE>make-polar</CODE> <var>x3</var> <var>x4</var>
<DT><U>procedure:</U> <CODE>real-part</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>imag-part</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>magnitude</CODE> <VAR>z</VAR>
<DT><U>procedure:</U> <CODE>angle</CODE> <VAR>z</VAR>
<DD>


<P>
<FONT color="red"><STRIKE>These procedures are part of every implementation that supports
general
complex numbers.</STRIKE></FONT>  Suppose <VAR>x1</VAR>, <VAR>x2</VAR>, <VAR>x3</VAR>, and <VAR>x4</VAR> are
real numbers and <VAR>z</VAR> is a complex number such that



<P>
<VAR>z</VAR> = <VAR>x1</VAR> + i <VAR>x2</VAR> = <VAR>x3</VAR> e<SUP>i <VAR>x4</VAR></SUP>


<P>
Then



<PRE>
(make-rectangular <VAR>x1</VAR> <VAR>x2</VAR>)               ==&gt; <VAR>z</VAR>
(make-polar <VAR>x3</VAR> <VAR>x4</VAR>)                     ==&gt; <VAR>z</VAR>
(real-part <VAR>z</VAR>)                          ==&gt; <VAR>x1</VAR>
(imag-part <VAR>z</VAR>)                          ==&gt; <VAR>x2</VAR>
(magnitude <VAR>z</VAR>)                          ==&gt; |<VAR>x3</VAR>|
(angle <VAR>z</VAR>)                              ==&gt; x<SUB>angle</SUB>
</PRE>

<P>
where -pi &lt; x<SUB>angle</SUB> &lt;= pi with x<SUB>angle</SUB> = <VAR>x4</VAR> + 2pi n
for some integer n.

<PRE>
(angle +inf.0)                ==> 0.0
(angle -inf.0)                ==> 3.141592653589793
</PRE>

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Magnitude</CODE> is the same as <CODE>abs</CODE> for a real argument<FONT COLOR="red"><STRIKE>,

but <CODE>abs</CODE> must be present in all implementations, whereas
<CODE>magnitude</CODE> need only be present in implementations that support
general complex numbers</STRIKE></FONT>.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>bitwise-and</CODE> <var>ei1</var> <var>ei2</var> ...
<DT><U>procedure:</U> <CODE>bitwise-ior</CODE> <var>ei1</var> <var>ei2</var> ...
<DT><U>procedure:</U> <CODE>bitwise-xor</CODE> <var>ei1</var> <var>ei2</var> ...
<DD>
<P>
The <code>bitwise-and</code> procedure returns the exact integer which is the bit-wise "and" of the
two's complement representations of its
arguments.
The <code>bitwise-ior</code> procedure returns the exact integer which is the bit-wise "or" of the two's
complement representations of its
arguments.
The <code>bitwise-xor</code> procedure returns the exact integer which is the
bit-wise "exlusive or" of the two's complement representations of its arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>arithmetic-shift</CODE> <var>ei1</var> <var>ei2</var>
<DD>
<P>
This conceptually shifts the two's complement representation of
<VAR>ei1</VAR> <VAR>ei2</VAR> bits left when <VAR>ei2</VAR> &gt; 0,
and -<VAR>ei2</VAR> bits right when <VAR>ei2</VAR> &lt; 0, extending
the sign.  It returns <VAR>ei1</VAR> when <VAR>ei2</VAR> = 0.
</DD>
</DL>

<h3><a name="exact-generic">Generic Exact Arithmetic</a></h3>

<p>This specification of exact arithmetic is an alternative to the
R5RS-style generic arithmetic described in the previous section.


<p>
The exact generic arithmetic provides generic operations on exact and
inexact rational and complex numbers.  Each inexact number, except for
infinities and NaNs, is taken to represent a unique exact rational
number or exact complex number with exact rational real and imaginary
parts, namely the one produced by <code>inexact-&gt;exact</code>.
With this provision, the generic exact operations correspond to their
mathematical counterparts.  
</p>

<P>In this model of arithmetic, the section on exactness reads as follows:
<font color=red>
Changes from the description of exactness in the previous section are
highlighted in red.
</font>

<BLOCKQUOTE>
Scheme numbers are either <I>exact</I> or <I>inexact</I>.  A number is
exact if it was written as an exact constant or was derived from exact
numbers using only exact operations.  A number is inexact if it <FONT
COLOR=red><STRIKE>is infinite, if it </STRIKE></FONT>was written as an
inexact constant, if it was derived using inexact ingredients, or if
it was derived using inexact operations.  The generic operations all
implement exact operations.  Consequently, exactness is a contagious
property of a number.

<P>
If two implementations produce exact results for a computation that
did not involve inexact <FONT COLOR="red"><STRIKE>intermediate results
or the results of numerical predicates</STRIKE></FONT> inputs, the two
ultimate results will be mathematically equivalent.  This is generally
not true of computations involving inexact numbers because approximate
methods such as floating point arithmetic may be used, but it is the
duty of each implementation to make the result as close as practical
to the mathematically ideal result.

<FONT COLOR="red">
The transition from exactness to inexactness is always explicit
through <code>exact-&gt;inexact</code>, <code>number-&gt;flonum</code>
(or indirectly through I/O).  Consequently, inexactness cannot
implicitly contaminate a computation that started out with exact
numbers and does not use the (explicitly) inexact operations.
</FONT>

<P>
<FONT COLOR=red><STRIKE>
Rational operations such as <CODE>+</CODE> should always produce
exact results when given exact arguments.
If the operation is unable to produce an exact result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an inexact value.
See section 6.2.3.
</STRIKE></FONT>
</BLOCKQUOTE>

<BLOCKQUOTE>
<P>
<EM>Rationale:</EM> This departure from the R5RS semantics abandons
the notion that a program may compute either exactly or inexactly,
depending on the input numbers.  Each generic procedure always
performs the same computation, which is in contrast to R5RS where the
generic procedures perform different operations depending on their
inputs.  This means that the generic operations reliably fulfill the
standard algebraic laws.  For a more detailed treatment of the
subject, refer to the paper by Egner et al. <A
href="#egner-at-al-2004">[Egner et al. 2004]</A>.

<P>
Should the R6RS adopt this model of generic model, it should also provide
the R5RS-stlye generic arithmetic described in the previous section as
a library for backward compatibility.
</BLOCKQUOTE>

<p>
We will use <var>z</var>, <var>z1</var>, <var>z2</var>, and
<var>z3</var> as metavariables that range over the exact complex
numbers,
<var>q</var>, <var>q1</var>, <var>q2</var>, and
<var>q3</var> as metavariables that range over the exact rational
numbers,
and
<var>n</var>, <var>n1</var>, <var>n2</var>, and
<var>n3</var> as metavariables that range over the exact integers.
</p>

<p>
If an argument to following procedures that corresponding to an exact
metavariable is not actually a rational or complex number with
rational real and imaginary part, these procedures signal an
error.
</p>

<P>
<DL>
<DT><U>procedure:</U> <CODE>=</CODE> <var>z1</var> <var>z2</var> <var>z3</var> ...
<DT><U>procedure:</U> <CODE>&gt;</CODE> <var>q1</var> <var>q2</var> <var>q3</var> ...
<DT><U>procedure:</U> <CODE>&lt;</CODE> <var>q1</var> <var>q2</var> <var>q3</var> ...
<DT><U>procedure:</U> <CODE>&gt;=</CODE> <var>q1</var> <var>q2</var> <var>q3</var> ...
<DT><U>procedure:</U> <CODE>&lt;=</CODE> <var>q1</var> <var>q2</var> <var>q3</var> ...
<DD>

<P>
These procedures return <TT>#t</TT> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.
</P>
</DD>
</DL>

<P>
<DL>
<DD>
<DT><U>library procedure:</U> <CODE>zero?</CODE> <var>z</var>
<DT><U>library procedure:</U> <CODE>positive?</CODE> <var>q</VAR>
<DT><U>library procedure:</U> <CODE>negative?</CODE> <var>q</VAR>
<DT><U>library procedure:</U> <CODE>odd?</CODE> <var>n</VAR>
<DT><U>library procedure:</U> <CODE>even?</CODE> <var>n</VAR>
<DD>

<P>
These numerical predicates test an exact number for a particular property,
returning <TT>#t</TT> or <TT>#f</TT>.
</P>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>max</CODE> <var>q1</var> <var>q2</var> ...
<DT><U>library procedure:</U> <CODE>min</CODE> <var>q1</var> <var>q2</var> ...
<DD>

<P>
These procedures return the maximum or minimum of their arguments.
</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>+</CODE> <var>z1</var> <var>z2</var> ...
<DT><U>procedure:</U> <CODE>*</CODE> <var>z1</var> <var>z2</var> ...
<DD>

<P>
These procedures return the sum or product of their arguments.
</p>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>-</CODE> <var>z1</var> <var>z2</var> ...
<DT><U>procedure:</U> <CODE>-</CODE> <var>z</var>
<DT><U>procedure:</U> <CODE>/</CODE> <var>z1</var> <var>z2</var> ...
<DT><U>procedure:</U> <CODE>/</CODE> <var>z</var>
<DD>

<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument. <CODE>/</CODE> signals an error
if a divisor is 0.
</p>

</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>abs</CODE> <var>q</VAR>
<DD>

<P>
This procedure returns the absolute value of its argument.

</P>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>div+mod</CODE> <var>q1</var> <var>q2</var>
<DT><U>library procedure:</U> <CODE>div</CODE> <var>q1</var> <var>q2</var>
<DT><U>library procedure:</U> <CODE>mod</CODE> <var>q1</var> <var>q2</var>
<DT><U>library procedure:</U> <CODE>quotient</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>modulo+remainder</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>modulo</CODE> <var>n1</var> <var>n2</var>
<DT><U>library procedure:</U> <CODE>remainder</CODE> <var>n1</var> <var>n2</var>
<DD>

<P>
These procedures implement number-theoretic integer division.  See <a
href="#integer-division">the Section</a> on integer division.
</p>
</dl>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>gcd</CODE> <var>n1</var> <var>n2</var> ...
<DT><U>library procedure:</U> <CODE>lcm</CODE> <var>n1</var> <var>n2</var> ...
<DD>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>library procedure:</U> <CODE>numerator</CODE> <var>q</var>
<DT><U>library procedure:</U> <CODE>denominator</CODE> <var>q</var>
<DD>
<P>
These procedures return the numerator or denominator of their argument.
The result is computed as if the argument was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>floor</CODE> <var>q</var>
<DT><U>procedure:</U> <CODE>ceiling</CODE> <var>q</var>
<DT><U>procedure:</U> <CODE>truncate</CODE> <var>q</var>
<DT><U>procedure:</U> <CODE>round</CODE> <var>q</var>
<DD>
<P>
These procedures return exact integers.
<CODE>Floor</CODE> returns the largest integer not larger than <var>q</VAR>.
<CODE>Ceiling</CODE> returns the smallest integer not smaller than <var>q</VAR>.
<CODE>Truncate</CODE> returns the integer closest to <var>q</VAR> whose absolute
value is not larger than the absolute value of <var>q</VAR>.  <CODE>Round</CODE> returns the
closest integer to <var>q</VAR>, rounding to even when <var>q</VAR> is halfway between two
integers.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>expt</CODE> <var>q1</var> <var>n2</var>
<DD>
<p>
Returns <var>q1</VAR> raised to the power <var>n2</VAR>.
0<SUP><var>n</VAR></SUP> is 1 if <var>n</VAR> = 0 and 0 if
<var>n</VAR> is positive.
Otherwise, this procedure signals an error.
</DL>

<p>
<DL>
<DT><U>procedure:</U> <CODE>make-rectangular</CODE> <var>q1</var> <var>q2</var>
<DT><U>procedure:</U> <CODE>real-part</CODE> <var>z</var>
<DT><U>procedure:</U> <CODE>imag-part</CODE> <var>z</var>
<DD>
<p>
Suppose <VAR>z</VAR> is a complex number such that
<VAR>z</VAR> = <var>q1</VAR> + <var>q2</VAR>*i.  Then:
<PRE>
(make-rectangular <var>q1</VAR> <var>q2</VAR>) =&gt; <VAR>z</VAR>
(real-part <VAR>z</VAR>)            =&gt; <var>q1</VAR>
(imag-part <VAR>z</VAR>)            =&gt; <var>q2</VAR>
</PRE>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>bitwise-not</CODE> <var>n</var>
<DD>
<P>
Returns the one's-complement of its argument.
</DD>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <CODE>bitwise-and</CODE> <var>n1</var> <var>n2</var> ...
<DT><U>procedure:</U> <CODE>bitwise-ior</CODE> <var>n1</var> <var>n2</var> ...
<DT><U>procedure:</U> <CODE>bitwise-xor</CODE> <var>n1</var> <var>n2</var> ...
<DD>
<P>
The <code>bitwise-and</code> procedure returns the exact integer which is the bit-wise "and" of the
two's complement representations of its
arguments.
The <code>bitwise-ior</code> procedure returns the exact integer which is the bit-wise "or" of the two's
complement representations of its
arguments.
The <code>bitwise-xor</code> procedure returns the exact integer which is the
bit-wise "exlusive or" of the two's complement representations of its arguments.
</DD>
</DL>

<P>
<DL>
<DT><U>procedure:</U> <CODE>arithmetic-shift</CODE> <var>n1</var> <var>n2</var>
<DD>
<P>
This conceptually shifts the two's complement representation of
<var>n1</VAR> <var>n2</VAR> bits left when <var>n2</VAR> &gt; 0,
and -<var>n2</VAR> bits right when <var>n2</VAR> &lt; 0, extending
the sign.  It returns <var>n1</VAR> when <var>n2</VAR> = 0.
</DD>
</DL>


<h2>References</h2>

    <ul>
      <li><a name="burger-dybvig-1996">[Burger, Dybvig 1996]</a> Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, pages 108-116.
	Available <a href="http://www.cs.indiana.edu/~burger/">here</a>.</li>
      <li><a name="clinger-1990">[Clinger 1990]</a> William Clinger. How to read floating point numbers accurately. In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, pages 92-101. Proceedings published as SIGPLAN Notices 25(6), June 1990. Available <a href="http://www.ccs.neu.edu/home/will/papers.html">here</a>.</li>
      <li><a name="egner-at-al-2004">[Egner et al. 2004]</a>
  Sebastian Egner, Richard Kelsey, Michael Sperber.
  Cleaning up the tower: Numbers in Scheme.
	  In <I>Proceedings of the Fifth ACM SIGPLAN
   Workshop on Scheme and Functional Programming,</I>
     pages 109--120,
     September 22, 2004, Snowbird, Utah.
  Technical report <a href="http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR600">TR600</A>,
    Computer Science Department, Indiana University.
      </li>
      <li><a name="jaffer-2005">[Jaffer 2005]</a>Aubrey Jaffer.  Numerics with Infinities.  2005.  <a href="http://srfi.schemers.org/srfi-70/">SRFI 70</a>.</li>
      <li><a name="penfield-1981">[Penfield 1981]</A> Paul Penfield, Jr. Principal values and branch cuts in complex APL. In APL '81 Conference Proceedings, pages 248-256. ACM SIGAPL, San Francisco, September 1981. Proceedings published as APL Quote Quad 12(1), ACM, September 1981. <a href="http://portal.acm.org/citation.cfm?id=800142.805368&dl=GUIDE&dl=ACM&type=series&idx=SERIES404&part=Proceedings&WantType=Proceedings&title=International%20Conference%20on%20APL">ACM Digital Library Entry</a>.</li>
      <li><a name="steele-1990">[Steele 1990]</A> Guy Lewis Steele Jr. Common Lisp: The Language, second edition. Digital Press, Burlington MA, 1990.  Available electronically <a href="http://www-2.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">here</a>.</li>
    </ul>



<h2>Acknowledgements</h2>

We thank Anton van Straaten, Kent Dybvig, Sebastian Egner, Mike Ashley, Aubrey
Jaffer, Marc Feeley, Matthew Flatt, Manuel Serrano for direct and
indirect assistance producing this draft.


<h2>Copyright</h2>

<p>
<strong>
(FIXME: I'm leaving this section for you, Mike.)
</strong>
</p>

</body></html>
