<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>SRFI 79: Primitive I/O</title>
</head>
<body>

<H1>Title</H1>

Primitive I/O

<H1>Authors</H1>

Michael Sperber

<h1>Abstract</h1><p>This SRFI defines a simple, primitive I/O subsystem for Scheme that is intended to function as the lowest layer of a more comprehensive suite of I/O layers.  It provides unbuffered I/O, and is close to what a typical operating system offers. Thus, its interface is suitable for implementing high-throughput and zero-copy I/O.</p><p>The Primitive I/O layer also allows clients to implement custom data sources and sinks via a simple interface.</p><p>Moreover, this SRFI defines a condition hierarchy specifying common I/O-related exceptional situations.</p><p>The Primitive I/O layer only handles blocking-I/O.  Non-blocking and selective I/O is left for another SRFI.</p><p>This I/O layer was designed in conjunction with two other layers that can be built on top of it: <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a> and <a href="http://srfi.schemers.org/srfi-81">SRFI 81 (Port I/O)</a>.</p><h1>Rationale</h1><p>The I/O subsystem in R5RS makes it difficult for a Scheme system to implement high-performance binary I/O.  It is possible, but at the cost of complicating the interface significantly.</p><p>Moreover, R5RS provides no functionality for a program to create its own port types to connect to custom data sources and sinks.  Many Scheme implementations provide such interfaces, but they are often complicated and tend to be volatile as implementation aspects of the I/O system changes.  This is because they build directly on the port model, rather than on a more primitive model such as the one specified here, which makes it comparatively easy to implement custom data sources and sinks.</p><h1>Specification</h1><h2>Prerequisites</h2><p>This SRFI refers to a number of additions and changes of the upcoming R6RS.</p><ul><li><a href="http://srfi.schemers.org/srfi-34/">SRFI 34 (Exception Handling for Programs)</a></li><li><a href="http://srfi.schemers.org/srfi-35/">SRFI 35 (Conditions)</a></li></ul><p>R6RS will have a <code>&amp;violation</code> condition type for arguments that violate a procedure's specification.</p><p>The specification frequently mentions <i>bytes</i> objects.  These refer to the bytes objects that will be part of the upcoming R6RS. These are equivalent in functionality to the blobs of <a href="http://srfi.schemers.org/srfi-74/">SRFI 74 (Octet-Addressed Binary Blocks)</a> but differ in terminology and some aspects of the interface.</p><p>The specification also refers to <i>enum-sets</i>, which are objects representing sets of symbols.  R6RS will specify a library with various operations on enum-sets.</p><h2>Filenames</h2><p>Some of the procedures described here accept a filename <var>filename</var> as an argument.  Valid values for such a filename include strings naming a file using the native notation of the operating system the Scheme implementation happens to be running on.</p><p>It is expected that a future SRFI will extend this set of values by a more abstract representation: This is necessary, as the most common operating systems do not really use strings for representing filenames, but rather byte or word sequences.  Moreover, the string notation is difficult to manipulate and not very portable.</p><h2>Data extensions</h2><h3>Condition types</h3><p>The I/O conditition type hierarchy here is similar, but not identical to the one described in <a href="http://srfi.schemers.org/srfi-36/">SRFI 36 (I/O Conditions)</a>.</p><p>The following list depicts the I/O condition hierarchy; more detailed explanations of the condition types follow.</p><ul><li><code>&amp;error</code><br><ul><li><code>&amp;i/o-error</code><br><ul><li><code>&amp;i/o-read-error</code></li><li><code>&amp;i/o-write-error</code></li><li><code>&amp;i/o-closed-error</code></li><li><code>&amp;i/o-invalid-position-error</code></li></ul><br><ul><li><code>&amp;i/o-filename-error</code> (has a <code>filename</code> field)<br><ul><li><code>&amp;i/o-file-protection-error</code><br><ul><li><code>&amp;i/o-file-is-read-only-error</code></li></ul></li><li><code>&amp;i/o-file-already-exists-error</code></li><li><code>&amp;i/o-no-such-file-error</code></li></ul></li></ul></li></ul></li><li><code>&amp;violation</code><br><ul><li><code>&amp;i/o-operation-not-available-violation</code></li></ul></li></ul><p>In exceptional situations not described as "it is an error", the procedures described in the specification below will raise an <code>&amp;i/o-error</code> condition object.  Except where explicitly specified, there is no guarantee that the raised condition object will contain all the information that would be applicable.  It is recommended, however, that an implementation of this SRFI provide all information about an exceptional situation in the condition object that is available at the place where it is detected.</p><pre>(define-condition-type &amp;i/o-error &amp;error
  i/o-error?)
</pre><dl><dd><p>This is a supertype for a set of more specific I/O errors.</p></dd></dl><pre>(define-condition-type &amp;i/o-read-error &amp;i/o-error
  i/o-read-error?)
</pre><dl><dd><p>This condition type specifies a read error that occurred during an I/O operation.</p></dd></dl><pre>(define-condition-type &amp;i/o-write-error &amp;i/o-error
  i/o-write-error?)
</pre><dl><dd><p>This condition type specifies a write error that occurred during an I/O operation.</p></dd></dl><pre>(define-condition-type &amp;i/o-invalid-position-error &amp;i/o-error
  i/o-invalid-position-error?
  (position i/o-error-position))
</pre><dl><dd><p>This condition type specifies that an attempt to set the file position specified an invalid position.  The value of the <code>position</code> field is the file position that the program intended to set.  This condition describes a range error, but not an argument type error.</p></dd></dl><pre>(define-condition-type &amp;i/o-closed-error &amp;i/o-error
  i/o-error?)
</pre><dl><dd><p>A condition of this type specifies that an operation tried to operate on a closed I/O object under the assumption that it is open.</p></dd></dl><pre>(define-condition-type &amp;i/o-filename-error &amp;i/o-error
  i/o-filename-error?
  (filename i/o-error-filename))
</pre><dl><dd><p>This condition type specifies an I/O error that occurred during an operation on a named file.  Condition objects belonging to this type must specify a file name in the <code>filename</code> field.</p></dd></dl><pre>(define-condition-type &amp;i/o-malformed-filename-error &amp;i/o-filename-error
  i/o-malformed-filename-error?)
</pre><dl><dd><p>This condition type indicates that a file name had an invalid format.</p></dd></dl><pre>(define-condition-type &amp;i/o-file-protection-error &amp;i/o-filename-error
  i/o-file-protection-error?)
</pre><dl><dd><p>A condition of this type specifies that an operation tried to operate on a named file with insufficient access rights.</p></dd></dl><pre>(define-condition-type &amp;i/o-file-is-read-only-error &amp;i/o-file-protection-error
  i/o-file-is-read-only-error?)
</pre><dl><dd><p>A condition of this type specifies that an operation tried to operate on a named read-only file under the assumption that it is writeable.</p></dd></dl><pre>(define-condition-type &amp;i/o-file-already-exists-error &amp;i/o-filename-error
  i/o-file-already-exists-error?)
</pre><dl><dd><p>A condition of this type specifies that an operation tried to operate on an existing named file under the assumption that it does not exist.</p></dd></dl><pre>(define-condition-type &amp;i/o-file-exists-not-error &amp;i/o-filename-error
  i/o-file-exists-not-error?)
</pre><dl><dd><p>A condition of this type specifies that an operation tried to operate on an non-existent named file under the assumption that it exists.</p></dd></dl><pre>(define-condition-type &amp;i/o-operation-not-available-violation &amp;violation
  i/o-operation-not-available-violation?)
</pre><dl><dd><p>This condition type indicates that the program tried to perform an I/O operation that was not available.</p></dd></dl><h4><a name="file-options">File Options</a></h4><p>When opening a file, the various procedures in this SRFI accept a <i>file-options</i> object containing a set of flags that specify how the file is to be opened.  A file-options object is an enum-set over the symbols constituting valid file options.</p><dl><dt><code>(file-options </code><var>file-options-name...</var><code>)</code> (syntax)</dt><dd><p>The syntax <code>file-options</code> returns a file-options object with the specified options set.  The following options (all affecting output only) may be used:</p><table><tr><td><code>create</code></td><td>create file if it does not already exist</td></tr><tr><td><code>exclusive</code></td><td>an error will be raised if this option and <code>create</code> are both set and the file already exists</td></tr><tr><td><code>truncate</code></td><td>file is truncated</td></tr></table></dd></dl><h2>Readers and Writers</h2><p>The objects representing input data sources are called <em>readers</em> and those representing output data sources are called <em>writers</em> for output.  They are unbuffered and operate purely on binary data.</p><p>This layer only specifies a fairly small set of operations --- a subset of the Standard ML Basis <code>PRIM_IO</code> signature.  Specifically, all functionality related to non-blocking I/O or polling is missing here.  This is intentional, as this functionality should be integrated with the threads system of the underlying implementation, and is thus outside the scope of this SRFI.  Instead, it is expected that the set of operations available on primitive I/O readers and writers will be augmented by future specifications, as will be the available constructors for these objects.</p><p>The Primitive I/O layer has one condition type specific to readers and writers:</p><pre>(define-condition-type &amp;i/o-reader/writer-error &amp;i/o-error
  i/o-reader/writer-error?
  (reader/writer i/o-error-reader/writer))
</pre><dl><dd><p>This condition type allows specifying the particular reader or writer with which an I/O error is associated.  The <code>reader/writer</code> field has purely informational purpose.  Conditions raised by Primitive I/O procedures <em>may</em> include an <code>&amp;i/o-reader/writer-error</code> condition, but are not required to do so.</p></dd></dl><h2>I/O buffers</h2><dl><dt><code>(make-i/o-buffer </code><var>size</var><code>)</code></dt><dd><p>This creates a bytes object of size <var>size</var> with undefined contents.  Callers of the Primitive I/O procedures are encouraged to use bytes objects created by <code>make-i/o-buffer</code> because they might have alignment and placement characteristics that make <code>reader-read!</code> and <code>writer-write!</code> more efficient.  (These procedures are still required to work on regular bytes objects, however.)</p></dd></dl><h2>Readers</h2><p>Although some reader objects might conceivably have something to do with files or devices, programmers should never assume it. The purpose of reader objects is to represent the output of arbitrary algorithms in a form susceptible to imperative I/O.</p><dl><dt><code>(reader? </code><var>obj</var><code>)</code></dt><dd><p>Returns <code>#t</code> if <var>obj</var> is a reader, otherwise returns <code>#f</code>.</p></dd><dt><code>(make-simple-reader </code><var>id</var> <var>descriptor</var> <var>chunk-size</var> <var>read!</var> <var>available</var> <var>get-position</var> <var>set-position!</var> <var>end-position</var> <var>close</var><code>)</code></dt><dd><p>Returns a reader object. <var>Id</var> is a string naming the reader, provided for informational purposes only.  <var>Descriptor</var> may be any object; the Primitive I/O system will not use it internally for any purpose.  <var>Descriptor</var> can be extracted from the reader object via <code>reader-descriptor</code>.  Thus, <var>descriptor</var> can be used to keep the internal state of certain kinds of readers.</p><p><var>Chunk-size</var> must be a positive exact integer,  and represents a recommended efficient size of the read operations on this reader.  This is typically the block size of the buffers of the operating system.  As such, it is only a hint for clients of the reader---calls to the <var>read!</var> procedure (see below) may specify a different read count.  A value of 1 represents a recommendation to use unbuffered reads.</p><p>The remaining arguments are procedures---<var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> may be omitted, in which case the corresponding arguments must be <code>#f</code>.</p><dl><dt><code>(</code><var>read!</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This reads up to <var>count</var> bytes from the reader and writes them into <var>bytes</var>, which must be a bytes object, starting at index <var>start</var>.  <var>bytes</var> must have at least <var>start</var> + <var>count</var> elements.  This procedure returns the number of bytes read as an exact integer.  It returns 0 if it encounters an end of file, or if <var>count</var> is 0.  If <var>count</var> is positive, this procedure blocks until at least one byte has been read or it has encountered end of file.</p><p><var>Bytes</var> may or may not be a bytes object returned by <code>make-i/o-buffer</code>.  It is possible that <code>reader-read!</code> operates more efficiently if it is, however.</p><p><var>Count</var> may or may not be the same as the chunk size of the reader. It is possible that <code>reader-read!</code> operates more efficiently if it is, however.</p></dd><dt><code>(<var>available</var>)</code></dt><dd><p>This returns an estimate of the total number of available bytes left in the stream.  The return value is either an exact integer, or <code>#f</code> if no such estimate is possible.  There is no guarantee that this estimate will have any specific relationship to the true number of available bytes.</p></dd><dt><code>(<var>get-position</var>)</code></dt><dd><p>This procedure, when present, returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.  (EOFs do not count as bytes.)</p></dd><dt><code>(</code><var>set-position!</var> <var>pos</var><code>)</code></dt><dd><p>This procedure, when present, moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p><p>The procedure must return a single value, which is ignored.</p></dd><dt><code>(<var>end-position</var>)</code></dt><dd><p>This procedure, when present, returns the position in the byte stream of the next end of file, without changing the current position.</p></dd><dt><code>(<var>close</var>)</code></dt><dd><p>This procedure marks the reader as closed, performs any necessary cleanup, and releases the resources associated with the reader.  Further operations on the reader may signal an error.</p><p>The procedure must return a single value, which is ignored.</p></dd></dl></dd><dt><code>(reader-id </code><var>reader</var><code>)</code></dt><dd><p>This returns  a string naming the reader, provided for informational purposes only.  For a file reader returned by <code>open-file-reader</code> or <code>open-file-reader+writer</code>, this will be a string representation of the file name.</p><p>For a reader created by <code>make-simple-reader</code>, this returns the value that was supplied as the <var>id</var> argument to <code>make-simple-reader</code>.</p></dd><dt><code>(reader-descriptor </code><var>reader</var><code>)</code></dt><dd><p>For a reader created by <code>make-simple-reader</code>, this returns the value that was supplied as the <var>descriptor</var> argument to <code>make-simple-reader</code>.</p><p>For all other readers, this returns an unspecified value.</p></dd><dt><code>(reader-chunk-size </code><var>reader</var><code>)</code></dt><dd><p>This returns a positive exact integer that  represents a recommended efficient size of the read operations on this reader.  This is typically the block size of the buffers of the operating system.  As such, it is only a hint for clients of the reader---calls to the <code>reader-read!</code> procedure (see below) may specify a different read count.  A value of 1 represents a recommendation to use unbuffered reads.</p><p>For a reader created by <code>make-simple-reader</code>, this returns the value that was supplied as the <var>chunk-size</var> argument to <code>make-simple-reader</code>.</p></dd><dt><code>(reader-read! </code><var>reader</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This reads up to <var>count</var> bytes from the reader and writes them into <var>bytes</var>, which must be a bytes object, starting at index <var>start</var>.  <var>bytes</var> must have at least <var>start</var> + <var>count</var> elements.  This procedure returns the number of bytes read as an exact integer.  It returns 0 if it encounters an end of file, or if <var>count</var> is 0.  This procedure blocks until at least one byte has been read or it has encountered end of file.</p><p><var>Bytes</var> may or may not be a bytes object returned by <code>make-i/o-buffer</code>.  It is possible that <code>reader-read!</code> operates more efficiently if it is, however.</p><p><var>Count</var> may or may not be the same as the chunk size of the reader. It is possible that <code>reader-read!</code> operates more efficiently if it is, however.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>read!</var> procedure of <var>reader</var> with the remaining arguments.</p></dd><dt><code>(reader-available </code><var>reader</var><code>)</code></dt><dd><p>This returns an estimate of the total number of available bytes left in the stream.  The return value is either an exact integer, or <code>#f</code> if no such estimate is possible.  There is no guarantee that this estimate will have any specific relationship to the true number of available bytes.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>available</var> procedure of <var>reader</var>.</p></dd><dt><code>(reader-has-get-position? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> supports the <code>reader-get-position</code> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-get-position </code><var>reader</var><code>)</code></dt><dd><p>When <code>reader-has-get-position</code> returns <code>#t</code> for <var>reader</var>, this returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>get-position</var> procedure of <var>reader</var>, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>get-position</var> procedure.</p></dd><dt><code>(reader-has-set-position!? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> supports the <code>reader-set-position!</code> operation, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-set-position! </code><var>reader</var> <var>pos</var><code>)</code></dt><dd><p>When <code>reader-has-set-position!?</code> returns <code>#t</code> for <var>reader</var>, moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>set-position!</var> procedure of <var>reader</var> with the <var>pos</var> argument, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>set-position!</var> procedure.</p></dd><dt><code>(reader-has-end-position? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> supports the <var>reader-end-position</var> operation, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-end-position </code><var>reader</var><code>)</code></dt><dd><p>When <code>reader-has-end-position?</code> returns <code>#t</code> for <var>reader</var>, this returns the position in the byte stream of the next end of file, without changing the current position.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>end-position</var> procedure of <var>reader</var>, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>end-position</var> procedure.</p></dd><dt><code>(reader-close </code><var>reader</var><code>)</code></dt><dd><p>This marks the reader as closed, performs any necessary cleanup, and releases the resources associated with the reader.  Further operations on the reader may signal an error.</p><p>For a reader created by <code>make-simple-reader</code>, this calls the <var>close</var> procedure of <var>reader</var>.</p></dd><dt><code>(open-bytes-reader </code><var>bytes</var><code>)</code></dt><dd><p>This returns a reader that uses a copy of <var>bytes</var>, a bytes object, as its contents.  This reader has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(open-file-reader </code><var>filename</var><code>)</code></dt><dt><code>(open-file-reader </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This returns a reader connected to the file named by <var>filename</var>.The <var>file-options</var> object defaults to <code>(file-options)</code>if not present.  It may determine various aspects of the returned reader, see the <a href="#file-options">section on file options</a>. This reader has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(standard-input-reader)</code></dt><dd><p>This returns a reader connected to the standard input.  The meaning of  "standard input" is implementation-dependent.</p></dd></dl><h2>Writers</h2><p>Although some writer objects might conceivably have something to do with files or devices, programmers should never assume it. The purpose of writer objects is to represent the input of arbitrary algorithms in a form susceptible to imperative I/O.</p><dl><dt><code>(writer? </code><var>obj</var><code>)</code></dt><dd><p>Returns <code>#t</code> if <var>obj</var> is a writer, otherwise returns <code>#f</code>.</p></dd><dt><code>(make-simple-writer </code><var>id</var> <var>descriptor</var> <var>chunk-size</var> <var>write!</var> <var>get-position</var> <var>set-position!</var> <var>end-position</var> <var>close</var><code>)</code></dt><dd><p>Returns a writer object. <var>Id</var> is a string naming the writer, provided for informational purposes only.  For a file, this will be a string representation of the file name.  <var>Descriptor</var> may be any object; the Primitive I/O system will not use it internally for any purpose.  <var>Descriptor</var> can be extracted from the writer object via <code>writer-descriptor</code>.  Thus, <var>descriptor</var> can be used to keep the internal state of certain kinds of writers.</p><p><var>Chunk-size</var> must be a positive exact integer,  and is the recommended efficient size of the write operations on this writer.  As such, it is only a hint for clients of the reader---calls to the <var>write!</var> procedure (see below) may specify a different write count. A value of 1 represents a recommendation to use unbuffered writes.</p><p>The remaining arguments are procedures --- <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> may be omitted, in which case the corresponding arguments must be <code>#f</code>.</p><dl><dt><code>(</code><var>write!</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This writes up to <var>count</var> bytes in bytes object <var>bytes</var> starting at index <var>start</var>.  Before it does this, it will block until it can write at least one byte.  It returns the number of bytes actually written as a positive exact integer.</p><p><var>Bytes</var> may or may not be a bytes object returned by <code>make-i/o-buffer</code>.  It is possible that <code>writer-write!</code> operates more efficiently if it is, however.</p><p><var>Count</var> may or may not be the same as the chunk size of the reader. It is possible that <code>writer-write!</code> operates more efficiently if it is, however.</p></dd><dt><code>(<var>get-position</var>)</code></dt><dd><p>This procedure, when present, returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.</p></dd><dt><code>(</code><var>set-position!</var> <var>pos</var><code>)</code></dt><dd><p>This procedure, when present, moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p><p>The procedure must return a single return value, which is ignored.</p></dd><dt><code>(<var>end-position</var>)</code></dt><dd><p>This procedure, when present, returns the byte position of the next end of file, without changing the current position.</p></dd><dt><code>(<var>close</var>)</code></dt><dd><p>This procedure marks the writer as closed, performs any necessary cleanup, and releases the resources associated with the writer.  Further operations on the writer may signal an error.</p><p>The procedure must return a single value, which is ignored.</p></dd></dl></dd><dt><code>(writer-id </code><var>writer</var><code>)</code></dt><dd><p>This returns string naming the writer, provided for informational purposes only.  For a file writer returned by <code>open-file-writer</code> or <code>open-file-reader+writer</code>, this will be a string representation of the file name.</p><p>For a writer created by <code>make-simple-writer</code>, this returns the value of the <var>id</var> field of the argument writer.</p></dd><dt><code>(writer-descriptor </code><var>writer</var><code>)</code></dt><dd><p>For a writer created by <code>make-simple-writer</code>, this returns the value of the <var>descriptor</var> field of the argument writer.</p><p>For all other writers, this returns an unspecified value.</p></dd><dt><code>(writer-chunk-size </code><var>writer</var><code>)</code></dt><dd><p>This returns a positive exact integer,  and is the recommended efficient size of the write operations on this writer.  As such, it is only a hint for clients of the reader---calls to <var>writer-write!</var> (see below) may specify a different write count. A value of 1 represents a recommendation to use unbuffered writes.</p><p>For a writer created by <code>make-simple-writer</code>, this returns the value of the <var>chunk-size</var> field of the argument writer.</p></dd><dt><code>(writer-write! </code><var>writer</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This writes up to <var>count</var> bytes in bytes object <var>bytes</var> starting at index <var>start</var>.  Before it does this, it will block until it can write at least one byte.  It returns the number of bytes actually written as a positive exact integer.</p><p><var>Bytes</var> may or may not be a bytes object returned by <code>make-i/o-buffer</code>.  It is possible that <code>writer-write!</code> operates more efficiently if it is, however.</p><p><var>Count</var> may or may not be the same as the chunk size of the reader. It is possible that <code>writer-write!</code> operates more efficiently if it is, however.</p><p>For a writer created by <code>make-simple-writer</code>, this calls the <var>write!</var> procedure of <var>writer</var> with the remaining arguments.</p></dd><dt><code>(writer-has-get-position? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> supports the <code>writer-get-position</code> operation, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-get-position </code><var>writer</var><code>)</code></dt><dd><p>When <code>writer-has-get-position?</code> returns <code>#t</code> for <var>writer</var>, this returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.</p><p>For a writer created by <code>make-simple-writer</code>, this calls the <var>get-position</var> procedure of <var>writer</var>, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>get-position</var> procedure.</p></dd><dt><code>(writer-has-set-position!? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> supports the <code>writer-set-position!</code> operation, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-set-position! </code><var>writer</var> <var>pos</var><code>)</code></dt><dd><p>When <code>writer-has-set-position!?</code> returns <code>#t</code> for <var>writer</var>, this moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p><p>For a writer created by <code>make-simple-writer</code>, this calls the <var>set-position!</var> procedure of <var>writer</var> with the <var>pos</var> argument, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>set-position!</var> procedure.</p></dd><dt><code>(writer-has-end-position? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> supports the <code>writer-end-position</code> operation, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-end-position </code><var>writer</var><code>)</code></dt><dd><p>When <code>writer-has-end-position?</code> returns <code>#t</code> for <var>writer</var>, this returns the byte position of the next end of file, without changing the current position.</p><p>For a writer created by <code>make-simple-writer</code>, this calls the <var>end-position</var> procedure of <var>writer</var>, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>end-position</var> procedure.</p></dd><dt><code>(writer-close </code><var>writer</var><code>)</code></dt><dd><p>This marks the writer as closed, performs any necessary cleanup, and releases the resources associated with the writer.  Further operations on the writer may signal an error.</p><p>For a writer created by <code>make-simple-writer</code>, this calls the <var>close</var> procedure of <var>writer</var>.</p></dd><dt><code>(open-bytes-writer)</code></dt><dd><p>This returns a writer that can yield everything written to it as a bytes object.  This writer has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(writer-bytes </code><var>writer</var><code>)</code></dt><dd><p>The <var>writer</var> argument must be a bytes writer returned by <code>open-bytes-writer</code>.  This procedure returns a newly allocated bytes object containing the data written to <var>writer</var> in sequence.  Doing this in no way invalidates the writer or change its store.</p></dd><dt><code>(open-file-writer </code><var>filename</var><code>)</code></dt><dt><code>(open-file-writer </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This returns a writer connected to the file named by <var>filename</var>. The <var>file-options</var> object defaults to <code>(file-options)</code>if not present.  It determines various aspects of the returned writer, see the <a href="#file-options">section on file options</a>. This writer has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(standard-output-writer)</code></dt><dd><p>This returns a writer connected to the standard output.  The meaning of  "standard output" is implementation-dependent.</p></dd><dt><code>(standard-error-writer)</code></dt><dd><p>This returns a writer connected to the standard error.  The meaning of  "standard error" is implementation-dependent.</p></dd></dl><h2>Opening files for reading and writing</h2><dl><dt><code>(open-file-reader+writer </code><var>filename</var><code>)</code></dt><dt><code>(open-file-reader+writer </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This returns two values, a reader and a writer connected to the file named by <var>filename</var>. The <var>file-options</var> object defaults to <code>(file-options)</code>if not present.  It determines various aspects of the returned writer and possibly the reader, see the <a href="#file-options">section on file options</a>. The reader and the writer have <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations, respectively.  </p><blockquote><p><i>Note:</i> This procedure enables opening a file for simultaneous input and output in environments where it is not possible to call <code>open-file-reader</code> and <code>open-file-writer</code> on the same file.</p></blockquote></dd></dl><h1>Reference Implementation</h1><p><a href="comprehensive-io-reference.tar.gz">Here</a> is a tarball containing a reference implementation of this SRFI, along with implementations for <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>, <a href="http://srfi.schemers.org/srfi-81/">SRFI 81 (Port I/O)</a>, and <a href="http://srfi.schemers.org/srfi-82/">SRFI 82: (Stream Ports)</a>.  It only runs on a version of Scheme 48 that has not been released at the time of writing in this SRFI.</p><p>However, its actual dependencies on Scheme 48 idiosyncracies are few.  Chief are its use of the module system, which is easily replaced by another, and the implementation of Unicode.  To implement primitive readers and writers on files, the code only relies on suitable library procedures to open the files, and <code>read-byte</code> and <code>write-byte</code> procedures to read or write single bytes from a (R5RS) port, as well as a <code>force-output</code> procedure to flush a port.</p><h1>Examples</h1><p>The tarball with the reference implementation contains these examples along with test cases for them.</p><p>This customized reader reads from a list of bytes objects.  A null bytes object yields EOF.</p><pre>(define (open-bytess-reader bs)
  (let* ((pos 0))
    (make-simple-reader
     "&lt;byte vectors&gt;"
     bs
     5                                  ; for debugging
     (lambda (bytes start count)
       (cond
        ((null? bs)
         0)
        (else
         (let* ((b (car bs))
                (size (bytes-length b))
                (real-count (min count (- size pos))))
           (bytes-copy! b pos
                           bytes start
                           real-count)
           (set! pos (+ pos real-count))
           (if (= pos size)
               (begin
                 (set! bs (cdr bs))
                 (set! pos 0)))
           real-count))))
     ;; pretty rough ...
     (lambda ()
       (if (null? bs)
           0
           (- (bytes-length (car bs)) pos)))
     #f #f #f                           ; semantics would be unclear
     (lambda ()
       (set! bs #f)))))                 ; for GC
</pre><p>Algorithmic reader producing an infinite stream of blanks:</p><pre>(define (make-infinite-blanks-reader)
  (make-simple-reader "&lt;blanks, blanks, and more blanks&gt;"
                      #f
                      4096
                      (lambda (bytes start count)
                        (let loop ((index 0))
                          (if (&gt;= index count)
                              index
                              (begin
                                (bytes-u8-set! bytes (+ start index) 32)
                                (loop (+ 1 index))))))
                      (lambda ()
                        1000) ; some number
                      #f #f #f
                      unspecific))
</pre><h1>Acknowledgements</h1><p>Sebastian Egner provided valuable comments on a draft of this SRFI. The posters to the <a href="http://srfi.schemers.org/srfi-68/">SRFI 68 (Comprehensive I/O)</a> provided many very valuable comments.  Donovan Kolbly did thorough pre-draft editing.  Any remaining mistakes are mine.</p><h1>References</h1><ul><li><a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</li></ul><H1>Copyright</H1>
Copyright (C) Michael Sperber (2005). All Rights Reserved. 
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Donovan Kolbly</a></address>
</body></html>
