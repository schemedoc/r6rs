<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>SRFI 81: Port I/O</title>
</head>
<body>

<H1>Title</H1>

Port I/O

<H1>Authors</H1>

Michael Sperber

<h1>Abstract</h1><p>This SRFI defines an I/O layer similar in nature to the ports subsystem in R5RS, and provides conventional, imperative buffered input and output.</p><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, the subsystem fulfills the following requirements:</p><ul><li>buffered reading and writing</li><li>binary and text I/O, mixed if needed</li><li>the ability to create arbitrary I/O ports from readers and writers</li></ul><p>It builds on the Primitive I/O  layer specified in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><h1>Rationale</h1><p>This SRFI is meant as a compelling replacement for the R5RS I/O subsystem.</p><p>The design of this SRFI is driven by the requirements mentioned in the abstract on the one hand.  Moreover, it is meant to fully integrate into a three-layer I/O subsystem where ports can be built on top of streams, as specified in <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>.  Ports can be implemented independently, however.</p><h1>Specification</h1><h2>Prerequisites</h2><p>This SRFI refers to a number of additions and changes of the upcoming R6RS.</p><ul><li><a href="http://srfi.schemers.org/srfi-34/">SRFI 34 (Exception Handling for Programs)</a></li><li><a href="http://srfi.schemers.org/srfi-35/">SRFI 35 (Conditions)</a></li></ul><p>The specification frequently mentions <i>bytes</i> objects.  These refer to the bytes objects that will be part of the upcoming R6RS. These are equivalent in functionality to the blobs of <a href="http://srfi.schemers.org/srfi-74/">SRFI 74 (Octet-Addressed Binary Blocks)</a> but differ in terminology and some aspects of the interface.</p><p>This SRFI uses the term "the unspecified value" to refer to the value returned by the <code>unspecified</code> procedure, which is the same as the value returned by <code>(if #f #f)</code>.</p><p>This SRFI also assumes the presence of a unique end of file object.</p><p>This SRFI assumes that the <code>char</code> datatype in Scheme corresponds to Unicode scalar values.  This, in turn, means that strings are analogous as vectors of scalar values. (Note that this is consistent with <a href="http://srfi.schemers.org/srfi-14/">SRFI 14 (Character-set library)</a> and <a href="http://srfi.schemers.org/srfi-75/">SRFI 75 (R6RS Unicode data)</a>.) </p><h2>Filenames</h2><p>Filenames in this SRFI are the same as in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><h2>File options</h2><p>File options are a subset of a certain set of symbols, as in <a href="http://srfi.schemers.org/srfi-79">SRFI 79 (Primitive I/O)</a>.</p><h2>Buffer modes</h2><p>Each output port has an associated <i>buffer mode</i> that defines when an output operation will flush the buffer associated with the output port.  The possible buffer modes are the symbols <code>none</code> for no buffering, <code>line</code> for flushing upon newlines, and <code>block</code> for block-based buffering.</p><dl><dt><code>(buffer-mode </code><var>name</var><code>)</code> (syntax)</dt><dd><p><var>Name</var> must be one of the symbols <code>none</code>, <code>line</code>, and <code>block</code>.  This returns the corresponding symbol denoting the associated buffer mode.</p><p>If <var>name</var> is not one of the valid identifiers, an exception must be raised with condition type <code>&amp;contract</code>at macro-expansion time.</p></dd><dt><code>(buffer-mode? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is a valid buffer-mode symbol, <code>#f</code> otherwise.</p></dd></dl><h2>Text Transcoders</h2><p>Text transcoders provide pre-packaged functionality for encoding and decoding text in some common encodings.  A <i>transcoder</i> is an opaque object encapsulating a specific translation from byte sequences to byte sequences.  For an input port, the transcoder translates the actual input to produce the input actually seen by the various <code>read-</code>... procedures. For an output port, the transcoder translates the data supplied to the various <code>write-</code>... procedures to produce the actual output.</p><p>This SRFI specifies how to obtain a transcoder given a text encoder/decoder (or <i>codec</i> for short) and a specified newline encoding. Hence, these transcoders all represent specific text encodings.  For input ports, the transcoders translate the encoding of the actual input to UTF-8 with the LF end-of-line convention.  For output ports, the transcoders translate UTF-8 with the LF end-of-line convention to the specified encoding.  Note that the <code>read-char</code> and the various <code>read-string</code>... procedures all decode UTF-8 with LF end-of-line convention, and that <code>write-char</code> and the various <code>write-string</code>... procedures encode the text they output as UTF-8.</p><p>As all ports operate on byte sequences, transcoding between text encodings may have to deal with encoding errors.  If a transcoder encounters an invalid or incomplete character encoding, it will treat the first byte of that encoding as the <code>?</code> character, skip that byte and continue.  Transcoders that do not support on full Unicode will produce <code>?</code> characters for unsupported characters.</p><p>In systems implementing <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>, the transcoders specified here may or may not be identical to those defined there.</p><dl><dt><code>(transcoder </code><code>(codec <var>codec</var>)</code> <code>(eol-style <var>eol-style</var>)</code><code>)</code> (syntax)</dt><dd><p>This constructs a transcoder object from a specified codec and a specified end-of-line style.  The <code>codec</code> and the <code>eol-style</code> clauses are both optional.  If present, <var>codec</var> and <var>eol-style</var>, must be expressions that evaluate to a codec and an eol-style symbol (see below), respectively.  If not present, the codec defaults to "no codec" (corresponding to UTF-8), and the eol-style symbol defaults to the platform's standard EOL convention.</p><p>Any operands to a <code>transcoder</code> form that do not match the above syntax may be platform-specific extensions.  The implementation is free to ignore them, but must not signal an error.</p></dd><dt><code>(update-transcoder </code><var>old</var> <code>(codec <var>codec</var>)</code> <code>(eol-style <var>eol-style</var>)</code><code>)</code> (syntax)</dt><dd><p>This form returns a new transcoder object constructed from an old one, with the <code>codec</code> and <code>eol-style</code> fields replaced by the specified values.  The <var>old</var> transcoder is unaffected by the operation.  (Again, the <code>codec</code> and the <code>eol-style</code> clauses are both optional.  Also, unrecognized operands can be ignored, but cannot signal an error.)</p></dd><dt><code>(eol-style </code><var>name</var><code>)</code> (syntax)</dt><dd><p><var>Name</var> must be one of the symbols <code>lf</code>, <code>lf</code>, and <code>crlf</code>.</p><p>This returns the corresponding symbol denoting the associated end-of-line style - <code>lf</code> stands for using U+000A, <code>crlf</code> stands for using U+000D U+000A, and <code>cr</code> stands for using U+000D as end-of-line.</p></dd><dt><code>(native-eol-style)</code></dt><dd><p>This returns the default end-of-line style of the underlying platform, i.e. <code>lf</code> on Unix and <code>crlf</code> on Windows.</p></dd><dt><code>(utf-8-codec)</code></dt><dt><code>(latin-1-codec)</code></dt><dt><code>(utf-16le-codec)</code></dt><dt><code>(utf-16be-codec)</code></dt><dt><code>(utf-32le-codec)</code></dt><dt><code>(utf-32be-codec)</code></dt></dl><dd><p>These are predefined codecs for the UTF-8, ISO8859-1, UTF-16LE, UTF-16BE, UTF32-LE, and UTF-32BE encodings.  Note that the UTF-8 codec performs no transcoding at all.</p></dd><h2>Input and Output Ports</h2><p>This SRFI provides buffered I/O based on <i>ports</i>.  Ports, like the streams in <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>, allow buffered I/O on the underlying data sources and destinations.  Input ports, like output ports, are imperative; a read operation destructively removes data from the port. The port layer is very similar, but not identical, to the R5RS I/O system.</p><p>The Port I/O layer introduces one condition type of its own.</p><pre>(define-condition-type &amp;i/o-port &amp;i/o
  i/o-port-error?
  (port i/o-error-port))
</pre><dl><dd><p>This condition type allows specifying with what particular port an I/O error is associated.  The <code>port</code> field has purely informational purpose.  Conditions raised by Port I/O procedures <em>may</em> include an <code>&amp;i/o-port-error</code> condition, but are not required to do so.</p></dd></dl><h3>Input ports</h3><p>An input port allows reading an infinite sequence of bytes puncuated by end of file objects.  An input port connected to a finite data source ends in an infinite sequence of end of file objects.</p><dl><dt><code>(input-port? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an input port, <code>#f</code> otherwise.</p></dd><dt><code>(read-bytes-some </code><var>input-port</var><code>)</code></dt><dd><p>This reads from <var>input-port</var>, blocking as necessary, until data is available from <var>input-port</var> or the next end of file has been reached.  This returns a freshly allocated bytes object of non-zero size containing that data, and updates <var>input-port</var> to point exactly past the data read. If an end of file has been reached, it returns the end of file object, and the input port is updated to point just past the end of file.</p></dd><dt><code>(read-u8 </code><var>input-port</var><code>)</code></dt><dd><p>This reads from <var>input-port</var>, blocking as necessary, until data is available from <var>input-port</var> or the next end of file has been reached.  If an byte is available before the next end of file, this returns that byte as an octet, and updates <var>input-port</var> to point exactly past the byte read. If an end of file has been reached, it returns the end of file object, and the input port is updated to point just past the end of file.</p></dd><dt><code>(read-bytes-n </code><var>input-port</var> <var>n</var><code>)</code></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of bytes to be read.</p><p>This reads from <var>input-port</var>, blocking as necessary, until <var>n</var>bytes are available from <var>input-port</var> or the next end of file has been reached before that.  This tries to read <var>n</var> bytes.  If <var>n</var> or more bytes are available before the next end of file, it returns a bytes object of size <var>n</var>.  If fewer bytes are available before the next end of file, it returns a bytes object containing those bytes. Subsequently, the input port is updated to point exactly past the data read. If end of file has been reached, this returns the end of file object, and the input port is updated to point just past the end of file.</p></dd><dt><code>(read-bytes-n! </code><var>input-port</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Count</var> must be an exact, non-negative integer, specifying the number of bytes to be read. <var>Bytes</var> must be a bytes object with at least <var>start</var> + <var>count</var> elements. This tries to read <var>count</var> bytes. </p><p>This reads from <var>input-port</var>, blocking as necessary, until <var>n</var>bytes are available from <var>input-port</var> or the next end of file has been reached before that.</p><p>If <var>count</var> or more bytes are available before the next end of file, they are written into <var>bytes</var> starting at index <var>start</var>, and it returns <var>count</var>.  If fewer bytes are available before the next end of file, it writes the available bytes into <var>bytes</var> starting at index <var>start</var>, and returns the number of bytes actually read. In either case, the input port is updated to point exactly past the data read. If end of file has been reached, this returns the end of file object, and it updates the input port to point just past the end of file.</p></dd><dt><code>(read-bytes-all </code><var>input-port</var><code>)</code></dt><dd><p>This attempts to read all data until the next end of file, blocking as necessary. If data is available before the next end of file, this returns a bytes object containing all bytes until that end of file.  If not, <code>read-bytes-all</code> returns the end of file object. The input port is updated to point just past the end of file.  Note that this function may block indefinitely on ports connected to interactive devices, even though data is available.</p></dd><dt><code>(read-char </code><var>input-port</var><code>)</code></dt><dd><p>This reads from <var>input-port</var>, blocking as necessary, until a complete UTF-8 encoding for a character is available from <var>input-port</var>, the prefix of the bytes read form an invalid encoding,  or the next end of file has been reached.  </p><p>If a complete character is available before the next end of file, this returns that character, and the input port is updated to point past the data read. If an end of file has been reached, this returns the end of file object, and the input port points just past the end of file.</p></dd><dt><code>(read-string-n </code><var>input-port</var> <var>n</var><code>)</code></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of characters to be read.</p><p>This reads from <var>input-port</var>, blocking as necessary, until <var>n</var> UTF-8 character encodings (including invalid encodings) are available, or the next end of file has been reached.</p><p>It tries to read <var>n</var> characters.  If <var>n</var> or more characters are available before the next end of file, it returns a string of size <var>n</var> consisting of those characters.  If fewer characters are available before the next end of file, it returns a string containing those characters.  In either case, the input port is updated to point exactly past the data read. If end of file has been reached, it returns the end of file object, and the input port is updated to point just past the end of file.</p></dd><dt><code>(read-string-n! </code><var>input-port</var> <var>string</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This reads from <var>input-port</var> in the same manner as <code>read-string-n</code>.</p><p><var>Count</var> must be an exact, non-negative integer, specifying the number of characters to be read.  It tries to read <var>count</var> characters.  If <var>count</var> or more characters are available before the next end of file, they are written into <var>string</var> starting at index <var>start</var>, and it returns <var>count</var> as the value. If fewer characters are available before the next end of file, it writes the available characters into <var>string</var> starting at index <var>start</var>, and it returns the number of characters actually read as the value. If end of file has been reached, it returns the end of file object, and the input port is updated to point just past the end of file.</p></dd><dt><code>(read-string-all </code><var>input-port</var><code>)</code></dt><dd><p>This reads from <var>input-port</var> until the next end of file, decoding characters in the same manner as <code>read-string-n</code> and <code>read-string-n!</code>.</p><p>If data is available before the next end of file, the value returned is a string containing all the text until the next end of file.  If no data is available, the value is the end of file object. The input port is updated to point just past the end of file.</p></dd><dt><code>(read-line </code><var>input-port</var><code>)</code></dt><dd><p>This reads from <var>input-port</var> until the next newline or end of file, decoding characters in the same manner as <code>read-string-n</code> and <code>read-string-n!</code>.</p><p>If data is available before the next newline or end of file, the value returned is a string containing all the text until the next newline or end of file.  If the data is followed by newline, input port is updated to point just past the newline.  If the data is followed by end of file, the input port is updated to point at the end of file. If no data is available, the value is the end of file object. The input port is updated to point just past the end of file.</p></dd><dt><code>(peek-u8 </code><var>input-port</var><code>)</code></dt><dd><p>This is the same as <code>read-u8</code>, but does not advance the port.</p></dd><dt><code>(peek-char </code><var>input-port</var><code>)</code></dt><dd><p>This is the same as <code>read-char</code>, but does not advance the port.</p></dd><dt><code>(port-eof? </code><var>input-port</var><code>)</code></dt><dd><p>Returns <code>#t</code> if the port is currently pointing at an end-of-file, <code>#f</code> otherwise.</p></dd><dt><a name="input-port-has-position?"><code>(input-port-has-position? </code><var>input-port</var><code>)</code></a></dt><dd><p>This returns <code>#t</code> if <var>input-port</var> supports the <code>input-port-position</code> operation (see below), and <code>#f</code> otherwise.</p></dd><dt><code>(input-port-position </code><var>input-port</var><code>)</code></dt><dd><p>This returns the byte position corresponding to the next byte read from the input port.  This procedure raises an exception with condition type <code>&amp;i/o-operation-not-available</code> if the port does not support the operation, specifically, when <var>input-port</var> is a transcoded port.</p></dd><dt><a name="input-port-has-set-position!?"><code>(input-port-has-set-position!? </code><var>input-port</var><code>)</code></a></dt><dd><p>This returns <code>#t</code> if <var>input-port</var> supports the <code>set-input-port-position!</code> operation (see below), and <code>#f</code> otherwise.</p></dd><dt><code>(set-input-port-position! </code><var>input-port</var> <var>pos</var><code>)</code></dt><dd><p><var>Pos</var> must be a non-negative exact integer.  This sets the current byte position of <var>input-port</var> to <var>pos</var>.  This procedure raises an exception with condition type <code>&amp;i/o-operation-not-available</code> if the port does not support the operation. specifically, when <var>input-port</var> is a transcoded port.</p></dd><dt><code>(transcode-input-port! </code><var>input-port</var> <var>transcoder</var><code>)</code></dt><dd><p>This transcodes <var>input-port</var> according to the encoding specified by <var>transcoder</var>, assuming <var>input-port</var> was previously not transcoded. The port will henceforth translate the data arriving at the port into UTF-8 with end-of-line encoded by U+000A.</p><p>It is an error for <var>input-port</var> to be transcoded upon the call to <code>transcode-input-port!</code>.</p></dd><dt><code>(close-input-port </code><var>input-port</var><code>)</code></dt><dd><p>This closes <var>input-port</var>, rendering the port incapable of accepting data.  This has no effect if the port has already been closed.  The unspecified value is returned.</p></dd><dt><code>(open-file-input-port </code><var>filename</var><code>)</code></dt><dt><code>(open-file-input-port </code><var>filename</var> <var>file-options</var><code>)</code></dt><dt><code>(open-file-input-port </code><var>filename</var> <var>file-options</var> <var>transcoder</var><code>)</code></dt><dd><p>This returns an input port for the named file. The <var>file-options</var> object defaults to <code>(file-options)</code>if not present.  It may determine various aspects of the returned port, see the <a href="#file-options">section on file options</a>. If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p><p>The returned input port supports the <code>input-port-position</code> and <code>set-input-port-position!</code> operations.</p></dd><dt><code>(open-bytes-input-port </code><var>bytes</var><code>)</code></dt><dt><code>(open-bytes-input-port </code><var>bytes</var> <var>transcoder</var><code>)</code></dt><dd><p>This returns an input port, associated with the bytes object <var>bytes</var>. If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p></dd><dt><code>(open-string-input-port </code><var>string</var><code>)</code></dt><dt><code>(open-string-input-port </code><var>string</var> <var>transcoder</var><code>)</code></dt><dd><p>This returns an input port, associated with the UTF-8 encoding of string <var>string</var>. If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p></dd><dt><code>(call-with-input-port </code><var>input-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>input-port</var> as an argument.  If <var>proc</var> returns, then the port is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the port will not be closed automatically, unless it is possible to prove that the port will never again be used for a read operation.</p></dd><dt><code>(standard-input-port)</code></dt><dd><p>Returns an input port connected to standard input, possibly a fresh one on each call.</p></dd></dl><h3>Output ports</h3><dl><dt><code>(output-port? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an output port, <code>#f</code> otherwise.</p></dd><dt><code>(write-bytes </code><var>output-port</var> <var>bytes</var><code>)</code></dt><dt><code>(write-bytes </code><var>output-port</var> <var>bytes</var> <var>start</var><code>)</code></dt><dt><code>(write-bytes </code><var>output-port</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers that default to 0 and <code>(bytes-length </code><var>bytes</var><code>)</code> - <var>start</var>, respectively.  <var>Bytes</var> must have a size of at least <var>start</var> + <var>count</var>.  This writes the <var>count</var> bytes in bytes object <var>bytes</var> starting at index <var>start</var> to the output port.  The unspecified value is returned.</p></dd><dt><code>(write-u8 </code><var>output-port</var> <var>octet</var><code>)</code></dt><dd><p>This writes <var>octet</var> to the output port.  The unspecified value is returned.</p></dd><dt><code>(write-string-n </code><var>output-port</var> <var>string</var><code>)</code></dt><dt><code>(write-string-n </code><var>output-port</var> <var>string</var> <var>start</var><code>)</code></dt><dt><code>(write-string-n </code><var>output-port</var> <var>string</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  <var>Start</var> defaults to 0. <var>Count</var> defaults to <code>(- (string-length <var>bytes</var>) <var>start</var>)</code>. This writes the UTF-8 encoding of the substring <code>(substring <var>string</var> (+ <var>start</var> <var>count</var>))</code> to the port.  The unspecified value is returned.</p></dd><dt><code>(write-char </code><var>output-port</var> <var>char</var><code>)</code></dt><dd><p>This writes the UTF-8 encoding of the character <var>char</var> to the port.  The unspecified value is returned.</p></dd><dt><code>(flush-output-port </code><var>output-port</var><code>)</code></dt><dd><p>This flushes any output from the buffer of <var>output-port</var> to the underlying data or device.  The unspecified value is returned.</p></dd><dt><code>(output-port-buffer-mode </code><var>output-port</var><code>)</code></dt><dd><p>This returns the buffer-mode object of <var>output-port</var>.</p></dd><dt><a name="output-port-has-position?"><code>(output-port-has-position? </code><var>output-port</var><code>)</code></a></dt><dd><p>This returns <code>#t</code> if <var>output-port</var> supports the <code>output-port-position</code> operation (see below), and <code>#f</code> otherwise.</p></dd><dt><code>(output-port-position </code><var>output-port</var><code>)</code></dt><dd><p>This returns the position corresponding to the next byte written to the output port.  This procedure raises an exception with condition type <code>&amp;i/o-operation-not-available</code> if the port does not support the operation, specifically, when <var>output-port</var> is a transcoded port.</p></dd><dt><a name="output-port-has-set-position!?"><code>(output-port-has-set-position!? </code><var>output-port</var><code>)</code></a></dt><dd><p>This returns <code>#t</code> if <var>output-port</var> supports the <code>set-output-port-position!</code> operation (see below), and <code>#f</code> otherwise.</p></dd><dt><code>(set-output-port-position! </code><var>output-port</var> <var>pos</var><code>)</code></dt><dd><p><var>Pos</var> must be a non-negative exact integer.  This flushes the output port and sets its current byte position to <var>pos</var>.  This procedure raises an exception with condition type <code>&amp;i/o-operation-not-available</code> if the port does not support the operation, specifically, when <var>output-port</var> is a transcoded port.</p></dd><dt><code>(transcode-output-port! </code><var>output-port</var> <var>transcoder</var><code>)</code></dt><dd><p>This transcodes <var>output-port</var>, translating the data fed into <var>output-port</var> into the encoding specified by <var>transcoder</var>, assuming it is encoded as UTF-8 with end-of-line encoded by U+000A.</p><p>If <var>output-port</var> was previously transcoded, the new transcoding replaces the old.</p></dd><dt><code>(close-output-port </code><var>output-port</var><code>)</code></dt><dd><p>This closes <var>output-port</var>, rendering the port incapable of delivering data.  This has no effect if the port has already been closed.  The unspecified value is returned.</p></dd><dt><code>(open-file-output-port </code><var>filename</var><code>)</code></dt><dt><code>(open-file-output-port </code><var>filename</var> <var>file-options</var><code>)</code></dt><dt><code>(open-file-output-port </code><var>filename</var> <var>file-options</var> <var>transcoder</var><code>)</code></dt><dt><code>(open-file-output-port </code><var>filename</var> <var>file-options</var> <var>transcoder</var> <var>buffer-mode</var><code>)</code></dt><dd><p>This returns an output port for the named file and the specified options (which defaults to <code>file-options</code>.) If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.  If <var>transcoder</var> is not specified or <code>#f</code>, the port is not transcoded.  <var>Buffer-mode</var> optionally specifies the buffer mode of the port; it defaults to <code>block</code>.</p><p>The returned output port supports the <code>output-port-position</code> and <code>set-output-port-position!</code> operations.</p></dd><dt><code>(call-with-bytes-output-port </code><var>proc</var><code>)</code></dt><dt><code>(call-with-bytes-output-port </code><var>proc</var> <var>transcoder</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output port connected to a bytes writer, and calls <var>proc</var> with that output port as an argument.  The call to <code>call-with-bytes-output-port</code> returns the bytes object associated with the port when <var>proc</var> returns.  If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p></dd><dt><code>(call-with-string-output-port </code><var>proc</var><code>)</code></dt><dt><code>(call-with-string-output-port </code><var>proc</var> <var>transcoder</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output connected to a bytes writer, and calls <var>proc</var> with that port as an argument.  The call to <code>call-with-string-output-port</code> returns the UTF-8 decoding of the bytes object associated with the port when <var>proc</var> returns.  If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p></dd><dt><code>(call-with-output-port </code><var>output-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>output-port</var> as an argument.  If <var>proc</var> returns, then the port is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the port will not be closed automatically, unless it is possible to prove that the port will never again be used for a write operation.</p></dd><dt><code>(standard-output-port)</code></dt><dt><code>(standard-error-port)</code></dt><dd><p>Returns a port connected to the standard output or standard error, respectively.</p></dd></dl><h3>Opening files for reading and writing</h3><dl><dt><code>(open-file-input+output-ports </code><var>filename</var><code>)</code></dt><dt><code>(open-file-input+output-ports </code><var>filename</var> <var>file-options</var><code>)</code></dt><dt><code>(open-file-input+output-ports </code><var>filename</var> <var>file-options</var> <var>transcoder</var><code>)</code></dt><dt><code>(open-file-input+output-ports </code><var>filename</var> <var>file-options</var> <var>transcoder</var> <var>buffer-mode</var><code>)</code></dt><dd><p>This returns two values, an input port and an output port for the named file and the specified options (which defaults to <code>(file-options)</code>). If a transcoder <var>transcoder</var> is specified, the ports are appropriately transcoded.  If <var>transcoder</var> is not specified or <code>#f</code>, the port is not transcoded.  <var>Buffer-mode</var> optionally specifies the buffer mode of the port; it defaults to <code>block</code>.</p><p>The returned ports support the <code>input-port-position</code> and <code>set-input-port-position!</code>, and <code>output-port-position</code> and <code>set-output-port-position!</code> operations, respectively.</p></dd></dl><h3>Ports from readers and writers</h3><dl><dt><code>(open-reader-input-port </code><var>reader</var><code>)</code></dt><dt><code>(open-reader-input-port </code><var>reader</var> <var>transcoder</var><code>)</code></dt><dd><p>This returns an input port connected to the reader <var>reader</var>.If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.</p></dd><dt><code>(open-writer-output-port </code><var>writer</var><code>)</code></dt><dt><code>(open-writer-output-port </code><var>writer</var> <var>transcoder</var><code>)</code></dt><dt><code>(open-writer-output-port </code><var>writer</var> <var>transcoder</var> <var>buffer-mode</var><code>)</code></dt><dd><p>This returns an output port connected to the writer <var>writer</var>. If a transcoder <var>transcoder</var> is specified, the port is appropriately transcoded.  If <var>transcoder</var> is not specified or <code>#f</code>, the port is not transcoded.  <var>Buffer-mode</var> optionally specifies the buffer mode of the port; it defaults to <code>block</code>.</p></dd></dl><h1>Design rationale</h1><h3>Encoding</h3><p>Many I/O system implementations allow associating an encoding with a port, allowing the direct use of several different encodings with ports.  The problem with this approach is that the encoding/decoding defines a mapping from binary data to text or vice versa.  Because of this asymmetry, such mappings do not compose.  The result is usually complications and restrictions in the I/O API, such as the inability to mix text or binary data.</p><p>This SRFI avoids this problem by specifying that textual I/O always uses UTF-8.  This means that, if the target or source of an I/O port is to use a different encoding, a translated port needs to be used, for which this SRFI offers the required facilities.  This means that text decoders or encoders are expressed as binary-to-binary mappings, and as such compose.</p><h3><code>display</code> vs <code>write</code></h3><p>R5RS calls the procedures for writing something to an output port <code>write-&lt;something&gt;</code>.  In a previous revision of this SRFI, all were called <code>display-&lt;something&gt;</code>.  R5RS doesn't offer a consistent rule for naming, as the <code>display</code> and <code>write-char</code> procedures behave identically on character arguments, wherease <code>write</code> and <code>write-char</code> do not.</p><p>Historically, it seems that the <a href="http://zurich.ai.mit.edu/pipermail/rrrs-authors/1985-March.txt">original proposal for the I/O subsystem in RnRS</a> indeed called the procedure <code>display-char</code>.  I do not know why it was renamed---probably for compatibility with Common Lisp, which also has <code>write-char</code>.</p><p>While the procedures in this SRFI follow a consistent naming scheme, consistency is an issue for what's <code>read</code> and <code>write</code>in R5RS. The naming scheme proposed here suggests they be called <code>read-datum</code> and <code>write-datum</code>.</p><h3><code>char-ready?</code></h3><p>This SRFI intentionally does not provide <code>char-ready?</code>, which is part of R5RS.  The original intention of the procedure seems to have been to interface with something like Unix <code>select(2)</code>.  With multi-byte encodings such as UTF-8, this is no longer sufficient: the procedure would really have to look at the actual input data in order to determine whether a complete character is actually present.  This makes realistic implementations of <code>char-ready?</code> inconsistent with the user's expectations.  A procedure <code>byte-ready?</code> would be more consistent.  On the other hand, such a procedure is rarely useful in real-world programs, hard to specify to the point where it would be portably usable, and complicates all layers of the I/O system, as readers would have to provide an additional member procedure to enable its implementation.  Moreover, a <code>select(2)</code>-like implementation is not possible on all plattforms and all types of ports.  Consequently, <code>char-ready?</code> and <code>byte-ready?</code> are not part of this SRFI.</p><h3><code>display</code></h3><p>This SRFI does not provide <code>display</code>, which is part of R5RS.  <code>Display</code> is woefully underspecified, and mostly used for debug output. It seems <code>display</code> should be replaced by a procedure for formatted output, possibly augmented by handling of dynamically-bound "current ports".</p><h3>Optional ports and argument order</h3><p>The argument order of the procedures in this SRFI is different from R5RS: The port is always at the beginning, and it is mandatory.For a rationale, see <a href="http://srfi.schemers.org/srfi-68/mail-archive/msg00031.html">the message by Taylor Campbell</a> on the subject.</p><h1>Reference Implementation</h1><p><a href="http://srfi.schemers.org/srfi-79/implementation/comprehensive-io-reference.tar.gz">Here</a> is a tarball containing a reference implementation of this SRFI, along with implementations for <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>, <a href="http://srfi.schemers.org/srfi-80/">SRFI 80 (Stream I/O)</a>, and <a href="http://srfi.schemers.org/srfi-82/">SRFI 82 (Stream Ports)</a>.  It only runs on a version of Scheme 48 that has not been released at the time of writing in this SRFI.</p><p>However, its actual dependencies on Scheme 48 idiosyncracies are few.  Chief are its use of the module system, which is easily replaced by another, and the implementation of Unicode.  To implement primitive readers and writers on files, the code only relies on suitable library procedures to open the files, and <code>read-byte</code> and <code>write-byte</code> procedures to read or write single bytes from a (R5RS) port, as well as a <code>force-output</code> procedure to flush a port.</p><p>The reference implementation has not been highly tuned, but I have spent a modest amount of time making the code deal with buffers in an economic manner.  Because of this, the code is more complicated than it needs to be, but hopefully also more usable as a basis for implementing this SRFI in actual Scheme systems.</p><h1>Examples</h1><p>Many examples are adapted from <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</p><p>The code makes liberal use of SRFIs <a href="http://srfi.schemers.org/srfi-1/"> SRFI 1 (List Library)</a>, <a href="http://srfi.schemers.org/srfi-11/">SRFI 11 (Syntax for receiving multiple values)</a>, <a href="http://srfi.schemers.org/srfi-26/">SRFI 26 (Notation for Specializing Parameters without Currying)</a>.</p><p>The tarball with the reference implementation contains these examples along with test cases for them.</p><pre>(define three-lines-string
  (call-with-string-output-port
   (lambda (port)
     (write-string port "foo") (write-char port #\newline)
     (write-string port "bar") (write-char port #\newline)
     (write-string port "baz") (write-char port #\newline))))
</pre><p>Read a file directly:</p><pre>(define (get-contents filename)
  (call-with-input-port (open-file-input-port filename)
    read-bytes-all))
</pre><p>Read a file byte-by-byte:</p><pre>(define (get-contents-2 filename)
  (call-with-input-port (open-file-input-port filename)
    (lambda (port)
      (let loop ((accum '()))
        (let ((thing (read-u8 port)))
          (if (eof-object? thing)
              (list-&gt;bytes (reverse accum))
              (loop (cons thing accum))))))))

(define (list-&gt;bytes l)
  (let ((bytes (make-bytes (length l))))
    (let loop ((i 0) (l l))
      (if (null? l)
          bytes
          (begin
            (bytes-u8-set! bytes i (car l))
            (loop (+ 1 i) (cdr l)))))))
</pre><p>Read file chunk-by-chunk:</p><pre>(define (get-contents-3 filename)
  (call-with-input-port (open-file-input-port filename)
    (lambda (port)
      (let loop ((accum '()))
        (cond
         ((non-eof (read-bytes-some port))
          =&gt; (lambda (bytes)
               (loop (cons bytes accum))))
         (else
          (concatenate-bytess (reverse accum))))))))

(define (concatenate-bytess list)
  (let* ((size (fold + 0 (map bytes-length list)))
         (result (make-bytes size)))
    (let loop ((index 0)
               (bytess list))
      (if (null? bytess)
          result
          (let* ((b (car bytess))
                 (size (bytes-length b)))
            (bytes-copy! b 0 result index size)
            (loop (+ index size)
                  (cdr bytess)))))))
</pre><h1>Acknowledgements</h1><p>Sebastian Egner provided valuable comments on a draft of this SRFI. The posters to the <a href="http://srfi.schemers.org/srfi-68/">SRFI 68 (Comprehensive I/O)</a> provided many very valuable comments.  Donovan Kolbly did thorough pre-draft editing.  Any remaining mistakes are mine.</p><h1>References</h1><ul><li><a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</li></ul><H1>Copyright</H1>
Copyright (C) Michael Sperber (2005). All Rights Reserved. 
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Donovan Kolbly</a></address>
</body></html>
