\section{Hash tables}

\subsection{Constructors}

\mainindex{hash table}

\begin{entry}{%
\proto{make-eq-hash-table}{}{}
\rproto{make-eq-hash-table}{ \var{k}}}

Returns a newly allocated hash table that accepts arbitrary objects as keys, 
and compares those keys with {\cf eq?}. If an argument is given, then the initial 
capacity of the hash table is set to \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-eqv-hash-table}{}{}
\rproto{make-eqv-hash-table}{ \var{k}}}

Returns a newly allocated hash table that accepts arbitrary objects as keys, 
and compares those keys with {\cf eqv?}.
If an argument is given, then the initial 
capacity of the hash table is set to \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-hash-table}{ \vari{procedure} \varii{procedure}}{}
\rproto{make-hash-table}{ \vari{procedure} \varii{procedure} \var{k}}}

Returns a newly allocated mutable hash table using \vari{procedure} 
as the hash function and \varii{procedure} as the procedure used to 
compare keys.  The hash function must accept a key and return a 
non-negative exact integer. If a third argument is given, then the 
initial capacity of the hash table is set to \var{k} elements.

Both the hash function \vari{procedure} and the comparison
predicate \varii{procedure} must behave like pure functions
on the domain of keys.  For example, the {\cf string-hash}
and {\cf string=?} procedures are permissible only if all
keys are strings and the contents of those strings are never
changed so long as any of them continue to serve as a key in
the hash table.  Furthermore any pair of values for which
the comparison predicate \varii{procedure} returns true must
be hashed to the same exact integers by the hash function
\vari{procedure}.

\begin{note}
Hash tables are allowed to cache the results of calling the
hash function and comparison predicate, so programs cannot
rely on the hash function being called for every lookup or
update.  Furthermore any hash table operation may call the
hash function more than once.
\end{note}

\begin{rationale}
Hash table lookups are often followed by updates, so caching
may improve performance.  Hash tables are free to change
their internal representation at any time, which may result
in many calls to the hash function.
\end{rationale}

\end{entry}

\subsection{Procedures}

\begin{entry}{%
\proto{hash-table?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} was created by one of the hash table constructors, otherwise returns \schfalse.
\end{entry}

\begin{entry}{\proto{hash-table-size}{ \var{hash-table}}}
Returns the number of keys contained in \var{hash-table} as an exact integer.
\end{entry}

\begin{entry}{%
\proto{hash-table-ref}{ \var{hash-table} \var{key} \var{default}}}
Returns the value in \var{hash-table} associated with \var{key}.
If \var{hash-table} does not contain an association for \var{key},
then \var{default} is returned.
\end{entry}

\begin{entry}{\proto{hash-table-set!}{ \var{hash-table} \var{key} \var{value}}}
Changes \var{hash-table} to associate \var{key} with value,
replacing any existing association for \var{key}.
Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-delete!}{ \var{hash-table} \var{key}}}
Removes any association for \var{key} within \var{hash-table}.
Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-contains?}{ \var{hash-table} \var{key}}}
Returns \schtrue{} if \var{hash-table} contains an association
for \var{key}, otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{%
\proto{hash-table-update!}{ \var{hash-table} \var{key} \var{procedure} \var{default}}}
Equivalent to, but potentially more efficient than:
\begin{scheme}
(hash-table-set!
 hash-table key
 (procedure (hash-table-ref
             hash-table key default)))
\end{scheme}
If \var{hash-table} does not contain an association for \var{key}, then \var{default} is passed to \var{procedure}.
\end{entry}

\begin{entry}{\proto{hash-table-fold}{ \var{procedure} \var{hash-table} \var{init}}}
For every association in \var{hash-table}, calls \var{procedure} with three arguments: the association key, the association value, and an accumulated value. The accumulated value is \var{init} for the first invocation of \var{procedure}, and for subsequent invocations of \var{procedure}, it is the return value of the previous invocation of \var{procedure}. The order of the calls to \var{procedure} is indeterminate. The return value of {\cf hash-table-fold} is the value of the last invocation of \var{procedure}. If any side effect is performed on the hash table while a {\cf hash-table-fold} operation is in progress, then the behavior of {\cf hash-table-fold} is unspecified.

\end{entry}

\begin{entry}{%
\proto{hash-table-copy}{ \var{hash-table}}{}
\rproto{hash-table-copy}{ \var{hash-table} \var{immutable}}}

Returns a copy of \var{hash-table}.  If the \var{immutable} argument is provided and is a true value, the returned hash table will be immutable, otherwise it will be mutable.

\end{entry}

\begin{entry}{\proto{hash-table-clear!}{ \var{hash-table}}}
Removes all associations from \var{hash-table}.  Returns the unspecified value.
\end{entry}

\begin{entry}{\proto{hash-table-keys}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold (lambda (k v a) (cons k a)) 
                 hash-table
                 '())
\end{scheme}
\end{entry}

\begin{entry}{\proto{hash-table-values}{ \var{hash-table}}}
Equivalent to:
\begin{scheme}
(hash-table-fold (lambda (k v a) (cons v a)) 
                 hash-table
                 '())
\end{scheme}
\end{entry}

\subsection{Reflection}

\begin{entry}{\proto{hash-table-equivalence-predicate}{ \var{hash-table}}}
Returns the equivalence predicate used by \var{hash-table} to compare keys.  For hash tables created with {\cf make-eq-hash-table} and {\cf make-eqv-hash-table}, returns {\cf eq?} and {\cf eqv?} respectively.
\end{entry}

\begin{entry}{\proto{hash-table-hash-function}{ \var{hash-table}}}
Returns the hash function used by hash-table.  For hash tables created by {\cf make-eq-hash-table} or {\cf make-eqv-hash-table}, \schfalse{} is returned.

\begin{rationale}
The {\cf make-eq-hash-table} and {\cf make-eqv-hash-table} constructors
are designed to hide their hash function.  This allows implementations
to use the machine address of an object as its hash value, rehashing
parts of the table as necessary whenever the garbage collector moves
objects to a different address.
\end{rationale}
\end{entry}

\begin{entry}{\proto{hash-table-mutable?}{ \var{hash-table}}}
Returns \schtrue{} if \var{hash-table} is mutable, \schfalse{} otherwise.
\end{entry}

\subsection{Hash functions}

The {\cf equal-hash}, {\cf string-hash}, and {\cf string-ci-hash}
procedures of this section are acceptable as hash functions only
if the keys on which they are called do not suffer side effects
while the hash table remains in use.

\begin{entry}{\proto{equal-hash}{ \var{obj}}}
Returns an integer hash value for \var{obj}, based on its structure and current contents.
\end{entry}

\begin{entry}{\proto{string-hash}{ \var{string}}}
Returns an integer hash value for \var{string}, based on its current contents.
\end{entry}

\begin{entry}{\proto{string-ci-hash}{ \var{string}}}
Returns an integer hash value for \var{string} based on its current contents, ignoring case.
\end{entry}

\begin{entry}{\proto{symbol-hash}{ \var{symbol}}}
Returns an integer hash value for \var{symbol}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
