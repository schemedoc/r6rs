\chapter{Scripts}
\label{scriptchapter}

A \defining{script} specifies an entry point for defining and running
a Scheme program.  A script specifies a set of libraries to import and
code to run.  Through the imported libraries, whether directly or the
transitive closure of importing, the script defines a complete Scheme
program.

Scripts follow the convention of many common platforms of accepting a
list of string \defining{command-line arguments} that may be used to
pass data to the script.  Moreover, a script can return an exact
integer specifying the script's \defining{exit value}.

\section{Script syntax}

A script is a delimited piece of text, typically a file, that follows
the following syntax:

\begin{grammar}
\meta{script} \: \meta{script header} \meta{script substance}
\meta{script header} \: \#! \meta{space} /usr/bin/env \meta{space}
  \> scheme-script \meta{linefeed}
\meta{script substance} \: \#!r6rs \meta{import form} \meta{script body}
  \> \| \meta{import form} \meta{script body}
\meta{import form} \: (import \arbno{\meta{import spec}})
\meta{script body} \: \arbno{\meta{script body form}} \meta{expression}
\meta{script body form} \: \| \meta{definition}
\> \| \meta{expression}
\end{grammar}

\subsection{Script header}

The first line of a script is:
\begin{verbatim}
#! /usr/bin/env scheme-script
\end{verbatim}
%
Implementations are required to ignore the first 
line of a script, however, even if it is not the above.
This allows script
headers to be customized locally by altering the script header from its
default portable form.

Implementations should provide an executable program named {\cf scheme-script}
that is capable of executing scripts on platforms where this makes
sense.  On most Unix-like systems, due to the 
use of the {\cf /usr/bin/env} trampoline, this program may itself be a shell 
script.

Most platforms require that scripts be marked as executable in some way, 
the details of which vary by platform and are beyond the scope of this 
report. Platforms which do not support the Unix-like script header syntax 
may need to use other mechanisms, such as a registered filename extension, 
in order to associate a script with the {\cf scheme-script} executable.

\subsection{Script substance}

The rules for \meta{script substance} specify syntax at the form level.

The \meta{import form} is identical to the import clause in
libraries (see section~\ref{librarysyntaxsection}), 
and specifies a set of libraries to import.  A \meta{script
  body} is like a \meta{library body} (see
section~\ref{librarybodysection}), except that 
definitions and expressions may occur in any order, and that the final
form of the script body must be an expression.  Thus, the syntax
specified by \meta{script body form} refers to the result of macro
expansion.

When base-library {\cf begin} forms occur anywhere within a script body,
they are spliced into the body; see section~\ref{begin}.
Some or all of the script body, including portions wrapped in {\cf begin}
forms, may be specified by a syntactic abstraction
(see section~\ref{macrosection}).

\section{Script semantics}

A script is executed by treating the script similarly to a library, and
invoking it.  The semantics of a script body may be roughly explained by
a simple translation into a library body: 
Each \hyper{expression} that appears before a
definition in
the script body is converted into a dummy definition 
{\cf (define \hyper{variable} (begin \hyper{expression} (unspecified)))},
where \hyper{variable} is fresh identifier.
(It is generally impossible to determine which forms are 
definitions and expressions without concurrently expanding the body, so
the actual translation is somewhat more complicated; see
chapter~\ref{expansionchapter}.)

A script may access its command-line arguments by calling the {\cf
  command-line-arguments} procedure (see
library section~\ref{lib:command-line-arguments}).  The final expression of a
script must return an exact integer, which becomes the exit value of
the script.  How that exit value is communicated to the environment is
implementation-specific.  When a script is invoked as a Unix or
Windows program, the exit value simply becomes the exit status of the
program.

If an exception with a {\cf\&serious} condition is raised during the
execution of the script, the default exception handler behaves as
described in library section~\ref{lib:exceptionssection}, and an
implementation-specific exit value is communicated to the
environment.  On Unix, this value is according to the definition of
{\cf EX\_SOFTWARE} in the {\cf sysexits.h} header~\cite{srfi22}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
