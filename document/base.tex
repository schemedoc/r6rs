%\vfill\eject
\chapter{Base library}
\label{baselibrarychapter}

This chapter describes Scheme's \deflibrary{r6rs base} library, which exports many of
the procedure and syntax bindings that are traditionally associated
with Scheme.

All exports of the \library{r6rs base} library are exported with level
$0$, except for exports {\cf syntax-rules} and {\cf identifier-syntax}
from the {\cf (r6rs base)} library, which are exported with level $1$.

Section~\ref{basetailcontextsection} defines the rules that identify
tail calls and tail contexts in base-library constructs.

\section{Base types}
\label{disjointness}

No object satisfies more than one of the following predicates:

\begin{scheme}
boolean?          pair?
symbol?           number?
char?             string?
vector?           procedure?
unspecified?      null?%
\end{scheme}

These predicates define the base types {\em boolean}, {\em pair}, {\em
symbol}, {\em number}, {\em char} (or {\em character}), {\em string}, {\em
vector}, and {\em procedure}.  Moreover, the empty list is a special
object of its own type, as is the unspecified value.
\mainindex{type}\schindex{boolean?}\schindex{pair?}\schindex{symbol?}
\schindex{number?}\schindex{char?}\schindex{string?}\schindex{vector?}
\schindex{procedure?}\index{empty list}\index{unspecified value}
\schindex{unspecified?}\schindex{null?}

Note that, although there is a separate boolean type, any Scheme value
can be used as a boolean value for the purpose of a conditional test;
see section~\ref{booleanvaluessection}.

\section{Definitions}
\label{defines}

The {\cf define} forms described in this section are definitions for
value bindings and may appear anywhere other definitions may appear.
See section~\ref{librarybodysection}.

A \hyper{definition} must have one of the following forms:\mainschindex{define}\mainindex{definition}

\begin{itemize}

\item{\tt(define \hyper{variable} \hyper{expression})}
  This binds \hyper{variable} to a new
  location before assigning the value of \hyper{expression} to it.
\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}

\item{\tt(define \hyper{variable})}

This form is equivalent to
\begin{scheme}
(define \hyper{variable} (unspecified))%
\end{scheme}

\item{\tt(define (\hyper{variable} \hyper{formals}) \hyper{body})}

\hyper{Formals} must be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a space-delimited period and another variable (as
in a lambda expression, see section~\ref{lambda}).  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

\item{\tt(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}

\hyper{Formal} must be a single
variable.  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}

\item a syntax definition (see section~\ref{define-syntax})
\end{itemize}

\section{Syntax definitions}
\label{syntaxdefinitionsection}

Syntax definitions are established with {\cf define-syntax}.
A {\cf define-syntax} form is a \hyper{definition} and may appear
anywhere other definitions may appear.

\begin{entry}{%
\proto{define-syntax}{ \hyper{variable} \hyper{expression}}{\exprtype}}

This binds the keyword \hyper{variable} to the value of
\hyper{expression}, which must evaluate, at macro-expansion
time, to a transformer.  (See library section~\extref{lib:transformerssection}{Transformers}).

Keyword bindings established by {\cf define-syntax} are visible
throughout the body in which they appear, except where shadowed by
other bindings, and nowhere else, just like variable bindings established
by {\cf define}.
All bindings established by a set of internal definitions, whether
keyword or variable definitions, are visible within the definitions
themselves.

\implresp The implementation must check that the value of
\hyper{expression} is a transformer when the evaluation produces a
value.

For example:

\begin{scheme}
(let ()
  (define even?
    (lambda (x)
      (or (= x 0) (odd? (- x 1)))))
  (define-syntax odd?
    (syntax-rules ()
      ((odd?  x) (not (even? x)))))
  (even? 10))                       \ev \schtrue{}%
\end{scheme}

An implication of the left-to-right processing order
(section~\ref{expansionchapter}) is that one internal definition can
affect whether a subsequent form is also a definition.  For example,
the expression

\begin{scheme}
(let ()
  (define-syntax bind-to-zero
    (syntax-rules ()
      ((bind-to-zero id) (define id 0))))
  (bind-to-zero x)
  x) \ev 0%
\end{scheme}

This behavior is irrespective of any binding for
{\cf bind-to-zero} that might appear outside of the {\cf let}
expression.
\end{entry}

\section{Bodies and sequences}
\label{bodiessection}

\index{body}The body \hyper{body} of a \ide{lambda}, \ide{let}, \ide{let*},
\ide{let-values}, \ide{let*-values}, \ide{letrec*}, \ide{letrec}
expression or that of a
definition with a body has the following form:

{\cf \hyper{definition} \ldots{} \hyper{sequence}}

\hyper{Sequence} has the following form:

{\cf \hyperi{expression} \hyperii{expression} \ldots}

Definitions may occur in a \hyper{body}.
Such definitions are known as {\em internal definitions}
\mainindex{internal definition} as opposed to library body
definitions. 

With \ide{lambda}, \ide{let}, \ide{let*}, \ide{let-values},
\ide{let*-values}, \ide{letrec*}, and \ide{letrec},
the identifier defined by an internal
definition is local to the \hyper{body}.  That is, the identifier is
bound, and the region of the binding is the
entire \hyper{body}.  For example,

\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}

When base-library {\cf begin} forms occur in a body prior to the first
expression, they are spliced into the body; see section~\ref{begin}.
Some or all of the body, including portions wrapped in {\cf begin}
forms, may be specified by a syntactic abstraction
(see section~\ref{macrosection}).

An expanded \hyper{body} (see chapter~\ref{expansionchapter})
containing internal definitions can
always be converted into an equivalent {\cf letrec*}
expression.  For example, the {\cf let} expression in the above
example is equivalent to

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

\section{Expressions}
\label{expressionsection}

The entries in this section describe the expressions of the base
language, which may occur in the position of the \hyper{expression}
syntactic variable.  The expressions also include constant literals,
variable references and procedure calls as described in
section~\ref{primitiveexpressionsection}.

\subsection{Literal expressions}\unsection
\label{literalsection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}}

\syntax \hyper{Datum} should be a datum value.

\semantics
{\cf (quote \hyper{datum})} evaluates to the datum
denoted by \hyper{datum}.
(See
section~\ref{readsyntaxsection}.).  This notation is used to include literal
constants in Scheme code.

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

As noted in section~\ref{quotesection}, {\cf (quote \hyper{datum})}
may be abbreviated as \singlequote\hyper{datum}:

\begin{scheme}
'"abc"               \ev  "abc"
'145932              \ev  145932
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

As noted in section~\ref{storagemodel}, the value of a literal
expression may be immutable.
\end{entry}

\subsection{Procedures}\unsection
\label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{Formals} must be a formal arguments list as described below,
and \hyper{body} must be according to section~\ref{bodiessection}.

\semantics
\vest A \lambdaexp{} evaluates to a procedure.  The environment in
effect when the \lambdaexp{} is evaluated is remembered as part of the
procedure.  When the procedure is later called with some actual
arguments, the environment in which the \lambdaexp{} was evaluated is
extended by binding the variables in the formal argument list to
fresh locations, and the resulting actual argument values are stored
in those locations.  Then, the expressions in the body of the \lambdaexp{}
(which may contain internal definitions and thus represent a {\cf
  letrec*} form, see section~\ref{bodiessection}) are evaluated
sequentially in the extended environment.
The results of the last expression in the body are returned as
the results of the procedure call.

\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}a procedure}
((lambda (x) (+ x x)) 4)  \ev  8

((lambda (x)
   (define (p y)
     (+ y 1))
   (+ (p x) x))
 5) \ev 11

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{Formals} must have one of the following forms:

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments are stored in the bindings of the
corresponding variables.

\item \hyper{variable}:
The procedure takes any number of arguments; when the procedure is
called, the sequence of actual arguments is converted into a newly
allocated list, and the list is stored in the binding of the
\hyper{variable}.

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
If a space-delimited period precedes the last variable, then
the procedure takes $n$ or more arguments, where $n$ is the
number of formal arguments before the period (there must
be at least one).
The value stored in the binding of the last variable is a
newly allocated
list of the actual arguments left over after all the other actual
arguments have been matched up against the other formal arguments.
\end{itemize}

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

It is a syntax violation for a \hyper{variable} to appear more than once in
\hyper{formals}.

Each procedure created as the result of evaluating a \lambdaexp{} is
(conceptually) tagged
with a storage location, in order to make \ide{eqv?} and
\ide{eq?} work on procedures (see section~\ref{equivalencesection}).

\end{entry}


\subsection{Conditionals}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{Test}, \hyper{consequent}, and \hyper{alternate} must be 
expressions.

\semantics
An {\cf if} expression is evaluated as follows: first,
\hyper{test} is evaluated.  If it yields a true value\index{true} (see
section~\ref{booleanvaluessection}), then \hyper{consequent} is evaluated and
its value(s) is(are) returned.  Otherwise \hyper{alternate} is evaluated and its
value(s) is(are) returned.  If \hyper{test} yields a false value and no
\hyper{alternate} is specified, then the result of the expression is
the unspecified value.

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1
(if \#f \#f)                    \ev \theunspecified%
\end{scheme}

\end{entry}


\subsection{Assignments}\unsection
\label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\hyper{Expression} is evaluated, and the resulting value is stored in
the location to which \hyper{variable} is bound.  \hyper{Variable} must
be bound either in some region\index{region} enclosing the {\cf set!}\ expression
or at the top level of a library body.  The result of the {\cf set!} expression is
the unspecified value.

\begin{scheme}
(let ((x 2))
  (+ x 1)
  (set! x 4)
  (+ x 1)) \ev  5%
\end{scheme}

It is a syntax violation if \hyper{variable} refers to an
immutable binding.
\end{entry}

\subsection{Derived conditionals}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}

\syntax
Each \hyper{clause} must be of the form
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)%
\end{scheme}
where \hyper{test} is any expression.  Alternatively, a \hyper{clause} may be
of the form
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
The last \hyper{clause} may be
an ``else clause'', which has the form
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}
\mainschindex{else}
\mainschindex{=>}

\semantics
A {\cf cond} expression is evaluated by evaluating the \hyper{test}
expressions of successive \hyper{clause}s in order until one of them
evaluates to a true value\index{true} (see
section~\ref{booleanvaluessection}).  When a \hyper{test} evaluates to a true
value, then the remaining \hyper{expression}s in its \hyper{clause} are
evaluated in order, and the result(s) of the last \hyper{expression} in the
\hyper{clause} is(are) returned as the result(s) of the entire {\cf cond}
expression.  If the selected \hyper{clause} contains only the
\hyper{test} and no \hyper{expression}s, then the value of the
\hyper{test} is returned as the result.  If the selected \hyper{clause} uses the
\ide{=>} alternate form, then the \hyper{expression} is evaluated.
Its value must be a procedure that accepts one argument; this procedure is then
called on the value of the \hyper{test} and the value(s) returned by this
procedure is(are) returned by the {\cf cond} expression.
If all \hyper{test}s evaluate
to false values, and there is no else clause, then the result of
the conditional expression is the unspecified value; if there is an else
clause, then its \hyper{expression}s are evaluated, and the value(s) of
the last one is(are) returned.

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ('(1 2 3) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}

A sample definition of {\cf cond} in terms of simpler forms is in
appendix~\ref{derivedformsappendix}.
\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}

\syntax
\hyper{Key} must be an expression.  Each \hyper{clause} has one of
the following forms:
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)
(else \hyperi{expression} \hyperii{expression} \dotsfoo)%
\end{scheme}
\schindex{else}
The second form, which specifies an ``else clause'',
may only appear as the last \hyper{clause}.
Each \hyper{datum} is an external representation of some object.
The datums denoted by the \hyper{datum}s need not be distinct.

\semantics
A {\cf case} expression is evaluated as follows.  \hyper{Key} is
evaluated and its result is compared against the datums
denoted by the \hyper{datum}s of each \hyper{clause} in turn, proceding
in order from left to right through the set of clauses.  If the
result of evaluating \hyper{key} is equivalent (in the sense of
{\cf eqv?}; see section~\ref{eqv?}) to a datum of a \hyper{clause}, the
corresponding \hyper{expression}s are evaluated from left
to right and the results of the last expression in the \hyper{clause} are
returned as the results of the {\cf case} expression.  Otherwise, the
comparison process continues.  If the result of
evaluating \hyper{key} is different from every datum in each set, then if
there is an else clause its expressions are evaluated and the
results of the last are the results of the {\cf case} expression;
otherwise the result of the {\cf case} expression is the unspecified value.

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \theunspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))            \ev  consonant%
\end{scheme}

% A sample definition of {\cf case} in terms of simpler forms is in
% appendix~\ref{derivedformsappendix}.
\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{\exprtype}}

\syntax The \hyper{test}s must be expressions.

\semantics
The \hyper{test} expressions are evaluated from left to right, and the
value of the first expression that evaluates to a false value (see
section~\ref{booleanvaluessection}) is returned.  Any remaining expressions
are not evaluated.  If all the expressions evaluate to true values, the
value of the last expression is returned.  If there are no expressions
then \schtrue{} is returned.

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

The {\cf and} keyword could be defined in terms of {\cf if} using {\cf
  syntax-rules} (see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{and}
  (syntax-rules ()
    ((and) \sharpfoo{t})
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) \sharpfoo{f}))))%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{\exprtype}}

\syntax The \hyper{test}s must be expressions.

\semantics
The \hyper{test} expressions are evaluated from left to right, and the value of the
first expression that evaluates to a true value (see
section~\ref{booleanvaluessection}) is returned.  Any remaining expressions
are not evaluated.  If all expressions evaluate to false values, the
value of the last expression is returned.  If there are no
expressions then \schfalse{} is returned.

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or '(b c) (/ 3 0))             \ev  (b c)%
\end{scheme}

The {\cf or} keyword could be defined in terms of {\cf if} using {\cf
  syntax-rules} (see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{or}
  (syntax-rules ()
    ((or) \sharpfoo{f})
    ((or test) test)
    ((or test1 test2 ...)
     (let ((x test1))
       (if x x (or test2 ...))))))%
\end{scheme}
\end{entry}


\subsection{Binding constructs}

The four binding constructs {\cf let}, {\cf let*}, {\cf letrec}, and {\cf letrec*}
give Scheme a block structure, like Algol 60.  The syntax of the four
constructs is identical, but they differ in the regions\index{region} they establish
for their variable bindings.  In a {\cf let} expression, the initial
values are computed before any of the variables become bound; in a
{\cf let*} expression, the bindings and evaluations are performed
sequentially.  In a {\cf letrec} or {\cf letrec*}
expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.  In a {\cf letrec} expression, the
initial values are computed before being assigned to the variables;
in a {\cf letrec*}, the evaluations and assignments are performed
sequentially.

In addition, the binding constructs {\cf let-values} and {\cf
  let*-values} allow the binding of results of expression returning
multiple values.  They are analogous to {\cf let} and {\cf let*} in the
way they establish regions: in a {\cf let-values} expression, the
initial values are computed before any of the variables become bound;
in a {\cf let*-values} expression, the bindings are performed
sequentially. 

\begin{note}
  These forms are compatible with SRFI~11~\cite{srfi11}.
\end{note}

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.  It is a
syntax violation for a \hyper{variable} to appear more than once in the list of variables
being bound.

\semantics
The \hyper{init}s are evaluated in the current environment (in some
unspecified order), the \hyper{variable}s are bound to fresh locations
holding the results, the \hyper{body} is evaluated in the extended
environment, and the value(s) of the last expression of \hyper{body}
is(are) returned.  Each binding of a \hyper{variable} has \hyper{body} as its
region.\index{region}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

See also named {\cf let}, section \ref{namedlet}.

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} must be a sequence of
one or more expressions.

\semantics
The {\cf let*} form is similar to {\cf let}, but the bindings are performed
sequentially from left to right, and the region\index{region} of a binding indicated
by {\cf(\hyper{variable} \hyper{init})} is that part of the {\cf let*}
expression to the right of the binding.  Thus the second binding is done
in an environment in which the first binding is visible, and so on.

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\begin{note}
  While a {\cf let} expression must not contain duplicate
  variables, a {\cf let*} expression can.
\end{note}

The {\cf let*} keyword could be defined in terms of {\cf let} using {\cf
  syntax-rules} (see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{let*}
  (syntax-rules ()
    ((let* () body1 body2 ...)
     (let () body1 body2 ...))
    ((let* ((name1 expr1) (name2 expr2) ...)
       body1 body2 ...)
     (let ((name1 expr1))
       (let* ((name2 expr2) ...)
         body1 body2 ...)))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} must be a sequence of
one or more expressions. It is a syntax violation for a \hyper{variable} to appear more
than once in the list of variables being bound.

\semantics
The \hyper{variable}s are bound to fresh locations, the \hyper{init}s
are evaluated in the resulting environment (in
some unspecified order), each \hyper{variable} is assigned to the result
of the corresponding \hyper{init}, the \hyper{body} is evaluated in the
resulting environment, and the value(s) of the last expression in
\hyper{body} is(are) returned.  Each binding of a \hyper{variable} has the
entire {\cf letrec} expression as its region\index{region}, making it possible to
define mutually recursive procedures.

\begin{scheme}
%(letrec ((x 2) (y 3))
%  (letrec ((foo (lambda (z) (+ x y z))) (x 7))
%    (foo 4)))                   \ev  14
%
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))   
                \ev  \schtrue%
\end{scheme}

One restriction on {\cf letrec} is very important: it must be possible
to evaluate each \hyper{init} without assigning or referring to the
value of any \hyper{variable}.  The restriction is necessary because
Scheme passes arguments by value rather than by name.  In the most
common uses of {\cf letrec}, all the \hyper{init}s are \lambdaexp{}s
and the restriction is satisfied automatically.

\implresp An implementation may choose one particular order for
evaluating the \hyper{init} expressions, and, for that particular
order, must check that evaluation does not violate the restriction
described above.

A sample definition of {\cf letrec} in terms of simpler forms is in
appendix~\ref{derivedformsappendix}.
\end{entry}

\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} must be a sequence of
one or more expressions. It is a syntax violation for a \hyper{variable} to appear more
than once in the list of variables being bound.

\semantics
The \hyper{variable}s are bound to fresh locations  undefined,
each \hyper{variable} is assigned in left-to-right order to the
result of evaluating the corresponding \hyper{init}, the \hyper{body} is
evaluated in the resulting environment, and the value(s) of the last
expression in \hyper{body} is(are) returned. 
Despite the left-to-right evaluation and assignment order, each binding of
a \hyper{variable} has the entire {\cf letrec*} expression as its
region\index{region}, making it possible to define mutually recursive
procedures.

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
                \ev  5%
\end{scheme}

One restriction on {\cf letrec*} is very important: it must be possible
to evaluate each \hyper{init} without assigning or referring to the value
of the corresponding \hyper{variable} or the \hyper{variable} of any of
the bindings that follow it in \hyper{bindings}.
The restriction is necessary because Scheme passes arguments by value
rather than by name. 

The {\cf letrec*} keyword could be defined approximately in terms of {\cf let}
and {\cf set!}
using {\cf syntax-rules} (see section~\ref{syntaxrulessection})
as follows:

\begin{scheme}
(define-syntax \ide{letrec*}
  (syntax-rules ()
    ((letrec* ((var1 init1) ...) body1 body2 ...)
     (let ((var1 <undefined>) ...)
       (set! var1 init1)
       ...
       (let () body1 body2 ...)))))%
\end{scheme}

The syntax {\cf <undefined>} represents an expression that
returns something that, when stored in a location, causes an exception
with condition type {\cf\&assertion} to
be raised if an attempt to read from or write to the location occurs before the
assignments generated by the {\cf letrec*} transformation take place.
(No such expression is defined in Scheme.)
\end{entry}

\begin{entry}{%
\proto{let-values}{ \hyper{mv-bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Mv-bindings} must have the form
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} is as described in section~\ref{bodiessection}. It is
a syntax violation for a variable to appear more
than once in the list of variables that appear as part of the formals.

\semantics The \hyper{init}s are evaluated in the current environment
(in some unspecified order), and the variables occurring in the
\hyper{formals} are bound to fresh locations containing the values
returned by the \hyper{init}s, where the \hyper{formals} are matched
to the return values in the same way that the \hyper{formals} in a
\lambdaexp{} are matched to the actual arguments in a procedure call.
Then, the \hyper{body} is evaluated in the extended environment, and the
value(s) of the last expression of \hyper{body} is(are) returned.
Each binding of a variable has \hyper{body} as its
region.\index{region}
If the \hyper{formals} do not match, an exception with condition type
{\cf\&assertion} is raised.

\begin{scheme}
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) \ev (1 2 3 4)

(let-values (((a b . c) (values 1 2 3 4)))
  (list a b c))            \ev (1 2 (3 4))

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let-values (((a b) (values x y))
               ((x y) (values a b)))
    (list a b x y)))       \ev (x y a b)%
\end{scheme}

A sample definition of {\cf let-values} in terms of simpler forms is in
appendix~\ref{derivedformsappendix}.
\end{entry}

\begin{entry}{%
\proto{let*-values}{ \hyper{mv-bindings} \hyper{body}}{\exprtype}}

The {\cf let*-values} form is the same as with {\cf let-values}, but the bindings are
processed sequentially from left to right, and the
region\index{region} of the bindings indicated by {\cf(\hyper{formals}
  \hyper{init})} is that part of the {\cf let*-values} expression to
the right of the bindings.  Thus, the second set of bindings is evaluated in
an environment in which the first set of bindings is visible, and so
on.

\begin{scheme}
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))  \ev (x y x y)%
\end{scheme}

The following macro defines {\cf let*-values} in terms of {\cf let}
and {\cf let-values}:

\begin{scheme}
(define-syntax let*-values
  (syntax-rules ()
    ((let*-values () body1 body2 ...)
     (let () body1 body2 ...))
    ((let*-values (binding1 binding2 ...)
       body1 body2 ...)
     (let-values (binding1)
       (let*-values (binding2 ...)
         body1 body2 ...)))))%
\end{scheme}

\end{entry}

\subsection{Sequencing}\unsection

\begin{entry}{%
\proto{begin}{ \hyper{form} \dotsfoo}{\exprtype}
\rproto{begin}{ \hyper{expression} \hyper{expression} \dotsfoo}{\exprtype}}

The \hyper{begin} keyword has two different roles, depending on its
context:
\begin{itemize}
\item It may appear as a form in a \hyper{body} (see
  section~\ref{bodiessection}), \hyper{library body} (see
  section~\ref{librarybodysection}), or \hyper{toplevel body} (see
  chapter~\ref{programchapter}), or directly nested in a {\cf begin}
  form that appears in a body.  In this case, the {\cf begin} form
  must have the shape specified in the first header line.  This use of
  {\cf begin} acts as a \defining{splicing} form---the forms inside
  the \hyper{body} are spliced into the surrounding body, as if the
  {\cf begin} wrapper were not actually present.
  
  A {\cf begin} form in a \hyper{body} or \hyper{library body} must
  be non-empty if it appears after the first \hyper{expression}
  within the body.
\item It may appear as an ordinary expression and must have the shape
  specified in the second header line.  In this case, the
  \hyper{expression}s are evaluated sequentially from left to right,
  and the value(s) of the last \hyper{expression} is(are) returned.
  This expression type is used to sequence side effects such as
  assignments or input
  and output.
\end{itemize}

\begin{scheme}
(define x 0)

(begin (set! x 5)
       (+ x 1))                  \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em and prints}  4 plus 1 equals 5%
\end{scheme}

The following macro, which uses {\cf syntax-rules} (see
section~\ref{syntaxrulessection}), defines {\cf begin} in terms of {\cf
  lambda}.  Note that it only covers the expression case of {\cf begin}.
%
\begin{scheme}
(define-syntax \ide{begin}
  (syntax-rules ()
    ((begin exp ...)
     ((lambda () exp ...)))))%
\end{scheme}

The following alternative expansion for {\cf begin} does not make use of
the ability to write more than one expression in the body of a lambda
expression.  It, too, only covers the expression case of {\cf begin}.

\begin{scheme}
(define-syntax begin
  (syntax-rules ()
    ((begin exp)
     exp)
    ((begin exp1 exp2 ...)
     (call-with-values
         (lambda () exp1)
       (lambda ignored
         (begin exp2 ...))))))%
\end{scheme}

\end{entry}

\section{Equivalence predicates}
\label{equivalencesection}

A \defining{predicate} is a procedure that always returns a boolean
value (\schtrue{} or \schfalse).  An \defining{equivalence predicate} is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, {\cf eq?}\ is the finest or most
discriminating, and {\cf equal?}\ is the coarsest.  The {\cf eqv?} predicate is
slightly less discriminating than {\cf eq?}.  \todo{Pitman doesn't like
this paragraph.  Lift the discussion from the Maclisp manual.  Explain
why there's more than one predicate.}


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns \schtrue{} if \vari{obj} and \varii{obj} should
normally be regarded as the same object.  This relation is left slightly
open to interpretation, but the following partial specification of
{\cf eqv?} holds for all implementations of Scheme.

The {\cf eqv?} procedure returns \schtrue{} if one of the following holds:

\begin{itemize}
\item \vari{Obj} and \varii{obj} are both \schtrue{} or both \schfalse.

\item \vari{Obj} and \varii{obj} are both symbols and

\begin{scheme}
(string=? (symbol->string obj1)
          (symbol->string obj2))
    \ev  \schtrue%
\end{scheme}

\item \vari{Obj} and \varii{obj} are both exact\index{exact} numbers,
  and are numerically equal (see {\cf =}, 
  section~\ref{genericarithmeticsection}).

\item \vari{Obj} and \varii{obj} are both inexact\index{inexact} numbers, are numerically
  equal (see {\cf =}, section~\ref{genericarithmeticsection}, and
  yield the same results (in the sense of {\cf eqv?}) when passed
  as arguments to any other procedure that can be defined
  as a finite composition of Scheme's standard arithmetic
  procedures.

\item \vari{Obj} and \varii{obj} are both characters and are the same
character according to the {\cf char=?} procedure
(section~\ref{charactersection}).

\item Both \vari{obj} and \varii{obj} are the empty list, or the unspecified value,
respectively.

\item \vari{Obj} and \varii{obj} are pairs, vectors, or strings that denote the
same locations in the store (section~\ref{storagemodel}).

\item \vari{Obj} and \varii{obj} are procedures whose location tags are
equal (section~\ref{lambda}).
\end{itemize}

The {\cf eqv?} procedure returns \schfalse{} if one of the following holds:

\begin{itemize}
\item \vari{Obj} and \varii{obj} are of different types
(section~\ref{disjointness}).

\item One of \vari{obj} and \varii{obj} is \schtrue{} but the other is
\schfalse{}.

\item \vari{Obj} and \varii{obj} are symbols but

\begin{scheme}
(string=? (symbol->string \vari{obj})
          (symbol->string \varii{obj}))
    \ev  \schfalse%
\end{scheme}

\item One of \vari{obj} and \varii{obj} is an exact number but the other is
        an inexact number.

\item \vari{Obj} and \varii{obj} are rational numbers for which the {\cf =} procedure
  returns \schfalse{}.

\item \vari{Obj} and \varii{obj} yield different results (in the sense of
  {\cf eqv?}) when passed as arguments to any other procedure
  that can be defined as a finite composition of Scheme's
  standard arithmetic procedures.

\item \vari{Obj} and \varii{obj} are characters for which the {\cf char=?}
  procedure returns \schfalse{}.

\item One of \vari{obj} and \varii{obj} is the empty list, 
  or the unspecified value, but the other is not.

\item \vari{Obj} and \varii{obj} are pairs, vectors, or strings that denote
distinct locations.

\item \vari{Obj} and \varii{obj} are procedures that would behave differently
(return different value(s) or have different side effects) for some arguments.

\end{itemize}

\begin{note}
  The {\cf eqv?} procedure returning \schtrue{} when \vari{obj} and
  \varii{obj} are numbers does not imply that {\cf =} would also
  return \schtrue{} when called with \vari{obj} and \varii{obj} as
  arguments.
\end{note}


\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? '() '())                   \ev  \schtrue
(eqv? (unspecified) (unspecified)) \lev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(eqv? \#f 'nil)                  \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \schtrue%
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified
(eqv? +nan.0 +nan.0)             \ev \unspecified%
\end{scheme}

The next set of examples shows the use of {\cf eqv?}\ with procedures
that have local state.  Calls to {\cf gen-counter} must return a distinct
procedure every time, since each procedure has its own internal counter.
The {\cf gen-loser} procedure, however, returns equivalent procedures each time, since
the local state does not affect the value or side effects of the
procedures.

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

Since the effect of trying to modify constant objects (those returned by
literal expressions) is unspecified, implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of {\cf eqv?} on constants is sometimes
implementation-dependent.

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))         \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

\begin{rationale} 
The above definition of {\cf eqv?} allows implementations latitude in
their treatment of procedures and literals:  implementations are free
either to detect or to fail to detect that two procedures or two literals
are equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eq?} predicate is similar to {\cf eqv?}\ except that in some cases it is
capable of discerning distinctions finer than those detectable by
{\cf eqv?}.

The {\cf eq?}\ and {\cf eqv?} predicates are guaranteed to have the same
behavior on symbols, booleans, the empty list, 
the unspecified value, pairs, procedures,
and non-empty
strings and vectors.  The behavior of {\cf eq?} on numbers and characters is
implementation-dependent, but it always returns either true or
false, and returns true only when {\cf eqv?}\ would also return
true.  The {\cf eq?} predicate may also behave differently from {\cf eqv?} on empty
vectors and empty strings.

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? (unspecified) (unspecified)) \lev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}

\todo{Needs to be explained better above.  How can this be made to be
not confusing?  A table maybe?}

\begin{rationale} It is usually possible to implement {\cf eq?}\ much
more efficiently than {\cf eqv?}, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute {\cf eqv?}\ of two numbers in
constant time, whereas {\cf eq?}\ implemented as pointer comparison will
always finish in constant time.  The {\cf eq?} predicate may be used like {\cf eqv?}\
in applications using procedures to implement objects with state since
it obeys the same constraints as {\cf eqv?}.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf equal?}  predicate returns \schtrue{} if and only if the
(possibly infinite) unfoldings of its arguments into regular trees are
equal as ordered trees.

The {\cf equal?} predicate treats pairs and vectors
as nodes with outgoing edges, uses {\cf
  string=?} to compare strings, uses {\cf
  bytesvector=?} to compare bytevectors (see library chapter~\extref{lib:bytevectorschapter}{Bytevectors}),
  and uses {\cf eqv?} to compare other nodes.

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? '\#vu8(1 2 3 4 5)
        (u8-list->bytevector
         '(1 2 3 4 5))          \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified

(let* ((x (list 'a))
       (y (list 'a))
       (z (list x y)))
  (list (equal? z (list y x))
        (equal? z (list x x))))             \lev  (\schtrue{} \schtrue{})%
\end{scheme}

\end{entry}

\section{Procedure predicate}

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse%
\end{scheme}

\end{entry}

\section{Unspecified value}
\label{unspecifiedvalue}

\begin{entry}{%
\proto{unspecified}{}{procedure}}

Returns the unspecified value.\index{unspecified value} (See section
\ref{disjointness}.)
\end{entry}

\begin{note}
  The unspecified value is not a datum value, and thus has no external
  representation.
\end{note}

\begin{entry}{%
\proto{unspecified?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is the unspecified value, otherwise
returns \schfalse.
\end{entry}

\section{Generic arithmetic}
\label{genericarithmeticsection}

The procedures described here implement arithmetic that is
generic over
the numerical tower described in chapter~\ref{numbertypeschapter}.
The generic procedures described in this section
accept both exact and inexact numbers as arguments,
performing coercions and selecting the appropriate operations
as determined by the numeric subtypes of their arguments.

Library chapter~\extref{lib:numberchapter}{Arithmetic} describes
libraries that define other numerical procedures.

\subsection{Propagation of exactness and inexactness}
\label{propagationsection}

The procedures listed below must return the correct exact result
provided all their arguments are exact:

\begin{scheme}
+            -            *
max          min          abs
numerator    denominator  gcd
lcm          floor        ceiling
truncate     round        rationalize
expt         real-part    imag-part
make-rectangular%
\end{scheme}

The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:

\begin{scheme}
/
div          mod           div-and-mod
div0         mod0          div0-and-mod0%
\end{scheme}

The general rule is that the generic operations return the correct
exact result when all of their arguments are exact and the result is
mathematically well-defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include
{\cf sqrt}, {\cf exp}, {\cf log},
{\cf sin}, {\cf cos}, {\cf tan},
{\cf asin}, {\cf acos}, {\cf atan},
{\cf expt}, {\cf make-polar}, {\cf magnitude}, and {\cf angle}, which
are allowed (but not required) to return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.

One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is {\cf (* 1.0 0)} which
may return either {\cf 0} (exact) or {\cf 0.0} (inexact).

\subsection{Representability of infinities and NaNs}
\label{infinitiesnanssection}

The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these numbers in ways that are consistent with the
IEEE 754 standard for binary floating point arithmetic.  
An implementation of Scheme is not required to represent infinities and
NaNs, however;
an implementation must raise a continuable exception with
condition type {\cf\&no-infinities} or {\cf\&no-nans} (respectively;
see library section~\extref{lib:flonumssection}{Flonums})
whenever it is unable to represent an infinity or NaN as required by
the specification.  In this case, the continuation of the exception
handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to
conversions between numbers and external representations, including
the reading of program source code.

\subsection{Semantics of common operations}

Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.

\subsubsection{Integer division}
\label{integerdivision}

For various kinds of arithmetic (fixnum, flonum, exact, inexact, and
generic), Scheme provides operations for performing integer
division.  They rely on mathematical operations $\mathrm{div}$,
$\mathrm{mod}$, $\mathrm{div}_0$, and
$\mathrm{mod}_0$, that are defined as follows:

$\mathrm{div}$, $\mathrm{mod}$, $\mathrm{div}_0$, and $\mathrm{mod}_0$
each accept two real numbers $x_1$ and $x_2$ as operands, where
$x_2$ must be nonzero.

$\mathrm{div}$ returns an integer, and $\mathrm{mod}$ returns a real.
Their results are specified by
%
\begin{eqnarray*}
x_1~\mathrm{div}~x_2 &=& n_d\\
x_1~\mathrm{mod}~x_2 &=& x_m
\end{eqnarray*}
%
where
%
\begin{displaymath}
\begin{array}{c}
x_1 = n_d * x_2 + x_m\\
0 \leq x_m < |x_2|
\end{array}
\end{displaymath}
%
Examples:
\begin{eqnarray*}
5~\mathrm{div}~3    &=&  1\\
5~\mathrm{div}~-3   &=&  -1\\
5~\mathrm{mod}~3    &=&  2\\
5~\mathrm{mod}~-3   &=&  2
\end{eqnarray*}
%
$\mathrm{div}_0$ and $\mathrm{mod}_0$ are like $\mathrm{div}$ and
$\mathrm{mod}$, except the result of $\mathrm{mod}_0$ lies within a
half-open interval centered on zero.  The results are specified by
%
\begin{eqnarray*}
x_1~\mathrm{div}_0~x_2 &=& n_d\\
x_1~\mathrm{mod}_0~x_2 &=& x_m
\end{eqnarray*}
%
where:
%
\begin{displaymath}
\begin{array}{c}
x_1 = n_d * x_2 + x_m\\
-|\frac{x_2}{2}| \leq x_m < |\frac{x_2}{2}|
\end{array}
\end{displaymath}
%
Examples:
%
\begin{eqnarray*}
5~\mathrm{div}_0~3    &=&  2\\
5~\mathrm{div}_0~-3   &=&  -2\\
5~\mathrm{mod}_0~3    &=&  -1\\
5~\mathrm{mod}_0~-3   &=&  -1
\end{eqnarray*}

\begin{rationale}
The half-open symmetry about zero is convenient for some purposes.
\end{rationale}

\subsubsection{Transcendental functions}
\label{transcendentalfunctions}

In general, the transcendental functions $\log$, $\sin^{-1}$
(arcsine), $\cos^{-1}$ (arccosine), and $\tan^{-1}$ are multiply
defined.  The value of $\log z$ is defined to be the one whose
imaginary part lies in the range from $-\pi$ (inclusive if $-0.0$ is
distinguished, exclusive otherwise) to $\pi$ (inclusive).  $\log 0$ is
undefined.

The value of $\log z$ for non-real $z$ is defined in terms of log on real numbers as 

\begin{displaymath}
\log z = \log |z| + \mathrm{angle}~z
\end{displaymath}
%
where $\mathrm{angle}~z$ is the angle of $z = a\cdot e^{ib}$ specified
as:
$$\mathrm{angle}~z = b+2\pi n$$
with $-\pi \leq \mathrm{angle}~z\leq \pi$ and $\mathrm{angle}~z =
b+2\pi n$ for some integer $n$.

With the one-argument version of $\log$ defined this way, the values
of the two-argument-version of $\log$, $\sin^{-1} z$, $\cos^{-1} z$,
$\tan^{-1} z$, and the two-argument version of $\tan^{-1}$ are
according to the following formul\ae:
\begin{eqnarray*}
\log z~b &=& \frac{\log z}{\log b}\\
\sin^{-1} z &=& -i \log (i z + \sqrt{1 - z^2})\\
\cos^{-1} z &=& \pi / 2 - \sin^{-1} z\\
\tan^{-1} z &=& (\log (1 + i z) - \log (1 - i z)) / (2 i)\\
\tan^{-1} x~y &=& \mathrm{angle}(x+ yi)
\end{eqnarray*}

The range of $\tan^{-1} x~y$ is as in the following table. The
asterisk (*) indicates that the entry applies to implementations that
distinguish minus zero.

\begin{center}
\begin{tabular}{clll}
& $y$ condition & $x$ condition & range of result $r$\\\hline
& $y = 0.0$ & $x > 0.0$ & $0.0$\\
$\ast$ & $y = +0.0$  & $x > 0.0$ & $+0.0$\\     
$\ast$ & $y = -0.0$ & $x > 0.0$ & $-0.0$\\
& $y > 0.0$ & $x > 0.0$ & $0.0 < r < \frac{\pi}{2}$\\
& $y > 0.0$ & $x = 0.0$ & $\frac{\pi}{2}$\\
& $y > 0.0$ & $x < 0.0$ & $\frac{\pi}{2} < r < \pi$\\
& $y = 0.0$ & $x < 0$ & $\pi$\\
$\ast$ & $y = +0.0$ & $x < 0.0$ & $\pi$\\
$\ast$ & $y = -0.0$ & $x < 0.0$ & $-\pi$\\      
&$y < 0.0$ & $x < 0.0$ & $-\pi< r< -\frac{\pi}{2}$\\
&$y < 0.0$ & $x = 0.0$ & $-\frac{\pi}{2}$\\
&$y < 0.0$ & $x > 0.0$ & $-\frac{\pi}{2} < r< 0.0$\\    
&$y = 0.0$ & $x = 0.0$ & undefined\\
$\ast$& $y = +0.0$ & $x = +0.0$ & $+0.0$\\
$\ast$& $y = -0.0$ & $x = +0.0$& $-0.0$\\
$\ast$& $y = +0.0$ & $x = -0.0$ & $\pi$\\
$\ast$& $y = -0.0$ & $x = -0.0$ & $-\pi$\\
$\ast$& $y = +0.0$ & $x = 0$ & $\frac{\pi}{2}$\\
$\ast$& $y = -0.0$ & $x = 0$    & $-\frac{\pi}{2}$
\end{tabular}
\end{center}

The above specification follows Steele~\cite{CLtL}, which in turn
cites Penfield~\cite{Penfield81}; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.

\subsection{Numerical operations}

\subsubsection{Numerical type predicates}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object is
of the named type, and otherwise they return \schfalse{}.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.

If \var{z} is a complex number, then {\cf (real? \var{z})} is true if
and only if {\cf (zero? (imag-part \var{z}))} and {\cf (exact?
  (imag-part \var{z}))} are both true.

If \var{x} is a real number, then {\cf (rational? \var{x})} is true if
and only if there exist exact integers \vari{k} and \varii{k} such that
{\cf (= \var{x} (/ \vari{k} \varii{k}))} and {\cf (= (numerator
  \var{x}) \vari{k})} and {\cf (= (denominator \var{x}) \varii{k})} are
all true.  Thus infinities and NaNs are not rational numbers.

If \var{q} is a rational number, then {\cf (integer?
\var{q})} is true if and only if {\cf (= (denominator
\var{q}) 1)} is true.  If \var{q} is not a rational number,
then {\cf (integer? \var{q})} is false.

\begin{scheme}
(complex? 3+4i)                        \ev  \schtrue{}
(complex? 3)                           \ev  \schtrue{}
(real? 3)                              \ev  \schtrue{}
(real? -2.5+0.0i)                      \ev  \schfalse{}
(real? -2.5+0i)                        \ev  \schtrue{}
(real? -2.5)                           \ev  \schtrue{}
(real? \sharpsign{}e1e10)                         \ev  \schtrue{}
(rational? 6/10)                       \ev  \schtrue{}
(rational? 6/3)                        \ev  \schtrue{}
(rational? 2)                          \ev  \schtrue{}
(integer? 3+0i)                        \ev  \schtrue{}
(integer? 3.0)                         \ev  \schtrue{}
(integer? 8/4)                         \ev  \schtrue{}

(number? +nan.0)                       \ev  \schtrue{}
(complex? +nan.0)                      \ev  \schtrue{}
(real? +nan.0)                         \ev  \schtrue{}
(rational? +nan.0)                     \ev  \schfalse{}
(complex? +inf.0)                      \ev  \schtrue{}
(real? -inf.0)                         \ev  \schtrue{}
(rational? -inf.0)                     \ev  \schfalse{}
(integer? -inf.0)                      \ev  \schfalse{}%
\end{scheme}

\begin{note}
The behavior of these type predicates on inexact numbers is
unreliable, because any inaccuracy may
affect the result.
\end{note}
\end{entry}

\begin{entry}{%
\proto{real-valued?}{ obj}{procedure}
\proto{rational-valued?}{ obj}{procedure}
\proto{integer-valued?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  The {\cf real-valued?} procedure
They return \schtrue{} if the object is a number and is equal in the
sense of {\cf =} to some real number, or if the object is a NaN, or a
complex number whose real part is a NaN and whose imaginary part zero
in the sense of {\cf zero?}.  The {\cf rational-valued?} and {\cf
  integer-valued?} procedures return \schtrue{} if the object is a
number and is equal in the sense of {\cf =} to some object of the
named type, and otherwise they return \schfalse{}.

\begin{scheme}
(real-valued? +nan.0)                  \ev  \schtrue{}
(real-valued? +nan.0+0i)                  \ev  \schtrue{}
(real-valued? -inf.0)                  \ev  \schtrue{}
(real-valued? 3)                       \ev  \schtrue{}
(real-valued? -2.5+0.0i)               \ev  \schtrue{}
(real-valued? -2.5+0i)                 \ev  \schtrue{}
(real-valued? -2.5)                    \ev  \schtrue{}
(real-valued? \sharpsign{}e1e10)                  \ev  \schtrue{}

(rational-valued? +nan.0)              \ev  \schfalse{}
(rational-valued? -inf.0)              \ev  \schfalse{}
(rational-valued? 6/10)                \ev  \schtrue{}
(rational-valued? 6/10+0.0i)           \ev  \schtrue{}
(rational-valued? 6/10+0i)             \ev  \schtrue{}
(rational-valued? 6/3)                 \ev  \schtrue{}

(integer-valued? 3+0i)                 \ev  \schtrue{}
(integer-valued? 3+0.0i)               \ev  \schtrue{}
(integer-valued? 3.0)                  \ev  \schtrue{}
(integer-valued? 3.0+0.0i)             \ev  \schtrue{}
(integer-valued? 8/4)                  \ev  \schtrue{}%
\end{scheme}

\begin{rationale}
  These procedures test whether a given number can be coerced to the
  specified type without loss of numerical accuracy.  Their behavior
  is different from the numerical type predicates in the previous
  entry, whose behavior is motivated by closure properties designed to
  enable statically predictable semantics and efficient implementation.
\end{rationale}

\begin{note}
The behavior of these type predicates on inexact numbers is
unreliable, because any inaccuracy may
affect the result.
\end{note}
\end{entry}

\begin{entry}{%
\proto{exact?}{ z}{procedure}
\proto{inexact?}{ z}{procedure}}

These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates is
true.

\begin{scheme}
(exact? 5)                   \ev  \schtrue{}
(inexact? +inf.0)            \ev  \schtrue{}%
\end{scheme}
\end{entry}

\subsubsection{Generic conversions}

\begin{entry}{%
\proto{->inexact}{ z}{procedure}
\proto{->exact}{ z}{procedure}}

{\cf ->inexact} returns an inexact representation of \var{z}.  If
inexact numbers of the appropriate type have bounded precision, then
the value returned is an inexact number that is nearest to the
argument.  If an exact argument has no reasonably close inexact
equivalent, an exception with condition type
{\cf\&implementation-violation} may be
raised.

{\cf ->exact} returns an exact representation of \var{z}.  The value
returned is the exact number that is numerically closest to the
argument; in most cases, the result of this procedure should be
numerically equal to its argument.  If an inexact argument has no
reasonably close exact equivalent, an exception with condition type
{\cf\&implementation-violation} may be
raised.

These procedures implement the natural one-to-one correspondence
between exact and inexact integers throughout an
implementation-dependent range.

{\cf ->inexact} and {\cf ->exact} are idempotent.
\end{entry}

\begin{entry}{%
\proto{real->flonum}{ x}{procedure}}

Returns the best flonum representation of
\var{x}.

The value returned is a flonum that is numerically closest to the
argument.

\begin{rationale}
  Not all reals are inexact, and some inexact reals may
  not be flonums.
\end{rationale}

\begin{note}
  If flonums are represented in binary floating point, then
  implementations are strongly encouraged to break ties by preferring
  the floating point representation whose least significant bit is
  zero.
\end{note}
\end{entry}

\begin{entry}{%
\proto{real->single}{ x}{procedure}
\proto{real->double}{ x}{procedure}}

Given a real number \var{x}, these procedures compute the best
IEEE-754 single or double precision approximation to \var{x} and
return that approximation as an inexact real.

\begin{note}
  Both of the two conversions performed by these procedures (to
  IEEE-754 single or double, and then to an inexact real) may lose
  precision, introduce error, or may underflow or overflow.
\end{note}

\begin{rationale}
  The ability to round to IEEE-754 single or double precision is
  occasionally needed for control of precision or for
  interoperability.
\end{rationale}

\end{entry}
\subsubsection{Arithmetic operations}

\begin{entry}{%
\proto{=}{ \vari{z} \varii{z} \variii{z} \dotsfoo}{procedure}
\proto{<}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{>}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{<=}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{>=}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically
nonincreasing, and \schfalse{} otherwise.

\begin{scheme}
(= +inf.0 +inf.0)           \ev  \schtrue{}
(= -inf.0 +inf.0)           \ev  \schfalse{}
(= -inf.0 -inf.0)           \ev  \schtrue{}%
\end{scheme}

For any real number \var{x} that is neither infinite nor NaN:

\begin{scheme}
(< -inf.0 \var{x} +inf.0))        \ev  \schtrue{}
(> +inf.0 \var{x} -inf.0))        \ev  \schtrue{}%
\end{scheme}

For any number \var{z}:
%
\begin{scheme}
(= +nan.0 \var{z})               \ev  \schfalse{}%
\end{scheme}
%
For any real number \var{x}:
%
\begin{scheme}
(< +nan.0 \var{x})               \ev  \schfalse{}
(> +nan.0 \var{x})               \ev  \schfalse{}%
\end{scheme}

These predicates are required to be transitive.

\begin{note}
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
\end{note}

\begin{note}
While it is possible to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of {\cf =} and {\cf zero?}.

When in doubt, consult a numerical analyst.
\end{note}
\end{entry}

\begin{entry}{%
\proto{zero?}{ z}{procedure}
\proto{positive?}{ x}{procedure}
\proto{negative?}{ x}{procedure}
\proto{odd?}{ n}{procedure}
\proto{even?}{ n}{procedure}
\proto{finite?}{ x}{procedure}
\proto{infinite?}{ x}{procedure}
\proto{nan?}{ x}{procedure}}

These numerical predicates test a number for a particular property,
returning \schtrue{} or \schfalse{}.  See note above.  The {\cf zero?}
procedure
tests if the number is {\cf =} to zero, {\cf positive?} tests whether it is
greater than zero, {\cf negative?} tests whether it is less than zero, {\cf
  odd?} tests whether it is odd, {\cf even?} tests whether it is even, {\cf
  finite?} tests whether it is not an infinity and not a NaN, {\cf
  infinite?} tests whether it is an infinity, {\cf nan?} tests whether it is a
NaN.

\begin{scheme}
(positive? +inf.0)            \ev  \schtrue{}
(negative? -inf.0)            \ev  \schtrue{}
(finite? +inf.0)              \ev  \schfalse{}
(finite? 5)                   \ev  \schtrue{}
(finite? 5.0)                 \ev  \schtrue{}
(infinite? 5.0)               \ev  \schfalse{}
(infinite? +inf.0)            \ev  \schtrue{}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{max}{ \vari{x} \varii{x} \dotsfoo}{procedure}
\proto{min}{ \vari{x} \varii{x} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.

\begin{scheme}
(max 3 4)                              \ev  4    ; exact
(max 3.9 4)                            \ev  4.0  ; inexact%
\end{scheme}

For any real number \var{x}:

\begin{scheme}
(max +inf.0 \var{x})                         \ev  +inf.0
(min -inf.0 \var{x})                         \ev  -inf.0%
\end{scheme}

\begin{note}
If any argument is inexact, then the result is also inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If {\cf min} or
{\cf max} is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may raise an exception with condition
type {\cf\&implementation-restriction}.
\end{note}

\end{entry}

\begin{entry}{%
\proto{+}{ \vari{z} \dotsfoo}{procedure}
\proto{*}{ \vari{z} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.

\begin{scheme}
(+ 3 4)                                \ev  7
(+ 3)                                  \ev  3
(+)                                    \ev  0
(+ +inf.0 +inf.0)                      \ev  +inf.0
(+ +inf.0 -inf.0)                      \ev  +nan.0

(* 4)                                  \ev  4
(*)                                    \ev  1
(* 5 +inf.0)                           \ev  +inf.0
(* -5 +inf.0)                          \ev  -inf.0
(* +inf.0 +inf.0)                      \ev  +inf.0
(* +inf.0 -inf.0)                      \ev  -inf.0
(* 0 +inf.0)                           \ev  0 \textit{or} +nan.0
(* 0 +nan.0)                           \ev  0 \textit{or} +nan.0
(* 1.0 0)                              \ev  0 \textit{or} 0.0%
\end{scheme}

For any real number \var{x} that is neither infinite nor NaN:

\begin{scheme}
(+ +inf.0 \var{x})                           \ev  +inf.0
(+ -inf.0 \var{x})                           \ev  -inf.0
(+ +nan.0 \var{x})                           \ev  +nan.0%
\end{scheme}

For any real number \var{x} that is neither
infinite nor NaN nor an exact 0:

\begin{scheme}
(* +nan.0 \var{x})                           \ev  +nan.0%
\end{scheme}

If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either raise an exception with
condition type {\cf\&implementation-restriction} or return an unspecified number.
\end{entry}

\begin{entry}{%
\proto{-}{ z}{procedure}
\rproto{-}{ \vari{z} \varii{z} \dotsfoo}{procedure}
\proto{/}{ z}{procedure}
\rproto{/}{ \vari{z} \varii{z} \dotsfoo}{procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.

\begin{scheme}
(- 3 4)                                \ev  -1
(- 3 4 5)                              \ev  -6
(- 3)                                  \ev  -3
(- +inf.0 +inf.0)                      \ev  +nan.0

(/ 3 4 5)                              \ev  3/20
(/ 3)                                  \ev  1/3
(/ 0.0)                                \ev  +inf.0
(/ 1.0 0)                              \ev  +inf.0
(/ -1 0.0)                             \ev  -inf.0
(/ +inf.0)                             \ev  0.0
(/ 0 0)                                \lev \exception{\&assertion} \textit{or} +nan.0
(/ 0 3.5)                              \ev  0.0 ; inexact
(/ 0 0.0)                              \ev  +nan.0
(/ 0.0 0)                              \ev  +nan.0
(/ 0.0 0.0)                            \ev  +nan.0%
\end{scheme}

If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either raise an exception with
condition type {\cf\&implementation-restriction} or return an
unspecified number.
\end{entry}

\begin{entry}{%
\proto{abs}{ x}{procedure}}

Returns the absolute value of its argument.

\begin{scheme}
(abs -7)                               \ev  7
(abs -inf.0)                           \ev  +inf.0%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{div-and-mod}{ \vari{x} \varii{x}}{procedure}
\proto{div}{ \vari{x} \varii{x}}{procedure}
\proto{mod}{ \vari{x} \varii{x}}{procedure}
\proto{div0-and-mod0}{ \vari{x} \varii{x}}{procedure}
\proto{div0}{ \vari{x} \varii{x}}{procedure}
\proto{mod0}{ \vari{x} \varii{x}}{procedure}}

These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in section~\ref{integerdivision}.  In each case, \vari{x}
must be neither infinite nor a NaN, and \varii{x} must be nonzero;
otherwise, an exception with condition type {\cf\&assertion} is raised.

\begin{scheme}
(div \vari{x} \varii{x})         \ev \(\vari{x}~\mathrm{div}~\varii{x}\)
(mod \vari{x} \varii{x})         \ev \(\vari{x}~\mathrm{mod}~\varii{x}\)
(div-and-mod \vari{x} \varii{x})     \ev \(\vari{x}~\mathrm{div}~\varii{x}, \vari{x}~\mathrm{mod}~\varii{x}\)\\\>\>\>; two return values
(div0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{div}_0~\varii{x}\)
(mod0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{mod}_0~\varii{x}\)
(div0-and-mod0 \vari{x} \varii{x})   \lev \(\vari{x}~\mathrm{div}_0~\varii{x}, \vari{x}~\mathrm{mod}_0~\varii{x}\)\\\>\>; two return values%
\end{scheme}

\begin{entry}{%
\proto{gcd}{ \vari{n} \dotsfoo}{procedure}
\proto{lcm}{ \vari{n} \dotsfoo}{procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.

\begin{scheme}
(gcd 32 -36)                           \ev  4
(gcd)                                  \ev  0
(lcm 32 -36)                           \ev  288
(lcm 32.0 -36)                         \ev  288.0 ; inexact
(lcm)                                  \ev  1%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{numerator}{ q}{procedure}
\proto{denominator}{ q}{procedure}}

These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of $0$ is defined to be $1$.

\begin{scheme}
(numerator (/ 6 4))                    \ev  3
(denominator (/ 6 4))                  \ev  2
(denominator
 (->inexact (/ 6 4)))                  \ev  2.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}}

These procedures return inexact integers on inexact arguments that are
not infinities or NaNs, and exact integers on exact rational
arguments.  For such arguments, {\cf floor} returns the largest
integer not larger than \var{x}.  The {\cf ceiling} procedure returns the smallest
integer not smaller than \var{x}.  The {\cf truncate} procedure returns the integer
closest to \var{x} whose absolute value is not larger than the
absolute value of \var{x}.  The {\cf round} procedure returns the closest integer to
\var{x}, rounding to even when \var{x} is halfway between two
integers.

\begin{rationale}
The {\cf round} procedure rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

\begin{note}
If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the
result should be passed to the {\cf ->exact} procedure.
\end{note}

Although infinities and NaNs are not integers, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN.

\begin{scheme}
(floor -4.3)                           \ev  -5.0
(ceiling -4.3)                         \ev  -4.0
(truncate -4.3)                        \ev  -4.0
(round -4.3)                           \ev  -4.0

(floor 3.5)                            \ev  3.0
(ceiling 3.5)                          \ev  4.0
(truncate 3.5)                         \ev  3.0
(round 3.5)                            \ev  4.0  ; inexact

(round 7/2)                            \ev  4    ; exact
(round 7)                              \ev  7

(floor +inf.0)                         \ev  +inf.0
(ceiling -inf.0)                       \ev  -inf.0
(round +nan.0)                         \ev  +nan.0%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ \vari{x} \varii{x}}{procedure}}

The {\cf rationalize} procedure returns the {\em simplest} rational number
differing from \vari{x} by no more than \varii{x}.    A rational number $r_1$ is
{\em simpler} \mainindex{simplest rational} than another rational number
$r_2$ if $r_1 = p_1/q_1$ and $r_2 = p_2/q_2$ (in lowest terms) and $|p_1|
\leq |p_2|$ and $|q_1| \leq |q_2|$.  Thus $3/5$ is simpler than $4/7$.
Although not all rationals are comparable in this ordering (consider $2/7$
and $3/5$) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler $2/5$ lies
between $2/7$ and $3/5$).  Note that $0 = 0/1$ is the simplest rational of
all.

\begin{scheme}
(rationalize
  (->exact .3) 1/10)                   \ev 1/3    ; exact
(rationalize .3 1/10)                  \ev \sharpsign{}i1/3  ; inexact

(rationalize +inf.0 3)                 \ev  +inf.0
(rationalize +inf.0 +inf.0)            \ev  +nan.0
(rationalize 3 +inf.0)                 \ev  0.0%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ z}{procedure}
\proto{log}{ z}{procedure}
\rproto{log}{ \vari{z} \varii{z}}{procedure}
\proto{sin}{ z}{procedure}
\proto{cos}{ z}{procedure}
\proto{tan}{ z}{procedure}
\proto{asin}{ z}{procedure}
\proto{acos}{ z}{procedure}
\proto{atan}{ z}{procedure}
\rproto{atan}{ \vari{x} \varii{x}}{procedure}}

These procedures compute the usual transcendental functions.  The {\cf
  exp} procedure computes the base-$e$ exponential of \var{z}. 
The {\cf log} procedure with a single argument computes the natural logarithm of
\var{z} (not the base ten logarithm); {\cf (log \vari{z}
  \varii{z})} computes the base-\varii{z} logarithm of \vari{z}.
The {\cf asin}, {\cf acos}, and {\cf atan} procedures compute arcsine,
arccosine, and arctangent, respectively.  The two-argument variant of
{\cf atan} computes {\cf (angle (make-rectangular \varii{x}
\vari{x}))}.

See section~\ref{transcendentalfunctions} for the underlying
mathematical operations. These procedures may return inexact results
even when given exact arguments.

\begin{scheme}
(exp +inf.0)                   \ev +inf.0
(exp -inf.0)                   \ev 0.0
(log +inf.0)                   \ev +inf.0
(log 0.0)                      \ev -inf.0
(log 0)                        \lev \exception{\&assertion}
(log -inf.0)                   \ev +inf.0+\(\pi\)i
(atan -inf.0)                  \lev -1.5707963267948965 ; approximately
(atan +inf.0)                  \lev 1.5707963267948965 ; approximately
(log -1.0+0.0i)                \ev 0.0+\(\pi\)i
(log -1.0-0.0i)                \ev 0.0-\(\pi\)i\\\>; if -0.0 is distinguished%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{sqrt}{ z}{procedure}}

Returns the principal square root of \var{z}.  For rational \var{z},
the result has either positive real part, or zero real part and
non-negative imaginary part.  With $\log$ defined as in
section~\ref{transcendentalfunctions}, the value of {\cf (sqrt
  \var{z})} could be expressed as
%
\begin{displaymath}
e^{\frac{\log \var{z}}{2}}.
\end{displaymath}

The {\cf sqrt} procedure may return an inexact result even when given an exact
argument.

\begin{scheme}
(sqrt -5)                   \lev  0.0+2.23606797749979i ; approximately
(sqrt +inf.0)               \ev  +inf.0
(sqrt -inf.0)               \ev  +inf.0i%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{procedure}}

The {\cf exact-integer-sqrt} procedure returns two non-negative exact
integers $s$ and $r$ where $\var{ei} = s^2 +
r$ and $\var{ei} < (s+1)^2$.
\end{entry}

\begin{entry}{%
\proto{expt}{ \vari{z} \varii{z}}{procedure}}

Returns \vari{z} raised to the power \varii{z}.  For nonzero \vari{z},
%
\begin{displaymath}
  \vari{z}^{\varii{z}} = e^{\varii{z} \log \vari{z}}
\end{displaymath}

$0.0^{\var{z}}$ is $1.0$ if $\var{z} = 0.0$, and $0.0$ if {\cf
  (real-part \var{z})} is positive.  For other cases in which
the first argument is zero, an exception is raised with
condition type {\cf\&implementation-restriction} or an unspecified
number is returned.

For an exact real \vari{z} and an exact
integer \varii{z}, {\cf (expt \vari{z}
\varii{z})} must return an exact result.  For all other
values of \vari{z} and \varii{z}, {\cf (expt \vari{z}
\varii{z})} may return an inexact result, even when both
\vari{z} and \varii{z} are exact.

\begin{scheme}
(expt 5 3)                  \ev  125
(expt 5 -3)                 \ev  1/125
(expt 5 0)                  \ev  1
(expt 0 5)                  \ev  0
(expt 0 5+.0000312i)        \ev  0
(expt 0 -5)                 \ev  \unspecified
(expt 0 -5+.0000312i)       \ev  \unspecified
(expt 0 0)                  \ev  1
(expt 0.0 0.0)              \ev  1.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{make-rectangular}{ \vari{x} \varii{x}}{procedure}
\proto{make-polar}{ \variii{x} \variv{x}}{procedure}
\proto{real-part}{ z}{procedure}
\proto{imag-part}{ z}{procedure}
\proto{magnitude}{ z}{procedure}
\proto{angle}{ z}{procedure}}

Suppose \vari{x}, \varii{x}, \variii{x}, and \variv{x} are real
numbers and \var{z} is a complex number such that
%
\begin{displaymath}
\var{z} = \vari{x} + \varii{x}i = \variii{x} e^{i\variv{x}}.
\end{displaymath}

Then:
%
\begin{scheme}
(make-rectangular \vari{x} \varii{x}) \ev \var{z}
(make-polar \variii{x} \variv{x}) \ev \var{z}
(real-part \var{z})              \ev \vari{x}
(imag-part \var{z})              \ev \varii{x}
(magnitude \var{z})              \ev |\variii{x}|
(angle \var{z})                  \ev \var{x}\(_{\mathrm{angle}}\)%
\end{scheme}
%
where $-\pi \leq \var{x}_{\mathrm{angle}} \leq \pi$ with
$\var{x}_{\mathrm{angle}} = \variv{x} + 2\pi n$ for
some integer $n$.

\begin{scheme}
(angle -1.0)         \ev \(\pi\)
(angle -1.0+0.0)     \ev \(\pi\)
(angle -1.0-0.0)     \ev -\(\pi\)\\\>; if -0.0 is distinguished%
\end{scheme}

Moreover, suppose \vari{x}, \varii{x} are such that either \vari{x}
or \varii{x} is an infinity, then
%
\begin{scheme}
(make-rectangular \vari{x} \varii{x}) \ev \var{z}
(magnitude \var{z})              \ev +inf.0%
\end{scheme}
\end{entry}

The {\cf make-polar}, {\cf magnitude}, and
{\cf angle} procedures may return inexact results even when given exact
arguments.

\begin{scheme}
(angle -1)                    \ev \(\pi\)
(angle +inf.0)                \ev 0.0
(angle -inf.0)                \ev \(\pi\)
(angle -1.0+0.0)              \ev \(\pi\)
(angle -1.0-0.0)              \ev \(-\pi\)\\\>; if -0.0 is distinguished%
\end{scheme}
\end{entry}

\subsubsection{Numerical Input and Output}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}
\rproto{number->string}{ z radix precision}{procedure}}

\var{Radix} must be an exact integer, either 2, 8, 10, or 16.  If
omitted, \var{radix} defaults to 10.  If a \var{precision} is
specified, then \var{z} must be an inexact complex number,
\var{precision} must be an exact positive integer, and \var{radix}
must be 10.  The {\cf number->string} procedure takes a number and a
radix and returns as a string an external representation of the given
number in the given radix such that
%
\begin{scheme}
(let ((number \var{number})
      (radix \var{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))%
\end{scheme}
%
is true.  If no possible result makes this expression
true, an exception with condition type
{\cf\&implementation-restriction} is raised.

If a \var{precision} is specified, then the representations of the
inexact real components of the result, unless they are infinite or
NaN, specify an explicit \meta{mantissa width} \var{p}, and \var{p} is the
least $\var{p} \geq \var{precision}$ for which the above expression is
true.

If \var{z} is inexact, the radix is 10, and the above expression and
condition can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent, trailing zeroes, and
mantissa width) needed to make the above expression and condition
true~\cite{howtoprint,howtoread}; otherwise the format of the result
is unspecified.

The result returned by {\cf number->string} never contains an explicit
radix prefix.

\begin{note}
The error case can occur only when \var{z} is not a complex number
or is a complex number with a non-rational real or imaginary part.
\end{note}

\begin{rationale}
If \var{z} is an inexact number represented using binary floating
point, and the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and representations other than binary
floating point.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}

Returns a number of the maximally precise representation expressed by the
given \var{string}.  \var{Radix} must be an exact integer, either 2, 8, 10,
or 16.  If supplied, \var{radix} is a default radix that may be overridden
by an explicit radix prefix in \var{string} (e.g. {\tt "\#o177"}).  If \var{radix}
is not supplied, then the default radix is 10.  If \var{string} is not
a syntactically valid notation for a number, then {\cf string->number}
returns \schfalse{}.
%
\begin{scheme}
(string->number "100")                 \ev  100
(string->number "100" 16)              \ev  256
(string->number "1e2")                 \ev  100.0
(string->number "15\sharpsign\sharpsign")                \ev  1500.0
(string->number "+inf.0")              \ev  +inf.0
(string->number "-inf.0")              \ev  -inf.0
(string->number "+nan.0")              \ev  +nan.0%
\end{scheme}
\end{entry}


\section{Booleans}
\label{booleansection}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f} However, of all
the standard Scheme values, only \schfalse{} counts as false in
conditional expressions.  See section~\ref{booleanvaluessection}.

\begin{note}
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both \schfalse{} and the empty list \index{empty list}
from the symbol \ide{nil}.
\end{note}

\begin{entry}{%
\proto{not}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is false, and returns
\schfalse{} otherwise.

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is either \schtrue{} or
\schfalse{} and returns \schfalse{} otherwise.

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

 
\section{Pairs and lists}
\label{listsection}

A \defining{pair} (sometimes called a \defining{dotted pair}) is a
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure {\cf cons}.
The car and cdr fields are accessed by the procedures {\cf car} and
{\cf cdr}.

Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list\index{empty list} or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set \var{X} such that

\begin{itemize}
\item The empty list is in \var{X}.
\item If \var{list} is in \var{X}, then any pair whose cdr field contains
      \var{list} is also in \var{X}.
\end{itemize}

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

The empty list\mainindex{empty list} is a special object of its own type.
It is not a pair.  It has no elements and its length is zero.

\begin{note}
The above definitions imply that all lists have finite length and are
terminated by the empty list.
\end{note}

A chain of pairs not ending in the empty list is called an
\defining{improper list}.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

\begin{scheme}
(a b c . d)%
\end{scheme}

is equivalent to

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

Whether a given pair is a list depends upon what is stored in the cdr
field.

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a pair, and otherwise
returns \schfalse.

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

Returns a newly allocated pair whose car is \vari{obj} and whose cdr is
\varii{obj}.  The pair is guaranteed to be different (in the sense of
{\cf eqv?}) from every existing object.

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

Returns the contents of the car field of \var{pair}.

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \exception{\&assertion}%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

Returns the contents of the cdr field of \var{pair}.

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \exception{\&assertion}%
\end{scheme}
 
\end{entry}



\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{procedure}


\begin{entry}{%
\proto{caar}{ pair}{procedure}
\proto{cadr}{ pair}{procedure}
\texonly
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}
\endtexonly
\htmlonly $\vdots$ \endhtmlonly
\proto{cdddar}{ pair}{procedure}
\proto{cddddr}{ pair}{procedure}}

These procedures are compositions of {\cf car} and {\cf cdr}, where
for example {\cf caddr} could be defined by

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is the empty list\index{empty list}.
Otherwise, returns \schfalse.

\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a list.  Otherwise, returns \schfalse{}.
By definition, all lists are chains of pairs that have finite length and are terminated by
the empty list.

\begin{scheme}
(list? '(a b c))     \ev  \schtrue
(list? '())          \ev  \schtrue
(list? '(a . b))     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{procedure}}

Returns a newly allocated list of its arguments.

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{procedure}}

\nodomain{\var{List} must be a list.}
Returns the length of \var{list}.

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo{} obj}{procedure}}

\nodomain{All \var{list}s must be lists.}
Returns a possibly improper list consisting of the elements of the first \var{list}
followed by the elements of the other \var{list}s, with \var{obj} as
the cdr of the final pair.
An improper list results if \var{obj} is not a
proper list.

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}

The resulting chain of pairs is always newly allocated, except that it shares
structure with the \var{obj} argument.
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{procedure}}

\nodomain{\var{List} must be a list.}
Returns a newly allocated list consisting of the elements of \var{list}
in reverse order.

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list k}{procedure}}

\domain{\var{List} must be a list of size at least \var{k}.}

The {\cf list-tail} procedure returns the subchain of pairs of \var{list}
obtained by omitting the first \var{k} elements.

\begin{scheme}
(list-tail '(a b c d) 2)                 \ev  (c d)%
\end{scheme}

\implresp The implementation must check that \var{list} is a chain of
pairs of size at least \var{k}.  It should not check that it is a chain
of pairs beyond this size.

{\cf List-tail} could be defined by

\begin{scheme}
(define (list-tail l k)
  (if (and (not (null? l))
           (not (pair? l)))
      (assertion-violation
       'list-tail
       "not a list"
       l))
  (if (or (not (exact? k))
          (not (integer? k))
          (negative? k))
      (assertion-violation
       'list-tail
       "not an exact non-negative integer"
       l))
  
  (let loop ((l l) (k k))
    (if (zero? k)
        l
        (loop (cdr l) (- k 1)))))%
\end{scheme} 

\end{entry}


\begin{entry}{%
\proto{list-ref}{ list k}{procedure}}

\domain{\var{List} must be a list of size at least $\var{k}+1$.}

Returns the \var{k}th element of \var{list}.

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev c%
\end{scheme}

\implresp The implementation must check that \var{list} is a chain of
pairs of size at least $\var{k}+1$.  It should not check that it is a list
of pairs beyond this size.
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s must all have the same length.  \var{Proc}
  must be a procedure that takes as many arguments as there are
  \var{list}s and returns a single value.  \var{Proc} must not mutate
  any of the \var{list}s.}

The {\cf map} procedure applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.
\var{Proc} is always called in same dynamic environment 
as {\cf map} itself.
The dynamic order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)%
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s must all have the same length.  \var{Proc}
  must be a procedure that takes as many arguments as there are
  \var{list}s.  \var{Proc} must not mutate
  any of the \var{list}s.}

The {\cf for-each} procedure applies \var{proc}
element-wise to the elements of the
\var{list}s for its side effects,  in order from the first element(s) to the
last.
\var{Proc} is always called in same dynamic environment 
as {\cf for-each} itself.
The return values of {\cf for-each} are 
unspecified.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)

(for-each (lambda (x) x) '(1 2 3 4)) \lev 4

(for-each even? '()) \ev \theunspecified%
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.

\begin{rationale}
  The return values are unspecified to allow implementations of {\cf
    for-each} to tail-call \var{proc} on the last element(s).
\end{rationale}

\end{entry}


\section{Symbols}
\label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eq?}, {\cf eqv?} and {\cf equal?}) if and only if their
names are spelled the same way.  This is exactly the property needed to
represent identifiers\index{identifier} in programs, and so most
implementations of Scheme use them internally for that purpose.  Symbols
are useful for many other applications; for instance, they may be used
the way enumerated values are used in C and Pascal.

A symbol literal is formed using {\cf quote}.

\begin{scheme}
Hello \ev Hello
'H\backwhack{}x65;llo \ev Hello
'$\lambda$ \ev $\lambda$
'\backwhack{}x3BB; \ev $\lambda$
(string->symbol "a b") \ev a\backwhack{}x20;b
(string->symbol "a\backwhack{}\backwhack{}b") \ev a\backwhack{}x5C;b
'a\backwhack{}x20;b \ev a\backwhack{}x20;b
'|a b| \>; \emph{syntax violation}
\>; \textrm{(illegal character}
\>; \textrm{vertical bar)}
'a\backwhack{}nb  \>; \emph{syntax violation}
\>; \textrm{(illegal use of backslash)}
'a\backwhack{}x20 \>; \emph{syntax violation}
\>; \textrm{(missing semi-colon to}
\>; \textrm{terminate \backwhack{}x escape)}%
\end{scheme}

\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as a string.  
The returned string may be immutable.

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}. 

\begin{scheme}
(eq? 'mISSISSIppi 'mississippi)  \lev  \schfalse
(string->symbol "mISSISSIppi")  \lev%
  {\rm{}the symbol with name} "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{Characters}
\label{charactersection}

\mainindex{Unicode}
\mainindex{scalar value}

\defining{Characters} are objects that represent Unicode scalar
values~\cite{Unicode}.

\begin{note}
  Unicode defines a standard mapping between sequences of {\em code
  points}\mainindex{code point} (integers in the range 0 to \#x10FFFF
  in the latest version of the standard) and human-readable
  ``characters''. More precisely, Unicode distinguishes between
  glyphs, which are printed for humans to read, and characters, which
  are abstract entities that map to glyphs (sometimes in a way that's
  sensitive to surrounding characters).  Furthermore, different
  sequences of code points sometimes correspond to the same character.
  The relationships among code points, characters, and glyphs are
  subtle and complex.

  Despite this complexity, most things that a literate human would
  call a ``character'' can be represented by a single code point in
  Unicode (though there may exist code-point sequences that represent
  that same character). For example, Roman letters, Cyrillic letters,
  Hebrew consonants, and most Chinese characters fall into this
  category. Thus, the ``code point'' approximation of ``character''
  works well for many purposes. More specifically, Scheme characters
  correspond to Unicode {\em scalar values}\mainindex{scalar
    value}, which includes all code points except those designated as
  surrogates. A \defining{surrogate} is a code point in the range
  \#xD800 to \#xDFFF that is used in pairs in the UTF-16 encoding to
  encode a supplementary character (whose code is in the range
  \#x10000 to \#x10FFFF).
\end{note}

\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}

\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{sv}}{procedure}}

\domain{\var{Sv} must be a Unicode scalar value, i.e.\ a non-negative exact
  integer in $\left[0, \#x\textrm{D7FF}\right] \cup
  \left[\#x\textrm{E000}, \#x\textrm{10FFFF}\right]$.}

Given a character, {\cf char\coerce{}integer} returns its Unicode scalar value
as an exact integer.  
For a Unicode scalar value \var{sv}, {\cf integer\coerce{}char}
returns its associated character.

\begin{scheme}
(integer->char 32) \ev \sharpsign\backwhack{}space
(char->integer (integer->char 5000))
\ev 5000
(integer->char \sharpsign{}xD800) \ev \exception{\&assertion}%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}}

\label{characterequality}
These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.

\begin{scheme}
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}\ss) \ev \schtrue
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse%
\end{scheme}

\end{entry}

\section{Strings}
\label{stringsection}

Strings are sequences of characters.  

\vest The {\em length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed when the
string is created.  The \defining{valid indexes} of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

\vest In phrases such as ``the characters of \var{string} beginning with
index \var{start} and ending with index \var{end}'', it is understood
that the index \var{start} is inclusive and the index \var{end} is
exclusive.  Thus if \var{start} and \var{end} are the same index, a null
substring is referred to, and if \var{start} is zero and \var{end} is
the length of \var{string}, then the entire string is referred to.

\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ k}{procedure}
\rproto{make-string}{ k char}{procedure}}

Returns a newly allocated string of
length \var{k}.  If \var{char} is given, then all elements of the string
are initialized to \var{char}, otherwise the contents of the
\var{string} are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{procedure}}

Returns a newly allocated string composed of the arguments.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string}.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string k}{procedure}}

\domain{\var{K} must be a valid index of \var{string}.}
The {\cf string-ref} procedure returns character \vr{k} of \var{string} using zero-origin indexing.
\end{entry}


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{%\var{string} must be a string, 
\vr{k} must be a valid index of \var{string}%, and \var{char} must be a character
.}
The {\cf string-set!} procedure stores \var{char} in element \vr{k} of \var{string}
and returns the unspecified value.  % <!>

Passing an immutable string to {\cf string-set!} should cause an exception
with condition type {\cf\&assertion} to be raised.
\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \theunspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
             ; \textrm{should raise \exception{\&assertion}}
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \unspecified
             ; \textrm{should raise \exception{\&assertion}}%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}}

Returns \schtrue{} if the strings are the same length and contain the same
characters in the same positions.  Otherwise, returns \schfalse.

\begin{scheme}
(string=? "Stra\ss{}e" "Strasse") \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string<?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string>?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string<=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string>=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}}

These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, {\cf string<?}\ is
the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters.  If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.

\begin{scheme}
(string<? "z" "\ss") \ev \schtrue
(string<? "z" "zz") \ev \schtrue
(string<? "z" "Z") \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{procedure}}

\domain{\var{String} must be a string, and \var{start} and \var{end}
must be exact integers satisfying
$$0 \leq \var{start} \leq \var{end} \leq \hbox{\tt(string-length \var{string})\rm.}$$}
The {\cf substring} procedure returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} (inclusive) and ending with index
\var{end} (exclusive).
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{procedure}}

Returns a newly allocated string whose characters form the concatenation of the
given strings.

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{procedure}
\proto{list->string}{ list}{procedure}}

\domain{\var{List} must be a list of characters.}
The {\cf string\coerce{}list} procedure returns a newly allocated list of the
characters that make up the given string.  The {\cf
  list\coerce{}string} procedure
returns a newly allocated string formed from the characters in 
\var{list}. The {\cf string\coerce{}list}
and {\cf list\coerce{}string} procedures are
inverses so far as {\cf equal?}\ is concerned.  
\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{procedure}}

Returns a newly allocated copy of the given \var{string}.

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string char}{procedure}}

Stores \var{char} in every element of the given \var{string} and returns the
unspecified value.  % <!>

\end{entry}

\section{Vectors}
\label{vectorsection}

Vectors are heterogeneous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time required to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The {\em valid indexes}\index{valid indexes} of a
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Like list constants, vector constants must be quoted:

\begin{scheme}
'\#(0 (2 2 2 2) "Anna")  \lev  \#(0 (2 2 2 2) "Anna")%
\end{scheme}

\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector.  Otherwise, returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\var{K} must be a valid index of \var{vector}.}
The {\cf vector-ref} procedure returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (->exact (round (* 2 (acos -1))))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\var{K} must be a valid index of \var{vector}.}
The {\cf vector-set!} procedure stores \var{obj} in element \vr{k} of \var{vector}.
The value returned by {\cf vector-set!}\ is the unspecified value.  % <!>

Passing an immutable vector to {\cf vector-set!} should cause an exception
with condition type {\cf\&assertion} to be raised.

\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \unspecified
             ; constant vector
             ; may raise \exception{\&assertion}%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{procedure}
\proto{list->vector}{ list}{procedure}}

The {\cf vector->list} procedure returns a newly allocated list of the objects contained
in the elements of \var{vector}.  The {\cf list->vector} procedure returns a newly
created vector initialized to the elements of the list \var{list}.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-fill!}{ vector fill}{procedure}}

Stores \var{fill} in every element of \var{vector}
and returns the unspecified value.  % <!>

\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{The \var{vector}s must all have the same length.  \var{Proc}
  must be a procedure.  If the \var{vector}s are non-empty,
  \var{proc} must
  take as many arguments as there are {\it vector}s and must return a
  single value.}

The {\cf vector-map} procedure applies \var{proc} element-wise to the elements of the
\var{vector}s and returns a vector of the results, in order.
\var{Proc} is always called in same dynamic environment 
as {\cf vector-map} itself.
The dynamic order in which \var{proc} is applied to the elements of the
\var{vector}s is unspecified.

Analogous to {\cf map}.
\end{entry}


\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{The \var{vector}s must all have the same length.  \var{Proc}
  must be a procedure.  If the \var{vector}s are non-empty,
  \var{proc} must
  take as many arguments as there are {\it vector}s.}
The {\cf vector-for-each} procedure applies \var{proc}
element-wise to the elements of the
\var{vector}s for its side effects,  in order from the first element(s) to the
last.
\var{Proc} is always called in same dynamic environment 
as {\cf vector-for-each} itself.
The return values of {\cf vector-for-each} are 
unspecified.

Analogous to {\cf for-each}.
\end{entry}

\section{Errors and violations}
\label{errorviolation}

\begin{entry}{%
\proto{error}{ who message \vari{irritant} \dotsfoo}{procedure}
\proto{assertion-violation}{ who message \vari{irritant} \dotsfoo}{procedure}}

\domain{\var{Who} must be a string or a symbol or \schfalse{}.
  \var{message} must be a string.
  The \var{irritant}s are arbitrary objects.}

These procedures raise an exception.  Calling the {\cf error}
procedure means that an error has occurred, typically caused by
something that has gone wrong in the interaction of the program with the
external world or the user.  Calling the {\cf assertion-violation} procedure
means that an invalid call to a procedure was made, either passing an
invalid number of arguments, or passing an argument that it is not
specified to handle.

The \var{who} argument should describe the procedure or operation that
detected the exception.  The \var{message} argument should describe
the exceptional situation.  The \var{irritant}s should be the arguments
to the operation that detected the operation.

The condition object provided with the exception (see
library chapter~\extref{lib:exceptionsconditionschapter}{Exceptions
  and conditions}) has the following condition types:
%
\begin{itemize}
\item If \var{who} is not \schfalse, the condition has condition type
  {\cf \&who}, with \var{who} as the value of the {\cf who} field.  In
  that case, \var{who} should identify the procedure or entity that
  detected the exception.  If it is \schfalse, the condition does not
  have condition type {\cf \&who}.
\item The condition has condition type {\cf \&message}, with
  \var{message} as the value of the {\cf message} field.
\item The condition has condition type {\cf \&irritants}, and the {\cf
    irritants} field has as its value a list of the \var{irritant}s.
\end{itemize}
%
Moreover, the condition created by {\cf error} has condition type 
{\cf \&error}, and the condition created by {\cf assertion-violation} has
condition type {\cf \&assertion}.

\begin{scheme}
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5) \ev 120
(fac 4.5) \ev \exception{\&assertion}
(fac -3) \ev \exception{\&assertion}%
\end{scheme}

\begin{rationale}
  The procedures encode a common pattern of raising exceptions.
\end{rationale}
\end{entry}

\section{Control features}
\label{controlsection}
\label{valuessection}
 
This chapter describes various primitive procedures which control the
flow of program execution in special ways.

\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

\domain{\var{Proc} must be a procedure and \var{args} must be a
  list.}
Calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{args})} as the actual
arguments.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}
\proto{call/cc}{ proc}{procedure}}

\label{continuations} \domain{\var{Proc} must be a procedure of one
argument.} The procedure {\cf call-with-current-continuation} 
(which is the same as the procedure {\cf call/cc}) packages
the current continuation (see the rationale below) as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead use the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of \var{before} and \var{after} thunks installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation of the original call to \callcc.

\vest The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

\vest The following examples show only the most common ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-with-current-continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%

(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\begin{rationale}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is useful for implementing a
wide variety of advanced control structures.

\vest Whenever a Scheme expression is evaluated there is a
\defining{continuation} wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.
Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and store
the result in some other variable.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers do not
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
The {\cf call-with-current-continuation} procedure allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.

\vest Most programming languages incorporate one or more special-purpose
escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
invented a general purpose escape operator called the J-operator.  John
Reynolds~\cite{Reynolds72} described a simpler but equally powerful
construct in 1972.  The {\cf catch} special form described by Sussman
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
\ide{catch} construct could be provided by a procedure instead of by a
special syntactic construct, and the name
{\cf call-with-current-continuation} was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name \ide{call/cc} instead.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

Delivers all of its arguments to its continuation.
The {\cf values} procedure might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))%
\end{scheme}

The continuations of all non-final expressions within a sequence of
expressions in {\cf lambda}, {\cf begin}, {\cf let}, {\cf let*}, {\cf
  letrec}, {\cf letrec*}, {\cf let-values}, {\cf let*-values}, {\cf
  case}, {\cf cond}, and {\cf do} forms as well as the continuations
of the \var{before} and \var{after} arguments to {\cf dynamic-wind}
take an arbitrary number of values.

Except for these and the continuations created by {\cf
  call-with-values}, {\cf let-values}, and {\cf let*-values}, all
other continuations take exactly one value.  The effect of passing an
inappropriate number of values to a continuation not created by {\cf
  call-with-values}, {\cf let-values}, or {\cf let*-values} is
undefined.
\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

\domain{\var{Producer} must be a procedure that takes zero
  arguments.  \var{Consumer} must be a procedure that accepts as many
  values as \var{producer} returns.}
Calls \var{producer} with no arguments and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1%
\end{scheme}

\implresp After \var{producer} returns, the implementation must check
that \var{consumer} accepts as many values as \var{consumer} has
returned.
\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

\domain{\var{Before}, \var{thunk}, and \var{after} must be procedures
accepting zero arguments and returning any number of values.}

In the absence of any calls to escape procedures
(see \ide{call-with-current-continuation}),
{\cf dynamic-wind} behaves as if defined as follows.

\begin{scheme}
(define dynamic-wind
  (lambda (before thunk after)
    (before)
    (call-with-values
      (lambda () (thunk))
      (lambda vals
        (after)
        (apply values vals)))))%
\end{scheme}

That is, \var{before} is called without arguments.
If \var{before} returns, \var{thunk} is called without arguments.
If \var{thunk} returns, \var{after} is called without arguments.
Finally, if \var{after} returns, the values resulting from the
call to \var{thunk} are returned.

\implresp The implementation must check the restrictions on
\var{thunk} and \var{after} only if they are actually called.

Invoking an escape procedure to transfer control into or out of the
dynamic extent of the call to \var{thunk} can cause additional calls to
\var{before} and \var{after}.
When an escape procedure created outside the dynamic extent of the call to
\var{thunk} is invoked from within the dynamic extent, \var{after} is
called just after control leaves the dynamic extent.
Similarly, when an escape procedure created within the dynamic extent of
the call to \var{thunk} is invoked from outside the dynamic extent,
\var{before} is called just before control reenters the dynamic extent.
In the latter case, if \var{thunk} returns, \var{after} is called even
if \var{thunk} has returned previously.
While the calls to \var{before} and \var{after} are not considered to be
within the dynamic extent of the call to \var{thunk}, calls to the before
and after thunks of any other calls to {\cf dynamic-wind} that occur
within the dynamic extent of the call to \var{thunk} are considered to be
within the dynamic extent of the call to \var{thunk}.

More precisely, an escape procedure used to transfer control out of the
dynamic extent of a set of zero or more active {\cf dynamic-wind}
\var{thunk} calls $x\ \dots$ and transfer control into the dynamic extent
of a set of zero or more active {\cf dynamic-wind} \var{thunk} calls
$y\ \dots$ proceeds as follows.
It leaves the dynamic extent of the most recent $x$ and calls without
arguments the corresponding \var{after} thunk.
If the \var{after} thunk returns, the escape procedure proceeds to
the next most recent $x$, and so on.
Once each $x$ has been handled in this manner,
the escape procedure calls without arguments the \var{before} thunk
corresponding to the least recent $y$.
If the \var{before} thunk returns, the escape procedure reenters the
dynamic extent of the least recent $y$ and proceeds with the next least
recent $y$, and so on.
Once each $y$ has been handled in this manner, control is transfered to
the continuation packaged in the escape procedure.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        (lambda ()
          (set! n (+ n 1))
          (k))
        (lambda ()
          (set! n (+ n 2)))
        (lambda ()
          (set! n (+ n 4))))))
  n) \ev 1

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        values
        (lambda ()
          (dynamic-wind
            values
            (lambda ()
              (set! n (+ n 1))
              (k))
            (lambda ()
              (set! n (+ n 2))
              (k))))
        (lambda ()
          (set! n (+ n 4))))))
  n) \ev 7%
\end{scheme}
\end{entry}

\section{Iteration}%\unsection

\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{\exprtype}}

\label{namedlet}
``Named {\cf let}'' is a variant on the syntax of \ide{let} which provides
a more general looping construct than {\cf do} and may also be used to express
recursions.
It has the same syntax and semantics as ordinary {\cf let}
except that \hyper{variable} is bound within \hyper{body} to a procedure
whose formal arguments are the bound variables and whose body is
\hyper{body}.  Thus the execution of \hyper{body} may be repeated by
invoking the procedure named by \hyper{variable}.

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

The {\cf let} keyword could be defined in terms of {\cf lambda} and {\cf letrec}
using {\cf syntax-rules} (see section~\ref{syntaxrulessection}) as
follows:

\begin{scheme}
(define-syntax \ide{let}
  (syntax-rules ()
    ((let ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))
    ((let tag ((name val) ...) body1 body2 ...)
     ((letrec ((tag (lambda (name ...)
                      body1 body2 ...)))
        tag)
      val ...))))%
\end{scheme}

\end{entry}

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{\exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{expression} \dotsfoo)}

\syntax
The \hyper{init}s, \hyper{step}s, and \hyper{test}s must be
expressions.  The \hyper{variable}s must be pairwise distinct variables.

\semantics
The {\cf do} expression is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits after evaluating the \hyper{expression}s.

A {\cf do} expression is evaluated as follows:
The \hyper{init} expressions are evaluated (in some unspecified order),
the \hyper{variable}s are bound to fresh locations, the results of the
\hyper{init} expressions are stored in the bindings of the
\hyper{variable}s, and then the iteration phase begins.

\vest Each iteration begins by evaluating \hyper{test}; if the result is
false (see section~\ref{booleanvaluessection}), then the \hyper{expression}s
are evaluated in order for effect, the \hyper{step}
expressions are evaluated in some unspecified order, the
\hyper{variable}s are bound to fresh locations, the results of the
\hyper{step}s are stored in the bindings of the
\hyper{variable}s, and the next iteration begins.

\vest If \hyper{test} evaluates to a true value, then the
\hyper{expression}s are evaluated from left to right and the value(s) of
the last \hyper{expression} is(are) returned.  If no \hyper{expression}s
are present, then the value of the {\cf do} expression is the
unspecified value.

\vest The region\index{region} of the binding of a \hyper{variable}
consists of the entire {\cf do} expression except for the \hyper{init}s.
It is a syntax violation for a \hyper{variable} to appear more than once in the
list of {\cf do} variables.

\vest A \hyper{step} may be omitted, in which case the effect is the
same as if {\cf(\hyper{variable} \hyper{init} \hyper{variable})} had
been written instead of {\cf(\hyper{variable} \hyper{init})}.

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}

The following definition
of {\cf do} uses a trick to expand the variable clauses.

\begin{scheme}
(define-syntax \ide{do}
  (syntax-rules ()
    ((do ((var init step ...) ...)
         (test expr ...)
         command ...)
     (letrec
       ((loop
         (lambda (var ...)
           (if test
               (begin
                 (unspecified)
                 expr ...)
               (begin
                 command
                 ...
                 (loop (do "step" var step ...)
                       ...))))))
       (loop init ...)))
    ((do "step" x)
     x)
    ((do "step" x y)
     y)))%
\end{scheme}

%\end{entry}


\section{Quasiquotation}\unsection
\label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype}}

``Backquote'' or ``quasiquote''\index{backquote} expressions are useful
for constructing a list or vector structure when some but not all of the
desired structure is known in advance.  If no
{\cf unquote} or {\cf unquote-splicing} forms
appear within the \hyper{qq template}, the result of
evaluating
{\cf (quasiquote \hyper{qq template})} is equivalent to the result of evaluating
{\cf (quote \hyper{qq template})}.

If an {\cf (unquote \hyper{expression} \dotsfoo)} form appears inside a
\hyper{qq template}, however, the \hyper{expression}s are evaluated
(``unquoted'') and their results are inserted into the structure instead
of the {\cf unquote} form.

If an {\cf (unquote-splicing \hyper{expression} \dotsfoo)} form
appears inside a \hyper{qq template}, then the \hyper{expression}s must
evaluate to lists; the opening and closing parentheses of the lists are
then ``stripped away'' and the elements of the lists are inserted in
place of the {\cf unquote-splicing} form.

{\cf unquote-splicing} and multi-operand {\cf unquote} forms must
appear only within a list or vector \hyper{qq template}.

As noted in section~\ref{quotesection},
{\cf (quasiquote \hyper{qq template})} may be abbreviated
\backquote\hyper{qq template},
{\cf (unquote \hyper{expression})} may be abbreviated
{\cf,}\hyper{expression}, and
{\cf (unquote-splicing \hyper{expression})} may be abbreviated
{\cf,}\atsign\hyper{expression}.

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)
(let ((name 'foo))
  `((unquote name name name)))%
          \lev (foo foo foo)
(let ((name '(foo)))
  `((unquote-splicing name name name)))%
          \lev (foo foo foo)
(let ((q '((append x y) (sqrt 9))))
  ``(foo ,,@q)) \lev `(foo (unquote (append x y) (sqrt 9)))
(let ((x '(2 3))
      (y '(4 5)))
  `(foo (unquote (append x y) (sqrt 9)))) \lev (foo (2 3 4 5) 3)%
\end{scheme}

Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost {\cf quasiquote}.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

It is a syntax violation if any of the identifiers
\ide{quasiquote}, \ide{unquote}, or \ide{unquote-splicing} appear in
positions within a \hyper{qq template} otherwise than as described above.

The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for $D = 1, 2,
3, \ldots$.  $D$ keeps track of the nesting depth.

\begin{grammar}%
\meta{quasiquotation} \: \meta{quasiquotation 1}
\meta{qq template 0} \: \meta{expression}
\meta{quasiquotation $D$} \: (quasiquote \meta{qq template $D$})
\meta{qq template $D$} \: \meta{simple datum}
\>    \| \meta{list qq template $D$}
\>    \| \meta{vector qq template $D$}
\>    \| \meta{unquotation $D$}
\meta{list qq template $D$} \: (\arbno{\meta{qq template or splice $D$}})
\>    \| (\atleastone{\meta{qq template or splice $D$}} .\ \meta{qq template $D$})
\>    \| \meta{quasiquotation $D+1$}
\meta{vector qq template $D$} \: \#(\arbno{\meta{qq template or splice $D$}})
\meta{unquotation $D$} \: (unquote \meta{qq template $D-1$})
\meta{qq template or splice $D$} \: \meta{qq template $D$}
\>    \| \meta{splicing unquotation $D$}
\meta{splicing unquotation $D$} \:
\>\> (unquote-splicing \arbno{\meta{qq template $D-1$}})
\>    \| (unquote \arbno{\meta{qq template $D-1$}}) %
\end{grammar}

In \meta{quasiquotation}s, a \meta{list qq template $D$} can sometimes
be confused with either an \meta{un\-quota\-tion $D$} or a \meta{splicing
un\-quo\-ta\-tion $D$}.  The interpretation as an
\meta{un\-quo\-ta\-tion} or \meta{splicing
un\-quo\-ta\-tion $D$} takes precedence.

\end{entry}

\section{Binding constructs for syntactic keywords}
\label{bindsyntax}

The {\cf let-syntax} and {\cf letrec-syntax} forms are analogous to {\cf let}
and {\cf letrec} but bind keywords rather than variables.
Like a {\cf begin} form, a {\cf let-syntax} or {\cf letrec-syntax} form
may appear in a definition context, in which case it is treated as a
definition, and the forms in the body of the form must also be
definitions.
A {\cf let-syntax} or {\cf letrec-syntax} form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{form} \dotsfoo}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyper{keyword} \hyper{expression}) \dotsfoo)%
\end{scheme}
Each \hyper{keyword} is an identifier,
each \hyper{expression} is 
an expression that evaluates, at macro-expansion
time, to a transformer (see
library chapter~\extref{lib:syntaxcasechapter}{{\cf syntax-case}}).  It is a
syntax violation for \hyper{keyword} to appear more than once in the list of keywords
being bound.
The \hyper{form}s are arbitrary forms.

\semantics
The \hyper{form}s are expanded in the syntactic environment
obtained by extending the syntactic environment of the
{\cf let-syntax} form with macros whose keywords are
the \hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{form}s as its region.

The \hyper{form}s of a {\cf let-syntax}
form are treated, whether in definition or expression context, as if
wrapped in an implicit {\cf begin}.  See section~\ref{begin}.
Thus, internal definitions in the result of expanding the \hyper{form}s have
the same region as any definition appearing in place of the {\cf
  let-syntax} form would have.

\implresp The implementation must check that the value of each
\hyper{expression} is a transformer when the evaluation produces a
value.

\begin{scheme}
(let-syntax ((when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if \schtrue))
    (when if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%

(let ()
  (let-syntax
    ((def (syntax-rules ()
            ((def stuff ...) (define stuff ...)))))
    (def foo 42))
  foo) \ev 42

(let ()
  (let-syntax ())
  5) \ev 5%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{form} \dotsfoo}{\exprtype}}

\syntax
Same as for {\cf let-syntax}.

\semantics
The \hyper{form}s are
expanded in the syntactic environment obtained by
extending the syntactic environment of the {\cf letrec-syntax}
form with macros whose keywords are the
\hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{bindings}
as well as the \hyper{form}s within its region,
so the transformers can
transcribe forms into uses of the macros
introduced by the {\cf letrec-syntax} form.

The \hyper{form}s of a {\cf letrec-syntax}
form are treated, whether in definition or expression context, as if
wrapped in an implicit {\cf begin}, see section~\ref{begin}.
Thus, internal definitions in the result of expanding the \hyper{form}s have
the same region as any definition appearing in place of the {\cf
  letrec-syntax} form would have.

\implresp The implementation must check that the value of each
\hyper{expression} is a transformer when the evaluation produces a
value.

\begin{scheme}
(letrec-syntax
  ((my-or (syntax-rules ()
            ((my-or) \schfalse)
            ((my-or e) e)
            ((my-or e1 e2 ...)
             (let ((temp e1))
               (if temp
                   temp
                   (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

The following example highlights how {\cf let-syntax}
and {\cf letrec-syntax} differ.

\begin{scheme}
(let ((f (lambda (x) (+ x 1))))
  (let-syntax ((f (syntax-rules ()
                    ((f x) x)))
               (g (syntax-rules ()
                    ((g x) (f x)))))
    (list (f 1) (g 1)))) \lev (1 2)

(let ((f (lambda (x) (+ x 1))))
  (letrec-syntax ((f (syntax-rules ()
                       ((f x) x)))
                  (g (syntax-rules ()
                       ((g x) (f x)))))
    (list (f 1) (g 1)))) \lev (1 1)%
\end{scheme}

The two expressions are identical except that the {\cf let-syntax} form
in the first expression is a {\cf letrec-syntax} form in the second.
In the first expression, the {\cf f} occurring in {\cf g} refers to
the {\cf let}-bound variable {\cf f}, whereas in the second it refers
to the keyword {\cf f} whose binding is established by the
{\cf letrec-syntax} form.
\end{entry}

\section{Macro transformers}
\label{syntaxrulessection}

\begin{entry}{%
\pproto{(syntax-rules (\hyper{literal} \dots) \hyper{syntax rule} \dots)}{\exprtype~({\cf expand})}}
\mainschindex{syntax-rules}

\syntax Each \hyper{literal} must be an identifier.
Each \hyper{syntax rule} must have the following form:

\begin{scheme}
(\hyper{srpattern} \hyper{template})
\end{scheme}

An \hyper{srpattern} is a restricted form of \hyper{pattern},
namely, a nonempty \hyper{pattern} in one of four parenthesized forms below
whose first subform is an identifier or an underscore {\cf \_}\schindex{\_}.
A \hyper{pattern} is an identifier, constant, or one of the following.

\begin{schemenoindent}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{schemenoindent}

An \hyper{ellipsis} is the identifier ``{\cf ...}'' (three periods).\schindex{...}

A \hyper{template} is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, or one of the following.

\begin{scheme}
(\hyper{subtemplate} \ldots)
(\hyper{subtemplate} \ldots . \hyper{template})
\#(\hyper{subtemplate} \ldots)%
\end{scheme}

A \hyper{subtemplate} is a \hyper{template} followed by zero or more ellipses.

\semantics An instance of {\cf syntax-rules} evaluates, at
macro-expansion time, to a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
{\cf syntax-rules} is matched against the patterns contained in the
\hyper{syntax rule}s, beginning with the leftmost \hyper{syntax rule}.
When a match is found, the macro use is transcribed hygienically
according to the template.  It is a syntax violation when no match is found.

An identifier appearing within a \hyper{pattern} may be an underscore
(~{\cf \_}~), a literal identifier listed in the list of literals
{\cf (\hyper{literal} \dots)}, or an ellipsis (~{\cf ...}~).
All other identifiers appearing within a \hyper{pattern} are
\textit{pattern variables\mainindex{pattern variable}}.
It is a syntax violation if an ellipsis or underscore appears in {\cf (\hyper{literal} \dots)}.

While the first subform of \hyper{srpattern} may be an identifier, the
identifier is not involved in the matching and
is not considered a pattern variable or literal identifier.

\begin{rationale}
The identifier is most often the keyword used to identify the macro.
The scope of the keyword is determined by the binding form or syntax
definition that binds it to the associated macro transformer.
If the keyword were a pattern variable or literal
identifier, then
the template that follows the pattern would be within its scope
regardless of whether the keyword were bound by {\cf let-syntax},
{\cf letrec-syntax}, or {\cf define-syntax}.
\end{rationale}

Pattern variables match arbitrary input subforms and
are used to refer to elements of the input.
It is a syntax violation if the same pattern variable appears more than once in a
\hyper{pattern}.

Underscores also match arbitrary input subforms but are not pattern variables
and so cannot be used to refer to those elements.
Multiple underscores may appear in a \hyper{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form $F$ matches a pattern $P$ if and only if
one of the following holds:

\begin{itemize}
\item $P$ is an underscore (~{\cf \_}~).

\item $P$ is a pattern variable.

\item $P$ is a literal identifier
and $F$ is an identifier such that both $P$ and $F$ would refer to the
same binding if both were to appear in the output of the macro outside
of any bindings inserted into the output of the macro.
(If neither of two like-named identifiers refers to any binding, i.e., both
are undefined, they are considered to refer to the same binding.)

\item $P$ is of the form
{\cf ($P_1$ \dots{} $P_n$)}
and $F$ is a list of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dots{} $P_n$ . $P_x$)}
and $F$ is a list or improper list of $n$ or more elements
whose first $n$ elements match $P_1$ through $P_n$
and
whose $n$th cdr matches $P_x$.

\item $P$ is of the form
{\cf ($P_1$ \dots{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dots{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a proper list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dots{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dots{} $P_n$ . $P_x$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a list or improper list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
whose next $n-m$ elements match $P_{m+1}$ through $P_n$,
and 
whose $n$th and final cdr matches $P_x$.

\item $P$ is of the form
{\cf \#($P_1$ \dots{} $P_n$)}
and $F$ is a vector of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf \#($P_1$ \dots{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dots{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a vector of $n$ or more elements
whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is a pattern datum (any nonlist, nonvector, nonsymbol
datum) and $F$ is equal to $P$ in the sense of the
{\cf equal?} procedure.
\end{itemize}

When a macro use is transcribed according to the template of the
matching \hyper{syntax rule}, pattern variables that occur in the
template are replaced by the subforms they match in the input.

Pattern data and identifiers that are not pattern variables
or ellipses are copied directly into the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses as
the subpattern in which the pattern variable appears.
(Otherwise, the expander would not be able to determine how many times the
subform should be repeated in the output.)
It is a syntax violation if the constraints of this paragraph are not met.

A template of the form
{\cf (\hyper{ellipsis} \hyper{template})} is identical to \hyper{template}, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within \hyper{template} are
treated as ordinary identifiers.
In particular, the template {\cf (... ...)} produces a single
ellipsis, {\cf ...}.
This allows syntactic abstractions to expand into forms containing
ellipses.

As an example, if \ide{let} and \ide{cond} are defined as in
section~\ref{let} and appendix~\ref{derivedformsappendix} then they
are hygienic (as required) and the following is not an error.

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

The macro transformer for {\cf cond} recognizes {\cf =>}
as a local variable, and hence an expression, and not as the
top-level identifier {\cf =>}, which the macro transformer treats
as a syntactic keyword.  Thus the example expands into

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

instead of

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

which would result in an assertion violation.

\end{entry}

\begin{entry}{%
\proto{identifier-syntax}{ \hyper{template}}{\exprtype~({\cf expand})}
\pproto{(identifier-syntax}{\exprtype~({\cf expand})}}\\
{\tt\obeyspaces
                   (\hyperi{id} \hyperi{template})
                   ((set! \hyperii{id} \hyper{pattern})
                    \hyperii{template}))}

\syntax The \hyper{id}s must be identifiers.

\semantics
When a keyword is bound to a transformer produced by the first form of
{\cf identifier-syntax}, references to the keyword within the scope
of the binding are replaced by \hyper{template}.

\begin{scheme}
(define p (cons 4 5))
(define-syntax p.car (identifier-syntax (car p)))
p.car \ev 4
(set! p.car 15) \ev \exception{\&syntax}%
\end{scheme}

The second, more general, form of {\cf identifier-syntax} permits
the transformer to determine what happens when {\cf set!} is used.
In this case, uses of the identifier by itself are replaced by
\hyperi{template}, and uses of {\cf set!} with the identifier are
replaced by \hyperii{template}.

\begin{scheme}
(define p (cons 4 5))
(define-syntax p.car
  (identifier-syntax
    (\_ (car p))
    ((set! \_ e) (set-car! p e))))
(set! p.car 15)
p.car           \ev 15
p               \ev (15 5)%
\end{scheme}

\end{entry}

\section{Tail calls and tail contexts}
\label{basetailcontextsection}

A {\em tail call}\mainindex{tail call} is a procedure call that occurs
in a {\em tail context}.  Tail contexts are defined inductively.  Note
that a tail context is always determined with respect to a particular lambda
expression.

\begin{itemize}
\item The last expression within the body of a lambda expression,
  shown as \hyper{tail expression} below, occurs in a tail context.
\begin{grammar}%
(l\=ambda \meta{formals}
  \>\arbno{\hyper{definition}} 
  \>\arbno{\meta{expression}} \meta{tail expression})
\end{grammar}%

\item If one of the following expressions is in a tail context,
then the subexpressions shown as \meta{tail expression} are in a tail context.
These were derived from rules for the syntax of the forms described in
this chapter by replacing some occurrences of \meta{expression}
with \meta{tail expression}.  Only those rules that contain tail contexts
are shown here.

\begin{grammar}%
(if \meta{expression} \meta{tail expression} \meta{tail expression})
(if \meta{expression} \meta{tail expression})

(cond \atleastone{\meta{cond clause}})
(cond \arbno{\meta{cond clause}} (else \meta{tail sequence}))

(c\=ase \meta{expression}
  \>\atleastone{\meta{case clause}})
(c\=ase \meta{expression}
  \>\arbno{\meta{case clause}}
  \>(else \meta{tail sequence}))

(and \arbno{\meta{expression}} \meta{tail expression})
(or \arbno{\meta{expression}} \meta{tail expression})

(let (\arbno{\meta{binding spec}}) \meta{tail body})
(let \meta{variable} (\arbno{\meta{binding spec}}) \meta{tail body})
(let* (\arbno{\meta{binding spec}}) \meta{tail body})
(letrec* (\arbno{\meta{binding spec}}) \meta{tail body})
(letrec (\arbno{\meta{binding spec}}) \meta{tail body})
(let-values (\arbno{\meta{mv binding spec}}) \meta{tail body})
(let*-values (\arbno{\meta{mv binding spec}}) \meta{tail body})

(let-syntax (\arbno{\meta{syntax spec}}) \meta{tail body})
(letrec-syntax (\arbno{\meta{syntax spec}}) \meta{tail body})

(begin \meta{tail sequence})

(d\=o \=(\arbno{\meta{iteration spec}})
  \>  \>(\meta{test} \meta{tail sequence})
  \>\arbno{\meta{expression}})

{\rm where}

\meta{cond clause} \: (\meta{test} \meta{tail sequence})
\meta{case clause} \: ((\arbno{\meta{datum}}) \meta{tail sequence})

\meta{tail body} \: \arbno{\meta{definition}}
\>\> \meta{tail sequence}
\meta{tail sequence} \: \arbno{\meta{expression}} \meta{tail expression}
\end{grammar}%

\item
If a {\cf cond} expression is in a tail context, and has a clause of
the form {\cf (\hyperi{expression} => \hyperii{expression})}
then the (implied) call to
the procedure that results from the evaluation of \hyperii{expression} is in a
tail context.  \hyperii{expression} itself is not in a tail context.

\end{itemize}

Certain built-in procedures are also required to perform tail calls.
The first argument passed to \ide{apply} and to
\ide{call-with-current-continuation}, and the second argument passed to
\ide{call-with-values}, must be called via a tail call.

In the following example the only tail call is the call to {\cf f}.
None of the calls to {\cf g} or {\cf h} are tail calls.  The reference to
{\cf x} is in a tail context, but it is not a call and thus is not a
tail call.
\begin{scheme}%
(lambda ()
  (if (g)
      (let ((x (h)))
        x)
      (and (g) (f))))%
\end{scheme}%

\begin{note}
Implementations are allowed, but not required, to
recognize that some non-tail calls, such as the call to {\cf h}
above, can be evaluated as though they were tail calls.
In the example above, the {\cf let} expression could be compiled
as a tail call to {\cf h}. (The possibility of {\cf h} returning
an unexpected number of values can be ignored, because in that
case the effect of the {\cf let} is explicitly unspecified and
implementation-dependent.)
\end{note}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

