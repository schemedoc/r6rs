\chapter{Libraries}
\label{librarychapter}
\mainindex{library}
The library system presented here is designed to let programmers share
libraries, i.e., code that is intended to be incorporated into larger
programs, and especially into programs that use library code from multiple
sources.  The library system supports macro definitions within libraries,
allows macro exports, and distinguishes the phases in which definitions
and imports are needed.  This chapter defines the notation for
libraries and a semantics for library expansion and execution.

Libraries address the following specific goals:

\begin{itemize}
\item Separate compilation and analysis; no two libraries have to be
  compiled at the same time (i.e., the meanings of two libraries
  cannot depend on each other cyclically, and compilation of two
  different libraries cannot rely on state shared across
  compilations), and significant program analysis
  can be performed without examining a whole program.
\item Independent compilation/analysis of unrelated libraries, where
  ``unrelated'' means that neither depends on the other through a
  transitive closure of imports.
\item Explicit declaration of dependencies, so that the meaning of
  each identifier is clear at compile time, and so that there is no
  ambiguity about whether a library needs to be executed for another
  library's compile time and/or run time.
\item Namespace management, to help prevent name conflicts.
\end{itemize}

It does not address the following:

\begin{itemize}
\item Mutually dependent libraries.
\item Separation of library interface from library implementation.
\item Code outside of a library (e.g., {\cf 5} by itself as a program).
\item Local modules and local imports. 
\end{itemize}

\section{Library form}
\label{librarysyntaxsection}

A library declaration contains the following elements:

\begin{itemize}
\item a name for the library (possibly with versioning),
\item a list of exports, which name a subset of the bindings defined
      within or imported into the library,
\item a list of import dependencies, where each dependency specifies:
\begin{itemize}
\item the imported library's name,
\item the relevant levels, e.g., expand or run time, and
\item the subset of the library's exports to make available within the
      importing library, and the local names to use within the importing
      library for each of the library's exports, and
\end{itemize}
\item a library body, consisting of a sequence of definitions 
      followed by a sequence of expressions.
\end{itemize}

A library definition must have the following form:\mainschindex{library}\mainschindex{import}\mainschindex{export}

\begin{scheme}
(library \hyper{library~name}
  (export \hyper{export~spec} \ldots)
  (import \hyper{import~spec} \ldots)
  \hyper{library~body})%
\end{scheme}

The \hyper{library~name} specifies the name of the library, the
{\cf export} form specifies the exported bindings, and the
{\cf import} form specifies the imported bindings.
The \hyper{library~body} specifies the set of definitions, both for local
(unexported) and exported bindings, and the set of initialization
expressions to be evaluated for their effects.
The exported bindings may be defined within the library or imported into
the library.

An identifier can be imported from two or more libraries or for two
levels from the same library only if the
binding exported by each library is the same (i.e., the binding is
defined in one library, and it arrives through the imports only by
exporting and re-exporting).  Otherwise, no identifier can be imported
multiple times, defined multiple times, or both defined and imported.
No identifiers are visible within a library except for those explicitly
imported into the library or defined within the library.

A \hyper{library name} has the following form:

\begin{scheme}
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version})%
\end{scheme}

where \hyper{version} is empty or has the following form:
%
\begin{scheme}
(\hyper{sub-version} \ldots)%
\end{scheme}

Each \hyper{sub-version} must be an exact nonnegative integer.
An empty \hyper{version} is equivalent to {\cf ()}.

Each \hyper{import~spec} specifies a set of bindings to be imported into
the library, the levels at which they are to be available, and the local
names by which they are to be known.  An \hyper{import spec} must
be one of the following:
%
\begin{scheme}
\hyper{import set}
(for \hyper{import~set} \hyper{import~level} \ldots)%
\end{scheme}

An \hyper{import level}  is one of the following:
\begin{scheme}
run
expand
(meta \hyper{level})%
\end{scheme}

where \hyper{level} is an exact integer.

As an \hyper{import level}, {\cf run} is an abbreviation for {\cf
  (meta 0)}, and {\cf expand} is an abbreviation for {\cf (meta 1)}.
Levels and phases are discussed in section~\ref{phasessection}.

An \hyper{import~set} names a set of bindings from another library, and
possibly specifies local names for the imported bindings.  It must be
one of the following:

\begin{scheme}
\hyper{library~reference}
(only \hyper{import~set} \hyper{identifier} \ldots)
(except \hyper{import~set} \hyper{identifier} \ldots)
(prefix \hyper{import~set} \hyper{identifier})
(rename \hyper{import~set} (\hyper{identifier} \hyper{identifier}) \ldots)%
\end{scheme}

A \hyper{library~reference} identifies a library by its 
name and optionally by its version.  It has the following form:

\begin{scheme}
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version~reference})%
\end{scheme}

A \hyper{version reference} is empty or has the following form:

\begin{scheme}
(\hyper{version spec} \ldots)%
\end{scheme}

A \hyper{version spec} has one of the following forms:

\begin{scheme}
(\hyper{sub-version reference} \ldots)
(and \hyper{version spec} \ldots)
(or \hyper{version spec} \ldots)
(not \hyper{version spec} \ldots)%
\end{scheme}

An empty \hyper{version reference} is equivalent to {\cf ()}.

A \hyper{sub-version reference} has one of the following forms:

\begin{scheme}
\hyper{sub-version}
\hyper{sub-version~condition}%
\end{scheme}

where a \hyper{sub-version condition} must have one of these forms:

\begin{scheme}
(>= \hyper{sub-version})
(<= \hyper{sub-version})
(and \hyper{sub-version~condition} \ldots)
(or \hyper{sub-version~condition} \ldots)
(not \hyper{sub-version~condition})%
\end{scheme}


The sequence of identifiers in the importing library's
\hyper{library~reference} must match the sequence of identifiers in the
imported library's \hyper{library~name}.
The importing library's \hyper{version~reference} specifies a predicate on a
prefix of the imported library's \hyper{version}.
Each integer must match exactly and each condition has the expected meaning.
Everything beyond the prefix specified in the version reference matches
unconditionally.
When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent manner.

To avoid problems such as incompatible types and replicated state, two
libraries whose library names contain the same sequence of identifiers but
whose versions do not match cannot co-exist in the same program.

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the bindings
by the imported library.
The precise set of bindings to be imported and the names of those
bindings can be adjusted with the {\cf only}, {\cf except},
{\cf prefix}, and {\cf rename} forms as described below.

\begin{itemize}
\item An {\cf only} form produces a subset of the bindings from another
\hyper{import~set}, including only the listed
\hyper{identifier}s.
The included \hyper{identifier}s must be in
the original \hyper{import~set}.
\item An {\cf except} form produces a subset of the bindings from another
\hyper{import~set}, including all but the listed
\hyper{identifier}s.
All of the excluded \hyper{identifier}s must be in
the original \hyper{import~set}.
\item A {\cf prefix} form adds the \hyper{identifier} prefix to each
name from another \hyper{import~set}.
\item A {\cf rename} form, {\cf (rename (\hyper{oldid} \hyper{newid}) \ldots)},
removes the bindings for {\cf \hyper{oldid} \ldots} to form an
intermediate \hyper{import~set}, then adds the bindings back for the
corresponding {\cf \hyper{newid} \ldots} to form the final
\hyper{import~set}.
Each \hyper{oldid} must be in the original \hyper{import~set},
each \hyper{newid} must not be in the intermediate \hyper{import~set},
and the \hyper{newid}s must be distinct.
\end{itemize}
It is a syntax violation if a constraint given above is not met.

An \hyper{export~spec} names a set of imported and locally defined bindings to
be exported, possibly with different
external names.  An \hyper{export~spec} must have one of the
following forms:

\begin{scheme}
\hyper{identifier}
(rename (\hyper{identifier} \hyper{identifier}) \ldots)%
\end{scheme}

In an \hyper{export~spec}, an \hyper{identifier} names a single binding defined
within or imported into the library, where the external name for the export is
the same as the name of the binding within the library. 
A {\cf rename} spec exports the binding named by the first
\hyper{identifier} in each {\cf (\hyper{identifier}
  \hyper{identifier})} pairing, using the second \hyper{identifier} as the
external name.

\label{librarybodysection}
The \hyper{library~body} of a {\cf library} form consists of forms
that are classified into 
\textit{definitions}\mainindex{definition}, and
\textit{expressions}\mainindex{expression}.  Which forms belong to
which class depends on the imported libraries and the result of
expansion---see chapter~\ref{expansionchapter}.  Generally, forms that
are not 
definitions (see section~\ref{defines} for definitions available
through the base library) are expressions.

A \hyper{library~body} is like a \hyper{body} (see section~\ref{bodiessection}) except that
\hyper{library~body}s need not include any expressions.  It must
have the following form:

\begin{scheme}
\hyper{definition} \ldots \hyper{expression} \ldots%
\end{scheme}

When base-library {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax} forms
occur in a top-level body prior to the first
expression, they are spliced into the body; see section~\ref{begin}.
Some or all of the body, including portions wrapped in {\cf begin},
{\cf let-syntax}, or {\cf letrec-syntax}
forms, may be specified by a syntactic abstraction
(see section~\ref{macrosection}).

The transformer expressions and transformer bindings are created
from left to right, as described in chapter~\ref{expansionchapter}.
The variable-definition right-hand-side expressions are evaluated
from left to right, as if in an implicit {\cf letrec*},
and the body expressions are also evaluated from left to right
after the variable-definition right-hand-side expressions.
A fresh location is created for each exported variable and initialized
to the value of its local counterpart.
The effect of returning twice to the continuation of the last body
expression is unspecified.

The names {\cf library}, {\cf export}, {\cf import},
{\cf for}, {\cf run}, {\cf expand}, {\cf meta},
{\cf import}, {\cf export}, {\cf only}, {\cf except}, {\cf
  prefix}, {\cf rename}, {\cf and}, {\cf or}, {\cf >=}, and {\cf <=}
appearing in the library syntax are part of the
syntax and are not reserved, i.e, the same can be used for other
purposes within the library or even exported from or imported 
into a library with different meanings, without affecting their
use in the {\cf library} form.

Bindings defined with a library are not visible in code
outside of the library, unless the bindings are explicitly exported from the
library. 
An exported macro may, however, \emph{implicitly export} an otherwise
unexported identifier defined within or imported into the library.
That is, it may insert a reference to that identifier into the output code
it produces.

\label{importsareimmutablesection} 
All explicitly exported variables are immutable in both the
exporting and importing libraries. 
It is thus a syntax violation if an
explicitly exported variable appears on the left-hand side of a {\cf set!}
expression, either in the exporting or importing libraries.
All other variables defined within a library are mutable.

All implicitly exported variables are also immutable in both the
exporting and importing libraries.
It is thus a syntax violation if a
variable appears on the left-hand side of a {\cf set!}
expression in any code produced by an exported macro outside of the
library in which the variable is defined.
It is also a syntax violation if a
reference to an assigned variable appears in any code produced by
an exported macro outside of the library in which the variable is defined,
where an assigned variable is one that appears on the left-hand
side of a {\cf set!} expression in the exporting library.

\begin{note}
The asymmetry in the prohibitions against assignments to
explicitly and implicitly exported variables reflects the fact that the
violation can be determined for implicitly exported variables only when the
importing library is expanded.
\end{note}

\section{Import and export levels}
\label{phasessection}

Every library can be characterized by expand-time information (minimally,
its imported libraries, a list of the exported keywords, a list of the
exported variables, and code to evaluate the transformer expressions) and
run-time information (minimally, code to evaluate the variable definition
right-hand-side expressions, and code to evaluate the body expressions).
The expand-time information must be available to expand references to
any exported binding, and the run-time information must be available to
evaluate references to any exported variable binding.

Expanding a library may require run-time information from another
library. For example, if a library provides procedures that are called
by another library's macros during expansion, then the former library
must be run when expanding the latter. The former may not be needed
when the latter is eventually run as part of a program, or it may be
needed for the latter's run time, too.

\mainindex{phase}
%
A \emph{phase} is a time at which the expressions within a library are
evaluated.
Within a library body, top-level expressions and
the right-hand sides of {\cf define} forms are evaluated at run time,
i.e., phase $0$, and the right-hand
sides of {\cf define-syntax} forms are evaluated at expand time, i.e.,
phase $1$.
When {\cf define-syntax},
{\cf let-syntax}, or {\cf letrec-syntax}
forms appear within code evaluated at phase $n$, the right-hand sides
are evaluated as phase $n+1$ expressions.

These phases are relative to the phase in which the library itself is
used.
An \defining{instance} of a library corresponds to an evaluation of its
variable definitions and expressions in a particular phase relative to another
library---a process called \defining{instantiation}.
For example, if a top-level expression in a library $L_1$ refers to
a variable export from another library $L_0$, then it refers to the export from an
instance of $L_0$ at phase $0$ (relative to the phase of $L_1$).
But if a phase $1$ expression within $L_1$ refers to the same binding from
$L_0$, then it refers to the export from an instance of $L_0$ at phase $1$
(relative to the phase of $L_1$).

A \defining{visit} of a library corresponds to the evalution of its syntax
definitions in a particular phase relative to another
library---a process called \defining{visiting}. Evaluating a syntax definition
at phase $n$ means that its right-hand side is evaluated at phase $n+1$.
For example, if a top-level expression in a library $L_1$ refers to
a macro export from another library $L_0$, then it refers to the export from an
visit of $L_0$ at phase $0$ (relative to the phase of $L_1$), which corresponds
to the evaluation of the macro's transformer expression at phase $1$.


\mainindex{level}\mainindex{import level} 
%
A \emph{level} is a lexical property of an identifier that determines
in which phases it can be referenced. The level for each identifier
bound by a definition within a library is $0$; that is, the identifier
can be referenced only by phase $0$ expressions within the library.
The level for each imported binding is determined by the enclosing {\cf
  for} form of the {\cf import} in the importing library, in
addition to the levels of the identifier in the exporting
library. Import and export levels are combined by pairwise addition of
all level combinations.  For example, references to an imported
identifier exported for levels $p_a$ and $p_b$ and imported for levels
$q_a$, $q_b$, and $q_c$ are valid at levels $p_a+q_a$, $p_a+q_b$,
$p_a+q_c$, $p_b+q_a$, $p_b+q_b$, and $p_b+q_c$. An \hyper{import~set}
without an enclosing {\cf for} is equivalent to {\cf (for
  \hyper{import~set} run)}, which is the same as {\cf (for
  \hyper{import~set} (meta 0))}.

The export level of an exported binding is $0$ for all bindings
that are defined within the exporting library. The export levels of a
reexported binding, i.e., an export imported from another library, are the
same as the effective import levels of that binding within the reexporting
library.

For the libraries defined in the library report, the export level is
$0$ for nearly all bindings. The exceptions are {\cf syntax-rules}
and {\cf identifier-syntax} 
from the {\cf (r6rs base)} library, which are exported
with level $1$, and all bindings from the composite {\cf (r6rs)}
library (see library chapter~\extref{lib:complibchapter}{Composite library}), which are
exported with levels $0$ and $1$.

\begin{rationale} 
The {\cf (r6rs)} library is intended as a convenient import for libraries where fine
control over imported bindings is not necessary or desirable. The {\cf (r6rs)} library
exports all bindings for {\cf expand} as well as {\cf run} so that it is convenient
for writing {\cf syntax-case} macros as well as run-time code.
\end{rationale}

Macro expansion within a library can introduce a reference to an
identifier that is not explicitly imported into the library. In that
case, the phase of the reference must match the identifier's level as
shifted by the difference between the phase of the source library
(i.e., the library that supplied the identifier's lexical context) and
the library that encloses the reference. For example, suppose that
expanding a library invokes a macro transformer, and the evaluation of
the macro transformer refers to an identifier that is exported from
another library (so the phase $1$ instance of the library is used);
suppose further that the value of the binding is a syntax object
representing an identifier with only a level-$n$ binding; then, the
identifier must be used only in a phase $n+1$ expression in the
library being expanded. This combination of level and phases is why
negative levels on identifiers can be useful, even though libraries
exist only at non-negative phases.

If any of a library's definitions are referenced at phase $0$ in the
expanded form of a program, then an instance of the referenced library
is created for phase $0$ before the program's definitions and
expressions are evaluated. This rule applies transitively: if the
expanded form of one library references at phase $0$ an identifier
from another library, then before the referencing library is
instantiated at phase $n$, the referenced library must be instantiated
for at phase $n$. When an identifier is referenced at any phase $n$
greater than $0$, in contrast, then the defining library is
instantiated at phase $n$ at some unspecified time before the
reference is evaluated. Similarly, when a macro keyword is referenced at
phase $n$ during the expansion of a library, then the
defining library is visited at phase $n$ at some unspecified time
before the reference is evaluated.

An implementation is allowed to distinguish instances/visits of a library for
different phases or to use an instance/visit at any phase as an instance/visit at
any other phase. An implementation is further allowed to start each
expansion of a {\cf library} form by removing
visits of libraries in any phase and/or instances of
libraries in phases above $0$. An implementation is allowed to
create instances/visits of more libraries at more phases than required to
satisfy references. When an identifier appears as an expression in a
phase that is inconsistent with the identifier's level, then an
implementation may raise an exception either at expand time or run
time, or it may allow the reference. Thus, a library is portable only
when it references identifiers in phases consistent with the declared
levels, and a library whose meaning depends on whether the
instances of a library are distinguished or shared across phases or
{\cf library} expansions may be unportable.

\begin{rationale} 
Opinions vary on how libraries should be instantiated and
initialized during the expansion and execution of library bodies,
whether library instances should be distnguished across phases,
and whether levels should be declared so that they constrain 
identifier uses to particular phases. This report therefore leaves
considerable latitude to implementations, while attempting to
provide enough guarantees to make portable libraries practical.

In particular, if a program and its libraries avoid the {\cf (r6rs)}
and {\cf (r6rs syntax-case)} libraries, and if the program and libraries
never use the {\cf for} import form, then the program does not depend
on whether instances are distinguished across phases, and the phase of
an identifier's use cannot be inconsistent with the identifier's level.
\end{rationale} 

\section{Primitive syntax}

After the {\cf import} form within a {\cf library} form, the forms
that constitute a library body depend on the libraries that are
imported. In particular, imported syntactic keywords determine most
of the available forms and whether each form is a 
definition or expression. A few form types are
always available independent of imported libraries, however,
including constant literals, variable references, procedure calls,
 and macro uses.

\subsection{Primitive expression types}
\label{primitiveexpressionsection}

The entries in this section all describe expressions, which may occur
in the place of \hyper{expression} syntactic variables.  See
also section~\ref{expressionsection}

\subsubsection*{Constant literals}\unsection

\begin{entry}{%
\pproto{\hyper{constant}}{\exprtype}}\mainindex{literal}

Numerical constants, string constants, character constants, and
boolean Constants evaluate ``to themselves''.

\begin{scheme}
"abc"      \ev  "abc"
145932     \ev  145932
\schtrue   \ev  \schtrue%
\end{scheme}

As noted in section~\ref{storagemodel}, the value of a literal
expression may be immutable.
\end{entry}

\subsubsection*{Variable references}\unsection
\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

An expression consisting of a variable\index{variable}
(section~\ref{variablesection}) is a variable reference.  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is a syntax violation to reference
an unbound\index{unbound} variable.

\begin{scheme}
; These examples assume the base library
; has been imported.
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsubsection*{Procedure calls}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

A procedure call is written by simply enclosing in parentheses
expressions for the procedure to be called and the arguments to be
passed to it.  A form in an expression context is a procedure
call if \hyper{operator} is not an identifier bound as a syntactic keyword.

When a procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting
arguments.\mainindex{call}\mainindex{procedure call}
\begin{scheme}%
; These examples assume the base library
; has been imported.
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

If the value of \hyper{operator} is not a procedure, an exception with
condition type {\cf\&assertion} is raised.

\begin{note} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.
\end{note}

\begin{note}
Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.
\end{note}

\begin{note} In many dialects of Lisp, the form {\tt
()} is a legitimate expression.  In Scheme, expressions written as
list/pair forms must have at
least one subexpression, so {\tt ()} is not a syntactically valid
expression.
\end{note}

\todo{Freeman:
I think an explanation as to why evaluation order is not specified
should be included.  It should not include any reference to parallel
evaluation.  Does any existing compiler generate better code because
the evaluation order is unspecified?  Clinger: yes: T3, MacScheme v2,
probably MIT Scheme and Chez Scheme.  But that's not the main reason
for leaving the order unspecified.}

\end{entry}

\subsection{Macros}
\label{macrosection}

Scheme libraries can define and use new derived expressions and
definitions called {\em syntactic abstractions} or
{\em macros}.\mainindex{syntactic abstraction}\mainindex{macro}
A syntactic abstraction is created by binding a keyword to a
{\em macro transformer} or, simply, {\em transformer}.
\index{macro transformer}\index{transformer}
The transformer determines
how a use of the macro is transcribed into a more primitive
form.

Macro uses typically have the form:
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
type of form.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.
The number of \hyper{datum}s and the syntax
of each depends on the syntactic abstraction.
Macro uses can also take the form of improper lists, singleton
identifiers, or {\cf set!} forms, where the second subform of the
{\cf set!} is the keyword (see
library section~\extref{lib:make-variable-transformer}{{\cf make-variable-transformer}}:
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo . \hyper{datum})
\hyper{keyword}
(set! \hyper{keyword} \hyper{datum})%
\end{scheme}

The macro definition facility consists of two parts:

\begin{itemize}
\item A set of forms ({\cf define-syntax} described in
  section~\ref{define-syntax}, {\cf let-syntax} and {\cf
    letrec-syntax} described in section~\ref{let-syntax}) used to create bindings
for keywords, associate them with macro transformers, and control
the scope within which they are visible, and

\item a facility ({\cf syntax-rules}; see
  section~\ref{syntaxrulessection}) for creating transformers
  via a pattern language,
  and a facility ({\cf syntax-case}; see
  library chapter~\extref{lib:syntaxcasechapter}{{\cf syntax-case}}) for creating transformers
  via a pattern language that permits the use of arbitrary
  Scheme code.
\end{itemize}

Keywords occupy the same name space as variables.
That is, within the same
scope, an identifier can be bound as a variable or keyword, or neither, but
not both, and local bindings of either kind may shadow other bindings of
either kind.

Macros defined using {\cf syntax-rules} are ``hygienic'' and ``referentially
transparent'' and thus preserve Scheme's lexical scoping~\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}:
\mainindex{hygienic}
\mainindex{referentially transparent}

\begin{itemize}
\item If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier is in effect renamed
throughout its scope to avoid conflicts with other identifiers.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.
\end{itemize}

Macros defined using the {\cf syntax-case} facility are also
hygienic unless {\cf datum\coerce{}syntax}
(see library section~\extref{lib:conversionssection}{Syntax-object and datum conversions}) is used.

\section{Examples}

Examples for various \hyper{import~spec}s and \hyper{export~spec}s:

\begin{scheme}
(library (stack)
  (export make push! pop! empty!)
  (import (r6rs))

  (define (make) (list '()))
  (define (push! s v) (set-car! s (cons v (car s))))
  (define (pop! s) (let ([v (caar s)])
                     (set-car! s (cdar s))
                     v))
  (define (empty! s) (set-car! s '())))

(library (balloons)
  (export make push pop)
  (import (r6rs))

  (define (make w h) (cons w h))
  (define (push b amt)
    (cons (- (car b) amt) (+ (cdr b) amt)))
  (define (pop b) (display "Boom! ") 
                  (display (* (car b) (cdr b))) 
                  (newline)))

(library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import (r6rs)
          (only (stack) make push! pop!) ; not empty!
          (prefix (balloons) balloon:))

  ;; Creates a party as a stack of balloons,
  ;; starting with two balloons
  (define (make-party)
    (let ([s (make)]) ; from stack
      (push! s (balloon:make 10 10))
      (push! s (balloon:make 12 9))
      s))
  (define (party-pop! p)
    (balloon:pop (pop! p))))


(library (main)
  (export)
  (import (r6rs) (party))

  (define p (make-party))
  (pop! p)        ; displays "Boom! 108"
  (push! p (push (make 5 5) 1))
  (pop! p))       ; displays "Boom! 24"%
\end{scheme}

Examples for macros and phases:

\begin{schemenoindent}
(library (my-helpers id-stuff)
  (export find-dup)
  (import (r6rs))

  (define (find-dup l)
    (and (pair? l)
         (let loop ((rest (cdr l)))
           (cond
            [(null? rest) (find-dup (cdr l))]
            [(bound-identifier=? (car l) (car rest)) 
             (car rest)]
            [else (loop (cdr rest))])))))

(library (my-helpers values-stuff)
  (export mvlet)
  (import (r6rs) (for (my-helpers id-stuff) expand))

  (define-syntax mvlet
    (lambda (stx)
      (syntax-case stx ()
        [(\_ [(id ...) expr] body0 body ...)
         (not (find-dup (syntax (id ...))))
         (syntax
           (call-with-values
               (lambda () expr) 
             (lambda (id ...) body0 body ...)))]))))

(library (let-div)
  (export let-div)
  (import (r6rs)
          (my-helpers values-stuff)
          (r6rs r5rs))

  (define (quotient+remainder n d)
    (let ([q (quotient n d)])
      (values q (- n (* q d)))))
  (define-syntax let-div
    (syntax-rules ()
     [(\_ n d (q r) body0 body ...)
      (mvlet [(q r) (quotient+remainder n d)]
        body0 body ...)])))%
\end{schemenoindent}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
