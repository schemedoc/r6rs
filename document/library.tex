\chapter{Libraries}
\label{librarychapter}
\mainindex{library}
The library system presented here is designed to let programmers share
libraries, i.e., code that is intended to be incorporated into larger
programs, and especially into programs that use library code from multiple
sources.  The library system supports macro definitions within libraries,
allows macro exports, and distinguishes the phases in which definitions
and imports are needed.  This chapter defines the notation for
libraries, a semantics for library expansion and execution, and a simple
format for sharing libraries.

Libraries address the following specific goals:

\begin{itemize}
\item Separate compilation and analysis; no two libraries have to be
  compiled at the same time (i.e., the meanings of two libraries
  cannot depend on each other cyclically, and compilation of two
  different libraries cannot rely on state shared across
  compilations), and significant program analysis
  can be performed without examining a whole program.
\item Independent compilation/analysis of unrelated libraries, where
  ``unrelated'' means that neither depends on the other through a
  transitive closure of imports.
\item Explicit declaration of dependencies, so that the meaning of
  each identifier is clear at compile time, and so that there is no
  ambiguity about whether a library needs to be executed for another
  library's compile time and/or run time.
\item Namespace management, so that different library producers are
  unlikely to define the same top-level name.
\end{itemize}

It does not address the following:

\begin{itemize}
\item Mutually dependent libraries.
\item Separation of library interface from library implementation.
\item Code outside of a library (e.g., {\cf 5} by itself as a program).
\item Local modules and local imports. 
\end{itemize}

\section{Library form}
\label{librarysyntaxsection}

A library declaration contains the following elements:

\begin{itemize}
\item a name for the library (possibly compound, with versioning),
\item a list of exports, which name a subset of the library's imports and
      definitions, and
\item a list of import dependencies, where each dependency specifies the
      following:
\begin{itemize}
\item the imported library's name,
\item the relevant phases, e.g., expand or run time, and
\item the subset of the library's exports to make available within the
      importing library, and the local names to use within the importing
      library for each of the library's exports,
\end{itemize}
\item a library body, consisting of a sequence of definitions followed
      by a sequence of expressions.
\end{itemize}

A library definition must have the following form:\mainschindex{library}\mainschindex{import}\mainschindex{export}

\begin{scheme}
(library \hyper{library~name}
  (export \hyper{export~spec} \ldots)
  (import \hyper{import~spec} \ldots)
  \hyper{library~body})%
\end{scheme}

The \hyper{library~name} specifies the name of the library, the
{\cf export} form specifies the exported bindings, and the
{\cf import} form specifies the imported bindings.
The \hyper{library~body} specifies the set of definitions, both for local
(unexported) and exported bindings, and the set of initialization
expressions (commands) to be evaluated for their effects.
The exported bindings may be defined within the library or imported into
the library.

An identifier can be imported from two or more libraries only if the
binding exported by each library is the same (i.e., the binding is
defined in one library, and it arrives through the imports only by
exporting and re-exporting).  Otherwise, no identifier can be imported
multiple times, defined multiple times, or both defined and imported.

A \hyper{library name} must be one of the following:

\begin{scheme}
\hyper{identifier}
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version})%
\end{scheme}

where \hyper{version} is empty or has the following form:
%
\begin{scheme}
(\hyperi{subversion} \hyperii{subversion} \ldots)%
\end{scheme}

Each \hyper{subversion} must be an exact nonnegative integer.

As a \hyper{library name}, \hyper{identifier} is shorthand for {\cf
  (\hyper{identifier})}.

Each \hyper{import~spec} specifies a set of bindings to be imported into
the library, the phases in which they are to be available, and the local
names by which they are to be known.  A \hyper{import spec} must
be one of the following:
%
\begin{scheme}
\hyper{import set}
(for \hyper{import~set} \hyper{import~phase} \ldots)%
\end{scheme}

An \hyper{import phase}  is one of the following:
\begin{scheme}
run
expand
(meta \hyper{level})%
\end{scheme}

where \hyper{level} is an exact nonnegative integer.

As an \hyper{import phase}, {\cf run} is an abbreviation for {\cf
  (meta 0)}, and {\cf expand} is an abbreviation for {\cf (meta 1)}.
Phases are discussed in section~\ref{phasessection}.

An \hyper{import~set} names a set of bindings from another library, and
possibly specifies local names for the imported bindings.  It must be
one of the following:

\begin{scheme}
\hyper{library~reference}
(only \hyper{import~set} \hyper{identifier} \ldots)
(except \hyper{import~set} \hyper{identifier} \ldots)
(add-prefix \hyper{import~set} \hyper{identifier})
(rename \hyper{import~set} (\hyper{identifier} \hyper{identifier}) \ldots)%
\end{scheme}

A \hyper{library~reference} identifies a library by its (possibly compound)
name and optionally by its version.  It must have one the following forms:

\begin{scheme}
\hyper{identifier}
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version~reference})%
\end{scheme}

\hyper{Identifier} is shorthand for {\cf (\hyper{identifier})}.
A \hyper{version reference} must have one of the following forms:

\begin{scheme}
\hyper{empty}
(\hyperi{subversion~reference} \hyperii{subversion~reference} \ldots)%
\end{scheme}

A \hyper{subversion reference} must have one of the following forms:

\begin{scheme}
\hyper{subversion}
\hyper{subversion~condition}%
\end{scheme}

where a \hyper{subversion condition} must have one of these forms:

\begin{scheme}
(>= \hyper{subversion})
(<= \hyper{subversion})
(and \hyperi{subversion~condition} \hyperii{subversion~condition} \ldots)
(or \hyperi{subversion~condition} \hyperii{subversion~condition} \ldots)
(not \hyper{subversion~condition})%
\end{scheme}


The sequence of identifiers in the importing library's
\hyper{library~reference} must match the sequence of identifiers in the
imported library's \hyper{library~name}.
The importing library's \hyper{version~reference} specifies a predicate on a
prefix of the imported library's \hyper{version}.
Each integer must match exactly and each condition has the expected meaning.
Everything beyond the prefix specified in the version reference matches
unconditionally.
When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent manner.

To avoid problems such as incompatible types and replicated state, two
libraries whose library names contain the same sequence of identifiers but
whose versions do not match cannot co-exist in the same program.

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the bindings
by the imported library.
The precise set of bindings to be imported and the names of those
bindings can be adjusted with the {\cf only}, {\cf except},
{\cf add-prefix}, and {\cf rename} forms as described below.

\begin{itemize}
\item The {\cf only} form produces a subset of the bindings from another
\hyper{import~set}, including only the listed
\hyper{identifier}s; if any of the included \hyper{identifier}s is not in
\hyper{import~set}, an exception is raised.
\item The {\cf except} form produces a subset of the bindings from another
\hyper{import~set}, including all but the listed
\hyper{identifier}s; if any of the excluded \hyper{identifier}s is not in
\hyper{import~set}, an exception is raised.
\item The {\cf add-prefix} adds the \hyper{identifier} prefix to each
name from another \hyper{import~set}.
\item The {\cf rename} form, for each pair of identifiers {\cf (\hyper{identifier}
\hyper{identifier})}, removes a binding from the set from \hyper{import~set},
and adds it back with a different name. 
The first identifier is the original name, and the
second identifier is the new name. 
If the original name is not in \hyper{import~set}, or
if the new name is already in \hyper{import~set}, an exception is raised.
\end{itemize}

An \hyper{export~set} names a set of imported and locally defined bindings to
be exported for optionally specified phases, possibly with different
external names.  An \hyper{export spec} must have one of the
following forms:

\begin{scheme}
\hyper{export~set}
(for (\hyper{export~set} \ldots) \hyper{import~phase} \ldots)%
\end{scheme}

where an \hyper{export set} must have one of these forms:

\begin{scheme}
\hyper{identifier}
(rename (\hyper{identifier} \hyper{identifier}) \ldots)%
\end{scheme}

In an \hyper{export~set}, an \hyper{identifier} names a single binding defined
within the library or imported, where the external name for the export is
the same as the name of the binding within the library. 
A {\cf rename} set exports the binding named by the first
\hyper{identifier} in each pair, using the second \hyper{identifier} as the
external name.

\label{librarybodysection}
The \hyper{library~body} of a {\cf library} form consists of forms
that are classified into \textit{declarations}\mainindex{declaration},
\textit{definitions}\mainindex{definition}, and
\textit{expressions}\mainindex{expression}.  Which forms belong to
which class depends on the imported libraries and the result of
expansion---see chapter~\ref{expansionchapter}.  Generally, forms that
are not declarations (see section~\ref{declarationssection} for
declarations available through the base library) or
definitions (see section~\ref{defines} for definitions available
through the base library) are expressions.

A \hyper{library~body} is like a \hyper{body} (see section~\ref{bodiessection}) except that
\hyper{library~body}s need not include any expressions.  It must
have the following form:

\begin{scheme}
\hyper{declaration} \ldots \hyper{definition} \ldots \hyper{expression} \ldots%
\end{scheme}

Note that {\cf begin} forms occurring in a body are spliced into the
body; see section~\ref{begin}.

The transformer expressions and transformer bindings are created
from left to right, as described in chapter~\ref{expansionchapter}.
The variable-definition right-hand-side expressions are evaluated
from left to right, as if in an implicit {\cf letrec*},
and the body expressions are also evaluated from left to right
after the variable-definition right-hand-side expressions.
The location of each exported variable is then initialized to the value
of its local counterpart.
The effect of returning twice to the continuation of the last body
expression is unspecified.

The names {\cf library}, {\cf export}, {\cf import},
{\cf for}, {\cf run}, {\cf expand}, {\cf meta},
{\cf import}, {\cf export}, {\cf only}, {\cf except}, and
{\cf rename} appearing in the library syntax are part of the
syntax and are not reserved, i.e, the same can be used for other
purposes within the library or even exported from or imported 
into a library with different meanings, without affecting their
use in the {\cf library} form.

In the case of any ambiguities that arise from the use of one of
these names as a shorthand (single-identifier) library name, the
ambiguity should be resolved in favor of the interpretation
of the name as library syntax.
For example, {\cf (import (for lib expand))} should be taken as
importing library {\cf lib} for {\cf expand}, not as importing
a library named {\cf (for lib expand)}.
The user can always eliminate such ambiguities by avoiding the shorthand
\hyper{library~reference} syntax when such an ambiguity might arise.

Bindings defined with a library are not visible in code
outside of the library, unless the bindings are explicitly exported from the
library. 
An exported macro may, however, \emph{implicitly export} an identifier
defined within or imported into the library.
That is, it may insert a reference to that identifier into the output code
it produces.

\label{importsareimmutablesection} 
All explicitly exported variables are immutable in both the exporting and
importing libraries.
All implicitly exported variables are mutable in the exporting library but
immutable in the importing libraries.
In consequence, any change after the initial assignment to the value of an
implicitly exported variable is not reflected by the references inserted
by an exported macro outside of the exporting library, and exported macros
may not insert assignments to implicitly exported variables outside of the
exporting library.

\section{Import phases}
\label{phasessection}

\mainindex{phase}\mainindex{import phase}
All bindings imported via a library's {\cf import} form are
\emph{visible} throughout the library's \hyper{library~body}.
An exception may be raised, however, if a binding is used out of its declared
phase(s):

\begin{itemize}\mainindex{meta level}
\item Bindings used in run-time code must be imported ``for {\cf run},''
which is equivalent to ``for {\cf (meta 0)}.''
\item Bindings used in the body of a transformer (appearing on the
right-hand-side of a transformer binding) in run-time code must be
imported ``for {\cf expand},'' which is equivalent to
``for {\cf (meta 1)},''
\item Bindings used in the body of a transformer appearing within the body of a
transformer in run-time code must be imported ``for {\cf (meta 2)},''
and so on.
\end{itemize}

The valid phases for referencing an imported binding are determined by the enclosing
{\cf for} form, if any, in the {\cf import} form of the importing
library, in addition to the phase of the identifier in the exporting library.
An \hyper{import~set} without an enclosing {\cf for} is equivalent to
{\cf (for \hyper{import~set} run)}.

Import and export phases are combined by pairwise addition of all phase
combinations.  For example, references to an imported identifier exported
for phases $p_a$ and $p_b$ and imported for phases $q_a$, $q_b$, and $q_c$
are valid at phases $p_a+q_q$, $p_a+q_b$, $p_a+q_c$, $p_b+q_q$, $p_b+q_b$,
and $p_b+q_c$.

The import phases implicitly determine when information about a
library must be available and also when the various forms contained within
a library must be evaluated.

Every library can be characterized by expand-time information (minimally,
its imported libraries, a list of the exported keywords, a list of the
exported variables, and code to evaluate the transformer expressions) and
run-time information (minimally, code to evaluate the variable definition
right-hand-side expressions, and code to evaluate the body expressions).
The expand-time information must be available to expand references to
any exported binding, and the run-time information must be available to
evaluate references to any exported variable binding.

If any of a library's bindings are imported by another library ``for
{\cf expand}'' (or for any meta level greater than 0), both expand-time and
run-time information for the first library is made available when the second
library is expanded.
If any of a library's bindings are imported by another library ``for
{\cf run},'' the expand-time information for the first library is made available when
the second library is expanded, and the run-time information for the first
library is made available when the run-time information for the second library
is made available.

It is also relevant when the code to evaluate a library's transformer
expressions is executed and when the code to evaluate the library's
variable-definition right-hand-side expressions and body expressions is
executed.
Executing the transformer expressions is also said to be \emph{visiting}\mainindex{visiting}
the library and to executing the variable-definition right-hand-side 
expressions and body expressions as \emph{invoking}\mainindex{invoking} the library.
A library must be visited before code that uses its bindings can be
expanded, and it must be invoked before code that uses its bindings can be
executed.
Visiting or invoking a library may also trigger the visiting or
invoking of other libraries.

More precisely, visiting a library at phase $N$ causes the system to:

\begin{itemize}
\item Visit at phase $N$ any library that is imported by this library
      ``for {\cf run}'' and that is not yet visited at phase $N$.
\item Visit at phase $N+M$ any library that is imported by this
      library ``for {\cf (meta \var{M})},'' $M>0$ and that is not yet
      visited at phase $N+M$.
\item Invoke at phase $N+M$ any library that is imported by this
      library ``for {\cf (meta \var{M})},'' $M>0$ and that is not yet
      invoked at phase $N+M$.
\item Evaluate the library's transformer expressions.
\end{itemize}

The order in which imported libraries are visited and invoked is not
defined, but imported libraries must be visited and invoked before the
library's transformer expressions are evaluated.

Similarly, invoking a library at meta phase $N$ causes the system to:

\begin{itemize}
\item Invoke at phase $N$ any library that is imported by this library
      ``for {\cf run}'' and that is not yet invoked at phase $N$.
\item Evaluate the library's variable-definition right-hand-side and body
      expressions.
\end{itemize}

The order in which imported libraries are invoked is not defined, but
imported libraries must be invoked before the library's variable-definition
right-hand-side and body expressions are evaluated.

An implementation is allowed to distinguish visits of a library across
different phases or to treat a visit at any phase as a visit at all
phases.
Similarly, an implementation is allowed to distinguish invocations of a
library across different phases or to treat an invocation at any phase as
an invocation at all phases.
An implementation is further allowed to start each expansion of a
{\cf library} form by removing all library bindings above phase 0.
Thus, a portable library's meaning must not depend on whether the
invocations are distinguished or preserved across phases or {\cf library}
expansions.

\section{Primitive syntax}

After the {\cf import} form within a {\cf library} form, the forms
that constitute a library body depend on the libraries that are
imported. In particular, imported syntactic keywords determine most
of the available forms, and whether each form is a declaration,
definition, or expression. A few form types are
always available independent of imported libraries, however,
including constant literals, variable references, procedure calls,
 and macro uses.

\subsection{Primitive expression types}
\label{primitiveexpressionsection}

The entries in this section all describe expressions, which may occur
in the place of \hyper{expression} syntactic variables.  See
also section~\ref{expressionsection}

\subsubsection*{Constant literals}\unsection

\begin{entry}{%
\pproto{\hyper{constant}}{\exprtype}}\mainindex{literal}

Numerical constants, string constants, character constants, and
boolean constants evaluate ``to themselves.''

\begin{scheme}
"abc"      \ev  "abc"
145932     \ev  145932
\schtrue   \ev  \schtrue%
\end{scheme}

As noted in section~\ref{storagemodel}, the value of a literal
expression may be immutable.
\end{entry}

\subsubsection*{Variable references}\unsection
\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

An expression consisting of a variable\index{variable}
(section~\ref{variablesection}) is a variable reference.  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is a syntax violation to reference
an unbound\index{unbound} variable.

\begin{scheme}
; these examples assume the base library
; has been imported
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsubsection*{Procedure calls}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

A procedure call is written by simply enclosing in parentheses
expressions for the procedure to be called and the arguments to be
passed to it.  A form in an expression context is a procedure
call if \hyper{operator} is not an identifier bound as a syntactic keyword.

When an procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting
arguments.\mainindex{call}\mainindex{procedure call}.
\begin{scheme}%
; these examples assume the base library
; has been imported
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

If the value of \hyper{operator} is not a procedure, an exception with
condition type {\cf\&contract} is raised.

\begin{note} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.
\end{note}

\begin{note}
Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.
\end{note}

\begin{note} In many dialects of Lisp, the form {\tt
()} is a legitimate expression.  In Scheme, expressions written as
list/pair forms must have at
least one subexpression, so {\tt ()} is not a syntactically valid
expression.
\end{note}

\todo{Freeman:
I think an explanation as to why evaluation order is not specified
should be included.  It should not include any reference to parallel
evaluation.  Does any existing compiler generate better code because
the evaluation order is unspecified?  Clinger: yes: T3, MacScheme v2,
probably MIT Scheme and Chez Scheme.  But that's not the main reason
for leaving the order unspecified.}

\end{entry}

\subsection{Macros}
\label{macrosection}

Scheme programs can define and use new derived expression or
definition types, called {\em macros}.\mainindex{macro}
Program-defined expression or definition types have the syntax
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
expression type.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.  The
number of the \hyper{datum}s, and their syntax, depends on the
expression type.

Each instance of a macro is called a {\em use}\index{macro use}
of the macro.
The set of rules that specifies
how a use of a macro is transcribed into a more primitive expression
is called the {\em transformer}\index{macro transformer}
of the macro.

Macro uses can also take the form of improper lists
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo . \hyper{datum})%
\end{scheme}
It is also possible that the keyword reference appears as an
\hyper{identifier}s (section~\ref{transformerssection}), or as the
second subform of a {\cf set!} form (see
section~\ref{make-variable-transformer}:

\begin{scheme}
(set! \hyper{keyword} \hyper{datum})%
\end{scheme}

The macro definition facility consists of two parts:

\begin{itemize}
\item A set of forms ({\cf define-syntax},
  section~\ref{define-syntax}, {\cf let-syntax} and {\cf
    letrec-syntax}, section~\ref{let-syntax}) used to establish that certain identifiers
are macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined, and

\item a facility (called {\cf syntax-case}; see
  chapter~\ref{syntaxcasechapter}) for defining macro transformers as
  Scheme code, and a derived facility (called {\cf syntax-rules}; see
  section~\ref{syntaxrulessection}) providing a pattern language for
  specifying macro transformers.
\end{itemize}

Keywords occupy the same name space as variables, i.e., within the same
scope, an identifier can be bound as a variable or keyword, or neither, but
not both.
The syntactic keyword of a macro may shadow variable bindings, and local
variable bindings may shadow keyword bindings.  \index{keyword}  All macros
defined using {\cf syntax-rules} are ``hygienic'' and ``referentially
transparent'' and thus preserve Scheme's lexical scoping~\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}:
\mainindex{hygienic}
\mainindex{referentially transparent}

\begin{itemize}

\item If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.

\end{itemize}

\section{Examples}

Examples for various \hyper{import~spec}s and \hyper{export~spec}s:

\begin{scheme}
(library (stack)
  (export make push! pop! empty!)
  (import (r6rs))

  (define (make) (list '()))
  (define (push! s v) (set-car! s (cons v (car s))))
  (define (pop! s) (let ([v (caar s)])
                     (set-car! s (cdar s))
                     v))
  (define (empty! s) (set-car! s '())))

(library (balloons)
  (export make push pop)
  (import (r6rs))

  (define (make w h) (cons w h))
  (define (push b amt)
    (cons (- (car b) amt) (+ (cdr b) amt)))
  (define (pop b) (display "Boom! ") 
                  (display (* (car b) (cdr b))) 
                  (newline)))

(library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import (r6rs)
          (only (stack)
                make push! pop!) ; not empty!
          (add-prefix (balloons) balloon:))

  ;; Creates a party as a stack of balloons,
  ;; starting with two balloons
  (define (make-party)
    (let ([s (make)]) ; from stack
      (push! s (balloon:make 10 10))
      (push! s (balloon:make 12 9))
      s))
  (define (party-pop! p)
    (balloon:pop (pop! p))))


(library (main)
  (export)
  (import (r6rs) (party))

  (define p (make-party))
  (pop! p)        ; displays "Boom! 108"
  (push! p (push (make 5 5) 1))
  (pop! p))       ; displays "Boom! 24"%
\end{scheme}

Examples for macros and phases:

\begin{schemenoindent}
(library (id-stuff)
  (export find-dup)
  (import (r6rs))

  (define (find-dup l)
    (and (pair? l)
         (let loop ((rest (cdr l)))
           (cond
            [(null? rest) (find-dup (cdr l))]
            [(bound-identifier=? (car l) (car rest)) 
                                 (car rest)]
            [else (loop (cdr rest))])))))

(library (values-stuff)
  (export (for mvlet expand run))
  (import (r6rs) (import (for (id-stuff) expand)))

  (define-syntax mvlet
    (lambda (stx)
      (syntax-case stx ()
        [(\_ [(id ...) expr] body0 body ...)
         (not (find-dup
                (syntax-object->list
                  (syntax (id ...)))))
         (syntax
           (call-with-values
               (lambda () expr) 
             (lambda (id ...) body0 body ...)))]))))

(library (let-div)
  (export let-div)
  (import (r6rs) (mvlet))

  (define (quotient+remainder n d)
    (let ([q (quotient n d)])
      (values q (- n (* q d)))))
  (define-syntax let-div
    (syntax-rules ()
     [(\_ n d (q r) body0 body ...)
      (mvlet [(q r) (quotient+remainder n d)]
        body0 body ...)])))%
\end{schemenoindent}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
