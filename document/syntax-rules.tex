\chapter{\tt{syntax-rules}}
\label{syntaxruleschapter}

A \hyper{transformer spec} has the following form:

\begin{entry}{%
\proto{syntax-rules}{ \hyper{literals} \hyper{syntax rule} \dotsfoo}{}}

\syntax
\hyper{Literals} is a list of identifiers and each \hyper{syntax rule}
should be of the form
\begin{scheme}
(\hyper{pattern} \hyper{template})%
\end{scheme}
The \hyper{pattern} in a \hyper{syntax rule} is a list \hyper{pattern}
that begins with the keyword for the macro.

A \hyper{pattern} is either an identifier, a constant, or one of the
following
\begin{scheme}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis})%
\end{scheme}
and a template is either an identifier, a constant, or one of the following
\begin{scheme}
(\hyper{element} \ldots)
(\hyper{element} \hyper{element} \ldots . \hyper{template})
\#(\hyper{element} \ldots)%
\end{scheme}
where an \hyper{element} is a \hyper{template} optionally
followed by an \hyper{ellipsis} and
an \hyper{ellipsis} is the identifier ``{\cf ...}'' (which cannot be used as
an identifier in either a template or a pattern).\schindex{...}

\semantics An instance of {\cf syntax-rules} produces a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
{\cf syntax-rules} is matched against the patterns contained in the
\hyper{syntax rule}s, beginning with the leftmost \hyper{syntax rule}.
When a match is found, the macro use is transcribed hygienically
according to the template.

An identifier that appears in the pattern of a \hyper{syntax rule} is
a {\em pattern variable}, unless it is the keyword that begins the pattern,
is listed in \hyper{literals}, or is the identifier ``{\cf ...}''.
Pattern variables match arbitrary input elements and
are used to refer to elements of the input in the template.  It is an
error for the same pattern variable to appear more than once in a
\hyper{pattern}.

The keyword at the beginning of the pattern in a
\hyper{syntax rule} is not involved in the matching and
is not considered a pattern variable or literal identifier.

\begin{rationale}
The scope of the keyword is determined by the expression or syntax
definition that binds it to the associated macro transformer.
If the keyword were a pattern variable or literal
identifier, then
the template that follows the pattern would be within its scope
regardless of whether the keyword were bound by {\cf let-syntax}
or by {\cf letrec-syntax}.
\end{rationale}

Identifiers that appear in \hyper{literals} are interpreted as literal
identifiers to be matched against corresponding subforms of the input.
A subform
in the input matches a literal identifier if and only if it is an
identifier
and either both its occurrence in the macro expression and its
occurrence in the macro definition have the same lexical binding, or
the two identifiers are equal and both have no lexical binding.

% [Bill Rozas suggested the term "noise word" for these literal
% identifiers, but in their most interesting uses, such as a setf
% macro, they aren't noise words at all. -- Will]

A subpattern followed by {\cf ...} can match zero or more elements of the
input.  It is an error for {\cf ...} to appear in \hyper{literals}.
Within a pattern the identifier {\cf ...} must follow the last element of
a nonempty sequence of subpatterns.

More formally, an input form $F$ matches a pattern $P$ if and only if:

\begin{itemize}
\item $P$ is a non-literal identifier; or

\item $P$ is a literal identifier and $F$ is an identifier with the same
      binding; or

\item $P$ is a list {\cf ($P_1$ $\dots$ $P_n$)} and $F$ is a
      list of $n$
      forms that match $P_1$ through $P_n$, respectively; or

\item $P$ is an improper list
      {\cf ($P_1$ $P_2$ $\dots$ $P_n$ . $P_{n+1}$)}
      and $F$ is a list or
      improper list of $n$ or more forms that match $P_1$ through $P_n$,
      respectively, and whose $n$th ``cdr'' matches $P_{n+1}$; or

\item $P$ is of the form
      {\cf ($P_1$ $\dots$ $P_n$ $P_{n+1}$ \meta{ellipsis})}
      where \meta{ellipsis} is the identifier {\cf ...}
      and $F$ is
      a proper list of at least $n$ forms, the first $n$ of which match
      $P_1$ through $P_n$, respectively, and each remaining element of $F$
      matches $P_{n+1}$; or

\item $P$ is a vector of the form {\cf \#($P_1$ $\dots$ $P_n$)}
      and $F$ is a vector
      of $n$ forms that match $P_1$ through $P_n$; or

\item $P$ is of the form
      {\cf \#($P_1$ $\dots$ $P_n$ $P_{n+1}$ \meta{ellipsis})}
      where \meta{ellipsis} is the identifier {\cf ...}
      and $F$ is a vector of $n$
      or more forms the first $n$ of which match
      $P_1$ through $P_n$, respectively, and each remaining element of $F$
      matches $P_{n+1}$; or

\item $P$ is a datum and $F$ is equal to $P$ in the sense of
      the {\cf equal?} procedure.
\end{itemize}

It is an error to use a macro keyword, within the scope of its
binding, in an expression that does not match any of the patterns.

When a macro use is transcribed according to the template of the
matching \hyper{syntax rule}, pattern variables that occur in the
template are replaced by the subforms they match in the input.
Pattern variables that occur in subpatterns followed by one or more
instances of the identifier
{\cf ...} are allowed only in subtemplates that are
followed by as many instances of {\cf ...}.
They are replaced in the
output by all of the subforms they match in the input, distributed as
indicated.  It is an error if the output cannot be built up as
specified.

%%% This description of output construction is very vague.  It should
%%% probably be formalized, but that is not easy...

Identifiers that appear in the template but are not pattern variables
or the identifier
{\cf ...} are inserted into the output as literal identifiers.  If a
literal identifier is inserted as a free identifier then it refers to the
binding of that identifier within whose scope the instance of
{\cf syntax-rules} appears.
If a literal identifier is inserted as a bound identifier then it is
in effect renamed to prevent inadvertent captures of free identifiers.

As an example, if \ide{let} and \ide{cond} are defined as in
section~\ref{derivedsection} then they are hygienic (as required) and
the following is not an error.

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

The macro transformer for {\cf cond} recognizes {\cf =>}
as a local variable, and hence an expression, and not as the
top-level identifier {\cf =>}, which the macro transformer treats
as a syntactic keyword.  Thus the example expands into

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

instead of

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

which would result in an invalid procedure call.

\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
