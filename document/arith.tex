\chapter{Arithmetic}
\label{numberchapter}
\index{number}

This chapter describes Scheme's libraries for more specialized
numerical operations: fixnum and flonum arithmetic, as well as generic
exact and generic inexact arithmetic.

\section{Fixnums}
\label{fixnumssection}

Every implementation must define its fixnum range as a closed
interval
%
\begin{displaymath}
[-2^{w-1}, 2^{w-1} - 1]
\end{displaymath}
%
such that $w$ is a a (mathematical) integer $w \geq 24$.  Every
mathematical integer within an implementation's fixnum range must
correspond to an exact integer that is representable within the
implementation.
A fixnum is an exact integer whose value lies within this
fixnum range.

This section specifies two kinds of operations on fixnums.  Operations
whose names begin with {\cf fixnum} perform arithmetic modulo
$2^{w}$.  Operations whose names begin with {\cf fx}
perform integer arithmetic on their fixnum arguments, but raise an
exception with condition type {\cf\&implementation-restriction} 
if the result is not a fixnum.

\begin{rationale}
The operations whose names begin with {\cf fixnum}
implement arithmetic on a quotient ring of the integers,
but their results are not the same in every implementation
because the particular ring is parameterized by $w$.
The operations whose names begin with {\cf fx} do
not have as nice a closure property, and the arguments that
cause them to raise an exception are not the same in every
implementation, but any results they return without
raising an exception are the same in all implementations.
\end{rationale}

Some operations (e.g.\ {\cf fixnum<} and {\cf fx<}) behave the same in
both sets.

\begin{rationale}
Duplication of names reduces bias toward either set,
and saves programmers from having to remember which
names are supplied.
\end{rationale}

This section uses \var{fx}, \vari{fx} and \varii{fx} as parameter
names for arguments that must be fixnums.

\subsection{Quotient-ring fixnum operations}

This section describes the \deflibrary{r6rs arithmetic fixnum} library.

\begin{entry}{%
\proto{fixnum?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an exact
integer within the fixnum range, and
otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{%
\proto{fixnum-width}{}{procedure}
\proto{least-fixnum}{}{procedure}
\proto{greatest-fixnum}{}{procedure}}

These procedures return $w$,
$-2^{w-1}$ and $2^{w-1} - 1$: the
width, minimum and the maximum value of the fixnum range, respectively.
\end{entry}

\begin{entry}{%
\proto{fixnum=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fixnum>?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fixnum<?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fixnum>=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fixnum<=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{fixnum-zero?}{ fx}{procedure}
\proto{fixnum-positive?}{ fx}{procedure}
\proto{fixnum-negative?}{ fx}{procedure}
\proto{fixnum-odd?}{ fx}{procedure}
\proto{fixnum-even?}{ fx}{procedure}}

These numerical predicates test a fixnum for a particular property,
returning \schtrue{} or \schfalse{}.  The five properties tested by
these procedures are: whether the number is zero, greater than zero,
less than zero, odd, or even.
\end{entry}

\begin{entry}{%
\proto{fixnum-max}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}
\proto{fixnum-min}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
\end{entry}

\begin{entry}{%
\proto{fixnum+}{ \vari{fx} \dotsfoo}{procedure}
\proto{fixnum*}{ \vari{fx} \dotsfoo}{procedure}}

These procedures return the unique fixnum that is congruent mod $2^w$
to the sum or product of their arguments.
\end{entry}

\begin{entry}{%
\proto{fixnum-}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}
\rproto{fixnum-}{ fx}{procedure}}

With two or more arguments, this procedure returns the unique fixnum
that is congruent mod $2^w$ to the difference of its arguments,
associating to the left.  With one argument, however, it returns the
the unique fixnum that is congruent mod $2^w$ to the additive inverse
of its argument.
\end{entry}

\begin{entry}{%
\proto{fixnum-div+mod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-div}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-mod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-div0+mod0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-div0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-mod0}{ \vari{fx} \varii{fx}}{procedure}}

{\varii{fx} must be nonzero.}
These procedures implement number-theoretic integer division modulo
$2^w$.  Each procedure returns the unique fixnum(s) congruent modulo
$2^w$ to the result(s) specified in report section~\ref{report:integerdivision}.

\begin{scheme}
(fixnum-div \vari{ex} \varii{ex})         \ev \(\vari{ex}~\mathrm{div}~\varii{ex}\)
(fixnum-mod \vari{ex} \varii{ex})         \ev \(\vari{ex}~\mathrm{mod}~\varii{ex}\)
(fixnum-div+mod \vari{ex} \varii{ex})     \lev \(\vari{ex}~\mathrm{div}~\varii{ex}, \vari{ex}~\mathrm{mod}~\varii{ex}\)\\\>\>; two return values
(fixnum-div0 \vari{ex} \varii{ex})        \ev \(\vari{ex}~\mathrm{div}\sb{0}~\varii{ex}\)
(fixnum-mod0 \vari{ex} \varii{ex})        \ev \(\vari{ex}~\mathrm{mod}\sb{0}~\varii{ex}\)
(fixnum-div0+mod0 \vari{ex} \varii{ex})   \lev \(\vari{ex} \vari{ex}~\mathrm{div}\sb{0}~\varii{ex}, \vari{ex}~\mathrm{mod}\sb{0}~\varii{ex}\)\\\>\>; two return values%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum+/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
%
\begin{scheme}
(let* ((s (+ \vari{fx} \varii{fx} \variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))%
\end{scheme}

\begin{note}
The results returned by the
{\cf fixnum+/carry},
{\cf fixnum-/carry}, and
{\cf fixnum*/carry}
procedures depend upon the precision $w$,
so there are no {\cf fx} equivalents to these procedures.
\end{note}
\end{entry}

\begin{entry}{%
\proto{fixnum-/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
%
\begin{scheme}
(let* ((d (- \vari{fx} \varii{fx} \variii{fx}))
       (d0 (mod0 d (expt 2 (fixnum-width))))
       (d1 (div0 d (expt 2 (fixnum-width)))))
  (values d0 d1))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum*/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
\begin{scheme}
(let* ((s (+ (* \vari{fx} \varii{fx}) \variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-not}{ \var{fx}}{procedure}}

Returns the unique fixnum that is congruent
mod $2^w$ to the one's-complement of \var{fx}.
\end{entry}

\begin{entry}{%
\proto{fixnum-and}{ \vari{fx} \dotsfoo}{procedure}
\proto{fixnum-ior}{ \vari{fx} \dotsfoo}{procedure}
\proto{fixnum-xor}{ \vari{fx} \dotsfoo}{procedure}}

These procedures return the fixnum that is the bit-wise ``and'',
``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the fixnum (either $-1$ or $0$) that acts as identity for the
operation.
\end{entry}

\begin{entry}{%
\proto{fixnum-if}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the fixnum result of the following
computation:
\begin{scheme}
(fixnum-ior (fixnum-and \vari{fx} \varii{fx})
            (fixnum-and (fixnum-not \vari{fx}) \variii{fx}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-bit-count}{ \var{fx}}{procedure}}

If \var{fx} is non-negative, this procedure returns the
number of 1 bits in the two's complement representation of \var{fx}.
Otherwise it returns the number of 0 bits in the two's complement
representation of \var{fx}.
\end{entry}

\begin{entry}{%
\proto{fixnum-length}{ \var{fx}}{procedure}}

Returns the fixnum result of the following
computation:
\begin{scheme}
(do ((result 0 (+ result 1))
     (bits (if (fixnum-negative? \var{fx})
               (fixnum-not \var{fx})
               \var{fx})
           (fixnum-logical-shift-right bits 1)))
    ((fixnum-zero? bits)
     result))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-first-bit-set}{ \var{fx}}{procedure}}

Returns the index of the least significant $1$ bit in
the two's complement representation of \var{fx}.  If 
\var{fx} is $0$, then $-1$ is returned.
%
\begin{scheme}
(fixnum-first-bit-set 0)        \ev  -1
(fixnum-first-bit-set 1)        \ev  0
(fixnum-first-bit-set -4)       \ev  2%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-bit-set?}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative.}  The {\cf fixnum-bit-set?} procedure returns the
fixnum result of the following computation:
\begin{scheme}
(not
  (fixnum-zero?
    (fixnum-and \vari{fx}
                (fixnum-logical-shift-left 1 \varii{fx}))))%
\end{scheme}
%
\end{entry}

\begin{entry}{%
\proto{fixnum-copy-bit}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative.}  The {\cf fixnum-copy-bit} procedure
returns the fixnum result of the following computation:
\begin{scheme}
(let* ((mask (fixnum-logical-shift-left 1 \varii{fx})))
  (fixnum-if mask
             (fixnum-logical-shift-left \variii{fx} \varii{fx})
             \vari{fx}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-bit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative.}  The {\cf fixnum-bit-field} procedure
returns the fixnum result of the following computation:
%
\begin{scheme}
(let* ((mask (fixnum-not
              (fixnum-logical-shift-left -1 \variii{fx}))))
  (fixnum-logical-shift-right (fixnum-and \vari{fx} mask)
                              \varii{fx}))%
\end{scheme}
%
\end{entry}

\begin{entry}{%
\proto{fixnum-copy-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative.} The
{\cf fixnum-copy-bit-field} procedure
returns the fixnum result of the following computation:
\begin{scheme}
(let* ((to    \vari{fx})
       (start \varii{fx})
       (end   \variii{fx})
       (from  \variv{fx})
       (mask1 (fixnum-logical-shift-left -1 start))
       (mask2 (fixnum-not
               (fixnum-logical-shift-left -1 end)))
       (mask (fixnum-and mask1 mask2)))
  (fixnum-if mask
             (fixnum-logical-shift-left from start)
             to))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-arithmetic-shift}{ \vari{fx} \varii{fx}}{procedure}}

Returns the unique fixnum that is congruent mod $2^w$ to the result of
the following computation:
%
\begin{scheme}
(exact-floor (* \vari{fx} (expt 2 \varii{fx})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-arithmetic-shift-left}{ \vari{fx} \varii{fx}}{procedure}
\proto{fixnum-arithmetic-shift-right}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative.}  {\cf
  fixnum-arithmetic-shift-left} returns the same result as {\cf
  fixnum-arithmetic-shift}, and {\cf (fixnum-arithmetic-shift-right
\vari{fx} \varii{fx})} returns the same result as
{\cf (fixnum-arithmetic-shift \vari{fx} (fixnum- \varii{fx}))}.
\end{entry}

\begin{entry}{%
\proto{fixnum-logical-shift-left}{ \vari{fx} \varii{fx}}{procedure}}

Behaves the same as {\cf fixnum-arithmetic-shift-left}.
\end{entry}

\begin{entry}{%
\proto{fixnum-logical-shift-right}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative.}  The {\cf fixnum-logical-shift-right} procedure returns
the result of the following computation:
\begin{scheme}
(let* ((n       \vari{fx})
       (shift   \varii{fx})
       (shifted
         (fixnum-arithmetic-shift-right n shift)))
  (let* ((mask-width
           (fixnum-
             (fixnum-width)
             (fixnum-mod shift (fixnum-width))))
         (mask (fixnum-not
                (fixnum-logical-shift-left
                  -1 mask-width))))
    (fixnum-and shifted mask)))%
\end{scheme}
%
\begin{note}
The results of {\cf fixnum-logical-shift-left}
and {\cf fixnum-logical-shift-left}
can depend upon the precision $w$,
so they have no {\cf fx} equivalents.
\end{note}
\end{entry}

\begin{entry}{%
\proto{fixnum-rotate-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx}, \variii{fx}, and \variv{fx} must be non-negative.}
The {\cf fixnum-rotate-bit-field} procedure returns the result of the following computation:
\begin{scheme}
(let* ((n     \vari{fx})
       (start \varii{fx})
       (end   \variii{fx})
       (count \variv{fx})
       (width (fixnum- end start)))
  (if (fixnum-positive? width)
      (let* ((count (fixnum-mod count width))
             (field0
               (fixnum-bit-field n start end))
             (field1
               (fixnum-logical-shift-left
                 field0 count))
             (field2
               (fixnum-logical-shift-right
                 field0 (fixnum- width count)))
             (field (fixnum-ior field1 field2)))
        (fixnum-copy-bit-field n start end field))
      n))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fixnum-reverse-bit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the fixnum obtained from \vari{fx} by reversing the
bit field specified by \varii{fx} and \variii{fx}.
\begin{scheme}
(fixnum-reverse-bit-field \sharpsign{}b1010010 1 4)    \lev  88 ; \sharpsign{}b1011000
(fixnum-reverse-bit-field \sharpsign{}b1010010 91 -4)  \lev  82 ; \sharpsign{}b1010010%
\end{scheme}
\end{entry}

\subsection{Signalling fixnum operations}

This section describes the \deflibrary{r6rs arithmetic fx} library.

\begin{entry}{%
\rproto{fixnum?}{ obj}{procedure}}

This is the same as {\cf fixnum?} in the \library{r6rs
  arithmetic fixnum} library.
\end{entry}

\begin{entry}{%
\rproto{fixnum-width}{}{procedure}
\rproto{least-fixnum}{}{procedure}
\rproto{greatest-fixnum}{}{procedure}}

These are the same as {\cf fixnum-width},
{\cf least-fixnum}, and {\cf greatest-fixnum} in the \library{r6rs
  arithmetic fixnum} library,
respectively.
\end{entry}

\begin{entry}{%
\proto{fx=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx>?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx<?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx>=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx<=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}}

These procedures perform the same operations as {\cf fixnum=?}, {\cf
  fixnum>?}, {\cf fixnum<?}, {\cf fixnum>=?}, and {\cf fixnum<=?},
respectively.
\end{entry}

\begin{entry}{%
\proto{fxzero?}{ fx}{procedure}
\proto{fxpositive?}{ fx}{procedure}
\proto{fxnegative?}{ fx}{procedure}
\proto{fxodd?}{ fx}{procedure}
\proto{fxeven?}{ fx}{procedure}}

These procedures perform the same operations as {\cf fixnum-zero?},
{\cf fixnum-positive?}, {\cf fixnum-negative?}, {\cf fixnum-odd?}, and
{\cf fixnum-even?}, respectively.
\end{entry}

\begin{entry}{%
\proto{fxmax}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}
\proto{fxmin}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}}

These procedures perform the same operations as {\cf fixnum-max},
and {\cf fixnum-min}, respectively.
\end{entry}

\begin{entry}{%
\proto{fx+}{ \vari{fx} \varii{fx}}{procedure}
\proto{fx*}{ \vari{fx} \varii{fx}}{procedure}}

These procedures return the sum or product of their arguments,
provided that sum or product is a fixnum.  An exception with condition
type {\cf\&implementation-restriction} is raised if
that sum or product is not a fixnum.

\begin{rationale}
These procedures are restricted to two arguments because their
generalizations to three or more arguments would require
precision proportional to the number of arguments.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{fx-}{ \vari{fx} \varii{fx}}{procedure}
\rproto{fx-}{ fx}{procedure}}

With two arguments, this procedure returns the difference of its
arguments, provided that difference is a fixnum.

With one argument, this procedure returns the additive
inverse of its argument, provided that integer is a
fixnum.

An exception with condition type {\cf\&contract} is raised if the
mathematically correct result of this procedure is not a fixnum.

\begin{scheme}
(fx- (least-fixnum))  \lev  \exception{\&contract}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxdiv+mod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxmod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv0+mod0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxmod0}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be nonzero.}
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\ref{report:integerdivision}.  An exception with
condition type {\cf\&implementation-restriction} is raised if a result
specified by that section is not a fixnum.

\begin{scheme}
(fxdiv \vari{ex} \varii{ex})         \ev \(\vari{ex}~\mathrm{div}~\varii{ex}\)
(fxmod \vari{ex} \varii{ex})         \ev \(\vari{ex}~\mathrm{mod}~\varii{ex}\)
(fxdiv+mod \vari{ex} \varii{ex})     \lev \(\vari{ex}~\mathrm{div}~\varii{ex}, \vari{ex}~\mathrm{mod}~\varii{ex}\)\\\>\>; two return values
(fxdiv0 \vari{ex} \varii{ex})        \ev \(\vari{ex}~\mathrm{div}\sb{0}~\varii{ex}\)
(fxmod0 \vari{ex} \varii{ex})        \ev \(\vari{ex}~\mathrm{mod}\sb{0}~\varii{ex}\)
(fxdiv0+mod0 \vari{ex} \varii{ex})   \lev \(\vari{ex} \vari{ex}~\mathrm{div}\sb{0}~\varii{ex}, \vari{ex}~\mathrm{mod}\sb{0}~\varii{ex}\)\\\>\>; two return values%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxnot}{ \var{fx}}{procedure}}

This performs the same operation as {\cf fixnum-not}.
\end{entry}

\begin{entry}{%
\proto{fxand}{ \vari{fx} \dotsfoo}{procedure}
\proto{fxior}{ \vari{fx} \dotsfoo}{procedure}
\proto{fxxor}{ \vari{fx} \dotsfoo}{procedure}}

These procedures perform the same operations as {\cf fixnum-and},
{\cf fixnum-ior}, and {\cf fixnum-xor}, respectively.
\end{entry}

\begin{entry}{%
\proto{fxif}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

This performs the same operation as {\cf fixnum-if}.
\end{entry}

\begin{entry}{%
\proto{fxbit-count}{ \var{fx}}{procedure}}

This performs the same operation as {\cf fixnum-bit-count}.
\end{entry}

\begin{entry}{%
\proto{fxlength}{ \var{fx}}{procedure}}

This performs the same operation as {\cf fixnum-length}.
\end{entry}

\begin{entry}{%
\proto{fxfirst-bit-set}{ \var{fx}}{procedure}}

This performs the same operation as {\cf fixnum-first-bit-set}.
\end{entry}

\begin{entry}{%
\proto{fxbit-set?}{ \var{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative and less than {\cf
  (fixnum-width)}.}  The {\cf fxbit-set?} procedure
returns the same result as {\cf fixnum-bit-set?}.
\end{entry}

\begin{entry}{%
\proto{fxcopy-bit}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative and less than {\cf
  (fixnum-width)}. \variii{Fx} must be 0 or
1.}  The {\cf fxcopy-bit} procedure returns the same result as {\cf
  fixnum-copy-bit}.
\end{entry}

\begin{entry}{%
\proto{fxbit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
    equal to \variii{fx}.}  The {\cf fxbit-field} procedure returns the same result
  returned by {\cf fixnum-bit-field}.
\end{entry}

\begin{entry}{%
\proto{fxcopy-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
    equal to \variii{fx}.}  The {\cf fxcopy-bit-field} procedure returns the same result
  returned by {\cf fixnum-copy-bit-field}.
\end{entry}

\begin{entry}{%
\proto{fxarithmetic-shift}{ \vari{fx} \varii{fx}}{procedure}}

\domain{The absolute value of the \varii{fx} must be less than 
{\cf (fixnum-width)}.}  If
%
\begin{scheme}
(exact-floor (* \vari{fx} (expt 2 \varii{fx})))%
\end{scheme}
%
is a fixnum, then that fixnum is returned.  Otherwise an exception
with condition type {\cf\&implementation-restriction} is
raised.
\end{entry}

\begin{entry}{%
\proto{fxarithmetic-shift-left}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxarithmetic-shift-right}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative.} {\cf
  fxarithmetic-shift-left} behaves the same as {\cf
  fxarithmetic-shift}, and {\cf (fxarithmetic-shift-right \vari{fx}
  \varii{fx})} behaves the same as {\cf (fxarithmetic-shift \vari{fx}
  (fixnum- \varii{fx}))}.
\end{entry}

\begin{entry}{%
\proto{fxrotate-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx}, \variii{fx}, and \variv{fx} must be non-negative
  and less than {\cf (fixnum-width)}.  \variv{Fx} must be less than
  the difference between \variii{fx} and \variii{fx}.}  The {\cf fxrotate-bit-field} procedure
returns the same result as the {\cf fixnum-rotate-bit-field}
procedure.
\end{entry}

\begin{entry}{%
\proto{fxreverse-bit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
  equal to \variii{fx}.}  The {\cf fxreverse-bit-field} procedure returns the same result as
the {\cf fixnum-reverse-bit-field} procedure.
\end{entry}

\section{Flonums}
\label{flonumssection}

This section describes the \deflibrary{r6rs arithmetic flonum} library.

This section uses \var{fl}, \vari{fl} and \varii{fl} as
parameter names for arguments that must be flonums, and \var{ifl},
\vari{ifl} and \varii{ifl} as parameter names for arguments that 
must be integer-valued flonums, i.e. flonums for which the
{\cf integer-valued?} predicate returns true.

\begin{entry}{%
\proto{flonum?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a flonum, and
otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{%
\proto{fl=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl<?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl<=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl>?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl>=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
\schfalse{} otherwise.  These
predicates are required to be transitive.

\begin{scheme}
(fl= +inf.0 +inf.0)           \ev  \schtrue{}
(fl= -inf.0 +inf.0)           \ev  \schfalse{}
(fl= -inf.0 -inf.0)           \ev  \schtrue{}
(fl= 0.0 -0.0)                \ev  \schtrue{}
(fl< 0.0 -0.0)                \ev  \schfalse{}
(fl= +nan.0 \var{fl})               \ev  \schfalse{}
(fl< +nan.0 \var{fl})               \ev  \schfalse{}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flinteger?}{ fl}{procedure}
\proto{flzero?}{ fl}{procedure}
\proto{flpositive?}{ fl}{procedure}
\proto{flnegative?}{ fl}{procedure}
\proto{flodd?}{ ifl}{procedure}
\proto{fleven?}{ ifl}{procedure}
\proto{flfinite?}{ fl}{procedure}
\proto{flinfinite?}{ fl}{procedure}
\proto{flnan?}{ fl}{procedure}}

These numerical predicates test a flonum for a particular property,
returning \schtrue{} or \schfalse{}.
The {\cf flinteger?} procedure tests whether the number is an integer,
{\cf flzero?} tests whether
it is {\cf fl=?} to zero, {\cf flpositive?} tests whether it is greater
than zero, {\cf flnegative?} tests whether it is less
than zero, {\cf flodd?} tests whether it is odd, 
{\cf fleven?} tests whether it is even,
{\cf flfinite?} tests whether it is not an infinity and not a NaN,
{\cf flinfinite?} tests whether it is an infinity, and
{\cf flnan?} tests whether it is a NaN.

\begin{scheme}
(flnegative? -0.0)   \ev \schfalse{}
(flfinite? +inf.0)   \ev \schfalse{}
(flfinite? 5.0)      \ev \schtrue{}
(flinfinite? 5.0)    \ev \schfalse{}
(flinfinite? +inf.0) \ev \schtrue{}%
\end{scheme}

\begin{note}
{\cf (flnegative? -0.0)} must return \schfalse{},
else it would lose the correspondence with
{\cf (fl< -0.0 0.0)}, which is \schfalse{}
according to the IEEE standards.
\end{note}
\end{entry}

\begin{entry}{%
\proto{flmax}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\proto{flmin}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
\end{entry}

\begin{entry}{%
\proto{fl+}{ \vari{fl} \dotsfoo}{procedure}
\proto{fl*}{ \vari{fl} \dotsfoo}{procedure}}

These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations
that represent flonums as IEEE binary floating point numbers, the
meaning of ``best'' is defined by the IEEE standards.)

\begin{scheme}
(fl+ +inf.0 -inf.0)      \ev  +nan.0
(fl+ +nan.0 \var{fl})          \ev  +nan.0
(fl* +nan.0 \var{fl})          \ev  +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fl-}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\rproto{fl-}{ fl}{procedure}
\proto{fl/}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\rproto{fl/}{ fl}{procedure}}

With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.  With one argument, however, they return the additive or
multiplicative flonum inverse of their argument.  In general, they
should return the flonum that best approximates the mathematical
difference or quotient.  (For implementations that represent flonums
as IEEE binary floating point numbers, the meaning of ``best'' is
reasonably well-defined by the IEEE standards.)

\begin{scheme}
(fl- +inf.0 +inf.0)      \ev  +nan.0%
\end{scheme}

For undefined quotients, {\cf fl/} behaves as specified by the
IEEE standards:

\begin{scheme}
(fl/ 1.0 0.0)  \ev +inf.0
(fl/ -1.0 0.0) \ev -inf.0
(fl/ 0.0 0.0)  \ev +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flabs}{ fl}{procedure}}

Returns the absolute value of \var{fl}.
\end{entry}

\begin{entry}{%
\proto{fldiv+mod}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv}{ \vari{fl} \varii{fl}}{procedure}
\proto{flmod}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv0+mod0}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv0}{ \vari{fl} \varii{fl}}{procedure}
\proto{flmod0}{ \vari{fl} \varii{fl}}{procedure}}

These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\ref{report:integerdivision}.  For zero divisors, these
procedures may return a NaN or some meaningless flonum.

\begin{scheme}
(fldiv \vari{fl} \varii{fl})         \ev \(\vari{fl}~\mathrm{div}~\varii{fl}\)
(flmod \vari{fl} \varii{fl})         \ev \(\vari{fl}~\mathrm{mod}~\varii{fl}\)
(fldiv+mod \vari{fl} \varii{fl})     \lev \(\vari{fl}~\mathrm{div}~\varii{fl}, \vari{fl}~\mathrm{mod}~\varii{fl}\)\\\>\>; two return values
(fldiv0 \vari{fl} \varii{fl})        \ev \(\vari{fl}~\mathrm{div}_0~\varii{fl}\)
(flmod0 \vari{fl} \varii{fl})        \ev \(\vari{fl}~\mathrm{mod}_0~\varii{fl}\)
(fldiv0+mod0 \vari{fl} \varii{fl})   \lev \(\vari{fl}~\mathrm{div}_0~\varii{fl}, \vari{fl}~\mathrm{mod}_0~\varii{fl}\)\\\>\>; two return values%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{flnumerator}{ fl}{procedure}
\proto{fldenominator}{ fl}{procedure}}

These procedures return the numerator or denominator of \var{fl}
as a flonum; the result is computed as if \var{fl} was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.
%
\begin{scheme}
(flnumerator +inf.0)           \ev  +inf.0
(flnumerator -inf.0)           \ev  -inf.0
(fldenominator +inf.0)         \ev  1.0
(fldenominator -inf.0)         \ev  1.0
(flnumerator 0.75)             \ev  3.0 ; example
(fldenominator 0.75)           \ev  4.0 ; example%
\end{scheme}

The following behavior is strongly recommended but not required:

\begin{scheme}
(flnumerator -0.0)             \ev -0.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flfloor}{ fl}{procedure}
\proto{flceiling}{ fl}{procedure}
\proto{fltruncate}{ fl}{procedure}
\proto{flround}{ fl}{procedure}}

These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.  For such arguments, {\cf flfloor} returns the
largest integral flonum not larger than \var{fl}.  The {\cf flceiling}
procedure
returns the smallest integral flonum not smaller than \var{fl}.
The {\cf fltruncate} procedure returns the integral flonum closest to \var{fl} whose
absolute value is not larger than the absolute value of \var{fl}.
The {\cf flround} procedure returns the closest integral flonum to \var{fl},
rounding to even when \var{fl} is halfway between two integers.

\begin{rationale}
The {\cf flround} procedure rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

Although infinities and NaNs are not integers, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN:

\begin{scheme}
(flfloor +inf.0)                       \ev  +inf.0
(flceiling -inf.0)                     \ev  -inf.0
(fltruncate +nan.0)                    \ev  +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flexp}{ fl}{procedure}
\proto{fllog}{ fl}{procedure}
\rproto{fllog}{ \vari{fl} \varii{fl}}{procedure}
\proto{flsin}{ fl}{procedure}
\proto{flcos}{ fl}{procedure}
\proto{fltan}{ fl}{procedure}
\proto{flasin}{ fl}{procedure}
\proto{flacos}{ fl}{procedure}
\proto{flatan}{ fl}{procedure}
\rproto{flatan}{ \vari{fl} \varii{fl}}{procedure}}

These procedures compute the usual transcendental functions.  
The {\cf flexp} procedure computes the base-$e$ exponential of \var{fl}.
The {\cf fllog} procedure with a single argument computes the natural logarithm of
\var{fl} (not the base ten logarithm); {\cf (fllog \vari{fl}
  \varii{fl})} computes the base-\varii{fl} logarithm of \vari{fl}.
The {\cf flasin}, {\cf flacos}, and {\cf flatan} procedures compute arcsine,
arccosine, and arctangent, respectively.  {\cf (flatan \vari{fl}
  \varii{fl})} computes the arc tangent of \vari{fl}/\varii{fl}.

See report section~\ref{report:transcendentalfunctions} for the underlying
mathematical operations.  In the event that these operations do not
yield a real result for the given arguments, the result may be a NaN,
or may be some meaningless flonum.

Implementations that use IEEE binary floating point arithmetic are
encouraged to follow the relevant standards for these procedures.

\begin{scheme}
(flexp +inf.0)                \ev +inf.0
(flexp -inf.0)                \ev 0.0
(fllog +inf.0)                \ev +inf.0
(fllog 0.0)                   \ev -inf.0
(fllog -0.0)                  \ev \unspecified\\\>; if -0.0 is distinguished
(fllog -inf.0)                \ev +nan.0
(flatan -inf.0)               \lev -1.5707963267948965\\\>; approximately
(flatan +inf.0)               \lev 1.5707963267948965\\\>; approximately%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flsqrt}{ fl}{procedure}}

Returns the principal square root of \var{fl}. For a negative argument,
the result may be a NaN, or may be some meaningless flonum.

\begin{scheme}
(flsqrt +inf.0)               \ev  +inf.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flexpt}{ \vari{fl} \varii{fl}}{procedure}}

Returns \vari{fl} raised to the power \varii{fl}.  \vari{fl} should be
non-negative; if \vari{fl} is negative, then the result may be a NaN,
or may be some meaningless flonum.  If \vari{fl} is zero, then the
result is zero.  For positive $\mathit{fl}_1$,% LaTeX kludge

\begin{displaymath}
  \mathit{fl}_1^{\mathit{fl}_2} = e^{\mathit{fl}_2 \log \mathit{fl}_1}
\end{displaymath}
\end{entry}

\begin{entry}{%
\ctproto{no-infinities}
\proto{no-infinities?}{ obj}{procedure}
\ctproto{no-nans}
\proto{no-nans?}{ obj}{procedure}}

These condition types could be defined by the following code:

\begin{scheme}
(define-condition-type \&no-infinities
    \&implementation-restriction
  no-infinities?)

(define-condition-type \&no-nans
    \&implementation-restriction
  no-nans?)%
\end{scheme}

These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  (See report section~\ref{report:infinitiesnanssection}.)
\end{entry}

\begin{entry}{%
\proto{fixnum->flonum}{ fx}{procedure}}

Returns a flonum that is numerically closest to \var{fx}.

\begin{note}
The result of this procedure may not be
numerically equal to \var{fx}, because the fixnum precision
may be greater than the flonum precision.
\end{note}
\end{entry}

\section{Exact arithmetic}
\label{exactsection}

This section describes the \deflibrary{r6rs arithmetic exact} library.

The exact arithmetic provides generic operations on exact numbers;
these operations correspond to their mathematical counterparts.  The
exact numbers include rationals of arbitrary precision, and exact
rectangular complex numbers.  A rational number with a denominator of
$1$ is indistinguishable from its numerator.  An exact rectangular
complex number with a zero imaginary part is indistinguishable from
its real part.

\begin{entry}{%
\proto{exact-number?}{ ex}{procedure}
\proto{exact-complex?}{ ex}{procedure}
\proto{exact-rational?}{ ex}{procedure}
\proto{exact-integer?}{ ex}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object
is an exact number of the named type, and otherwise return
\schfalse{}.  In general, if a type predicate is true of a number then
all higher type predicates are also true of that number.
Consequently, if a type predicate is false of a number, then all lower
type predicates are also false of that number.
\end{entry}

This section uses \var{ex}, \vari{ex}, \varii{ex}, and \variii{ex} as
parameter names for arguments that must be exact complex numbers, \var{ef},
\vari{ef}, \varii{ef}, and \variii{ef} as parameter names for arguments 
that must be exact rational numbers, and \var{ei}, \vari{ei}, \varii{ei}, and
\variii{ei} as parameter names that must be exact integers.

\begin{entry}{%
\proto{exact=?}{ \vari{ex} \varii{ex} \variii{ex} \dotsfoo}{procedure}
\proto{exact>?}{ \vari{ef} \varii{ef} \variii{ef} \dotsfoo}{procedure}
\proto{exact<?}{ \vari{ef} \varii{ef} \variii{ef} \dotsfoo}{procedure}
\proto{exact>=?}{ \vari{ef} \varii{ef} \variii{ef} \dotsfoo}{procedure}
\proto{exact<=?}{ \vari{ef} \varii{ef} \variii{ef} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically
nonincreasing \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{exact-zero?}{ ex}{procedure}
\proto{exact-positive?}{ ef}{procedure}
\proto{exact-negative?}{ ef}{procedure}
\proto{exact-odd?}{ ei}{procedure}
\proto{exact-even?}{ ei}{procedure}}

These numerical predicates test an exact number for a particular
property, returning \schtrue{} or \schfalse{}.  The {\cf exact-zero?} procedure
tests whether the number is {\cf exact=?} to zero, {\cf exact-positive?}
tests whether it is greater than zero, {\cf exact-negative?} tests whether it is
less than zero, {\cf exact-odd?} tests whether it is odd, {\cf exact-even?}
tests whether it is even.
\end{entry}

\begin{entry}{%
\proto{exact-max}{ \vari{ef} \varii{ef} \dotsfoo}{procedure}
\proto{exact-min}{ \vari{ef} \varii{ef} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
\end{entry}

\begin{entry}{%
\proto{exact+}{ \vari{ex} \varii{ex} \dotsfoo}{procedure}
\proto{exact*}{ \vari{ex} \varii{ex} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.
\end{entry}

\begin{entry}{%
\proto{exact-}{ \vari{ex} \varii{ex} \dotsfoo}{procedure}
\rproto{exact-}{ ex}{procedure}
\proto{exact/}{ \vari{ex} \varii{ex} \dotsfoo}{procedure}
\rproto{exact/}{ ex}{procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.
The {\cf exact/} procedure raises an exception with condition
type {\cf\&contract} if a divisor is $0$.
\end{entry}

\begin{entry}{%
\proto{exact-abs}{ ef}{procedure}}

Returns the absolute value of \var{ef}.
\end{entry}

\begin{entry}{%
\proto{exact-div+mod}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-div}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-mod}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-div0+mod0}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-div0}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-mod0}{ \vari{ef} \varii{ef}}{procedure}}

\domain{\varii{Ef} must be nonzero.}
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\ref{report:integerdivision}.
%
\begin{scheme}
(exact-div \vari{ef} \varii{ef})         \ev \(\vari{ef}~\mathrm{div}~\varii{ef}\)
(exact-mod \vari{ef} \varii{ef})         \ev \(\vari{ef}~\mathrm{mod}~\varii{ef}\)
(exact-div+mod \vari{ef} \varii{ef})     \lev \(\vari{ef}~\mathrm{div}~\varii{ef}, \vari{ef}~\mathrm{mod}~\varii{ef}\)\\\>\>; two return values
(exact-div0 \vari{ef} \varii{ef})        \ev \(\vari{ef}~\mathrm{div}_0~\varii{ef}\)
(exact-mod0 \vari{ef} \varii{ef})        \ev \(\vari{ef}~\mathrm{mod}_0~\varii{ef}\)
(exact-div0+mod0 \vari{ef} \varii{ef})   \lev \(\vari{ef}~\mathrm{div}_0~\varii{ef}, \vari{ef}~\mathrm{mod}_0~\varii{ef}\)\\\>\>; two return values%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-gcd}{ \vari{ei} \varii{ei} \dotsfoo}{procedure}
\proto{exact-lcm}{ \vari{ei} \varii{ei} \dotsfoo}{procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.
\end{entry}

\begin{entry}{%
\proto{exact-numerator}{ ef}{procedure}
\proto{exact-denominator}{ ef}{procedure}}

These procedures return the numerator or denominator of their argument.
The result is computed as if the argument were represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of $0$ is defined to be $1$.
\end{entry}

\begin{entry}{%
\proto{exact-floor}{ ef}{procedure}
\proto{exact-ceiling}{ ef}{procedure}
\proto{exact-truncate}{ ef}{procedure}
\proto{exact-round}{ ef}{procedure}}

These procedures return exact integers.  The {\cf exact-floor} procedure returns the
largest integer not larger than \var{ef}.  The {\cf exact-ceiling} procedure returns
the smallest integer not smaller than \var{ef}.  The {\cf
  exact-truncate} procedure
returns the integer closest to \var{ef} whose absolute value is not
larger than the absolute value of \var{ef}.  The {\cf exact-round} procedure returns
the closest integer to \var{ef}, rounding to even when \var{ef} is
halfway between two integers.
\end{entry}

\begin{entry}{%
\proto{exact-expt}{ \vari{ef} \varii{ei}}{procedure}}

Returns \vari{ef} raised to the power \varii{ei}.  $0^{\var{ei}}$ is
$1$ if $\var{ei} = 0$ and $0$ if \var{ei} is positive.
If \vari{ef} is zero and \varii{ei} is negative,
this procedure raises an exception with condition type {\cf\&contract}.
\end{entry}

\begin{entry}{%
\proto{exact-make-rectangular}{ \vari{ef} \varii{ef}}{procedure}
\proto{exact-real-part}{ ex}{procedure}
\proto{exact-imag-part}{ ex}{procedure}}

The arguments of {\cf exact-make-rectangular} must be exact
rationals.  Suppose \var{ex} is a complex number such that
%
\begin{displaymath}
\var{ex} = \vari{ef} + \varii{ef}i\mathrm{.}
\end{displaymath}
%
Then:
\begin{scheme}
(exact-make-rectangular \vari{ef} \varii{ef}) \lev \var{ex}
(exact-real-part \var{ex})              \ev \vari{ef}
(exact-imag-part \var{ex})              \ev \varii{ef}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-sqrt}{ ei}{procedure}}

\domain{\var{Ei} must be non-negative.}
The {\cf exact-sqrt} procedure returns two non-negative exact
integers $s$ and $r$ where $\var{ei} = s^2 +
r$ and $\var{ei} < (s+1)^2$.
\end{entry}

\begin{entry}{%
\proto{exact-not}{ ei}{procedure}}

Returns the exact integer whose two's complement representation is the
one's complement of the two's complement representation of \var{ei}.
\end{entry}

\begin{entry}{%
\proto{exact-and}{ \vari{ei} \dotsfoo}{procedure}
\proto{exact-ior}{ \vari{ei} \dotsfoo}{procedure}
\proto{exact-xor}{ \vari{ei} \dotsfoo}{procedure}}

These procedures return the exact integer that is the bit-wise
``and'', ``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the integer (either $-1$ or $0$) that acts as identity for
the operation.
\end{entry}

\begin{entry}{%
\proto{exact-if}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

Returns the exact integer that is the result of the following computation:
\begin{scheme}
(exact-ior (exact-and \vari{ei} \varii{ei})
           (exact-and (exact-not \vari{ei}) \variii{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-bit-count}{ ei}{procedure}}
 
If \var{ei} is non-negative, this procedure returns the number of
1 bits in the two's complement representation of \var{ei}.
Otherwise it returns the number of 0 bits in the two's complement
representation of \var{ei}.
\end{entry}

\begin{entry}{%
\proto{exact-length}{ ei}{procedure}}

These procedures return the exact integer that is the result of the following
computation:
\begin{scheme}
(do ((result 0 (+ result 1))
     (bits (if (exact-negative? \var{ei})
               (exact-not \var{ei})
               \var{ei})
           (exact-arithmetic-shift bits -1)))
    ((exact-zero? bits)
     result))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-first-bit-set}{ ei}{procedure}}

Returns the index of the least significant $1$
bit in the two's complement representation of \var{ei}.
If \var{ei} is $0$, then $-1$ is returned.
\begin{scheme}
(exact-first-bit-set 0)        \ev  -1
(exact-first-bit-set 1)        \ev  0
(exact-first-bit-set -4)       \ev  2%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-bit-set?}{ \vari{ei} \varii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative.}

Otherwise returns the result of the following computation:
\begin{scheme}
(not (exact-zero?
      (exact-and
       (exact-arithmetic-shift-left 1 \varii{ei})
       \vari{ei})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-copy-bit}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative, and \variii{ei}
must be either $0$ or $1$.}
The {\cf exact-copy-bit} procedure returns the result of the following computation:
\begin{scheme}
(let* ((mask (exact-arithmetic-shift-left 1 \varii{ei})))
  (exact-if mask
            (exact-arithmetic-shift-left \variii{ei} \varii{ei})
            \vari{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-bit-field}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative, and
  \varii{ei} must be less than or equal to \variii{ei}.}  This
procedure returns the result of the following computation:
%
\begin{scheme}
(let* ((mask
        (exact-not
         (exact-arithmetic-shift-left -1 \variii{ei}))))
  (exact-arithmetic-shift-right
   (exact-and \vari{ei} mask)
   \varii{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-copy-bit-field}{ \vari{ei} \varii{ei} \variii{ei} \variv{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative,
and \varii{ei} must be less than or equal to \variii{ei}.}
The {\cf exact-copy-bit-field} procedure returns the result of the following computation:
%
\begin{scheme}
(let* ((to    \vari{ei})
       (start \varii{ei})
       (end   \variii{ei})
       (from  \variv{ei})
       (mask1
         (exact-arithmetic-shift-left -1 start))
       (mask2
         (exact-not
           (exact-arithmetic-shift-left -1 end)))
       (mask (exact-and mask1 mask2)))
  (exact-if mask
            (exact-arithmetic-shift-left from
                                         start)
            to))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-arithmetic-shift}{ \vari{ei} \varii{ei}}{procedure}}

Returns the exact integer result of the following computation:
%
\begin{scheme}
(exact-floor (* \vari{ei} (expt 2 \varii{ei})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-arithmetic-shift-left}{ \vari{ei} \varii{ei}}{procedure}
\proto{exact-arithmetic-shift-right}{ \vari{ei} \varii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative.}  {\cf
  exact-arithmetic-shift-left} returns the same result as {\cf
  exact-arithmetic-shift}, and {\cf (exact-arithmetic-shift-right
  \vari{ei} \varii{ei})} returns the same result as {\cf
  (exact-arithmetic-shift \vari{ei} (exact- \varii{ei}))}.
\end{entry}

\begin{entry}{%
\proto{exact-rotate-bit-field}{ \vari{ei} \varii{ei} \variii{ei} \variv{ei}}{procedure}}

\domain{\varii{Ei}, \variii{ei}, \variv{ei} must be non-negative, and \variv{ei}
must be less than the difference between \varii{ei} and \variii{ei}.}
The procedure returns the result of the following computation:
%
\begin{scheme}
(let* ((n     \vari{ei})
       (start \varii{ei})
       (end   \variii{ei})
       (count \variv{ei})
       (width (exact- end start)))
  (if (exact-positive? width)
      (let* ((count (exact-mod count width))
             (field0
               (exact-bit-field n start end))
             (field1 (exact-arithmetic-shift-left
                       field0 count))
             (field2 (exact-arithmetic-shift-right
                       field0
                       (exact- width count)))
             (field (exact-ior field1 field2)))
        (exact-copy-bit-field n start end field))
      n))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-reverse-bit-field}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative, and
  \varii{ei} must be less than or equal to \variii{ei}.}  The {\cf exact-reverse-bit-field} procedure returns
the result obtained from the \vari{ei} by reversing the bit field
specified by \varii{ei} and \variii{ei}.
\begin{scheme}
(exact-reverse-bit-field \sharpsign{}b1010010 1 4)   \lev  88 ; \sharpsign{}b1011000
(exact-reverse-bit-field \sharpsign{}1010010 91 -4)  \lev  \exception{\&contract}%
\end{scheme}
\end{entry}

\section{Inexact arithmetic}
\label{inexactsection}

This section describes the \deflibrary{r6rs arithmetic inexact} library.

The inexact arithmetic provides generic operations on inexact numbers.
The inexact numbers include inexact reals and inexact complex numbers,
both of which are distinguishable from the exact numbers.  The inexact
complex numbers include the flonums, and the procedures described here
behave consistently with the corresponding flonum procedures if passed
flonum arguments.

\begin{entry}{%
\proto{inexact-number?}{ obj}{procedure}
\proto{inexact-complex?}{ obj}{procedure}
\proto{inexact-real?}{ obj}{procedure}
\proto{inexact-rational?}{ obj}{procedure}
\proto{inexact-integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object
is an inexact number of the named type, and otherwise they return
\schfalse{}.  In general, if a type predicate is true of a number then
all higher type predicates are also true of that number.
Consequently, if a type predicate is false of a number, then all lower
type predicates are also false of that number.
\end{entry}

This section uses \var{in}, \vari{in}, \varii{in}, and
\variii{in} as parameter names for arguments that must be inexact numbers,
\var{ir}, \vari{ir}, \varii{ir}, and \variii{ir} as
parameter names for arguments that must be inexact real numbers,
\var{if}, \vari{if}, \varii{if}, and \variii{if} as
parameter names for arguments that must be inexact rationals, and
\var{ii}, \vari{ii}, \varii{ii}, and \variii{ii} as
parameter names for arguments that must be the inexact integers.

\begin{entry}{%
\proto{inexact=?}{ \vari{in} \varii{in} \variii{in} \dotsfoo}{procedure}
\proto{inexact>?}{ \vari{ir} \varii{ir} \variii{ir} \dotsfoo}{procedure}
\proto{inexact<?}{ \vari{ir} \varii{ir} \variii{ir} \dotsfoo}{procedure}
\proto{inexact>=?}{ \vari{ir} \varii{ir} \variii{ir} \dotsfoo}{procedure}
\proto{inexact<=?}{ \vari{ir} \varii{ir} \variii{ir} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically
nonincreasing \schfalse{} otherwise.  These predicates are required to
be transitive.
\end{entry}

\begin{entry}{%
\proto{inexact-zero?}{ in}{procedure}
\proto{inexact-positive?}{ ir}{procedure}
\proto{inexact-negative?}{ ir}{procedure}
\proto{inexact-odd?}{ ii}{procedure}
\proto{inexact-even?}{ ii}{procedure}
\proto{inexact-finite?}{ in}{procedure}
\proto{inexact-infinite?}{ in}{procedure}
\proto{inexact-nan?}{ in}{procedure}}

These numerical predicates test an inexact number for a particular
property, returning \schtrue{} or \schfalse{}.  The {\cf
  inexact-zero?} procedure
tests if the number is {\cf inexact=?} to zero, {\cf
  inexact-positive?} tests if it is greater than zero, {\cf
  inexact-negative?} tests if it is less than zero, {\cf inexact-odd?}
tests if it is odd, {\cf inexact-even?} tests if it is even, {\cf
  inexact-finite?} tests if it is not an infinity and not a NaN, {\cf
  inexact-infinite?} tests if it is an infinity, and
  {\cf inexact-nan?} tests if it is a NaN.
\end{entry}

\begin{entry}{%
\proto{inexact-max}{ \vari{ir} \varii{ir} \dotsfoo}{procedure}
\proto{inexact-min}{ \vari{ir} \varii{ir} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
\end{entry}

\begin{entry}{%
\proto{inexact+}{ \vari{in} \varii{in} \dotsfoo}{procedure}
\proto{inexact*}{ \vari{in} \varii{in} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.
\end{entry}

\begin{entry}{%
\proto{inexact-}{ \vari{in} \varii{in} \dotsfoo}{procedure}
\rproto{inexact-}{ in}{procedure}
\proto{inexact/}{ \vari{in} \varii{in} \dotsfoo}{procedure}
\rproto{inexact/}{ in}{procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse
of their argument.
\end{entry}

\begin{entry}{%
\proto{inexact-abs}{ in}{procedure}}

Returns the absolute value of its argument.
\end{entry}

\begin{entry}{%
\proto{inexact-div+mod}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-div}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-mod}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-div0+mod0}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-div0}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-mod0}{ \vari{ir} \varii{ir}}{procedure}}

\domain{\vari{Ir}
must be neither infinite nor a NaN, and \varii{ir} must be nonzero.}
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\ref{report:integerdivision}.  

\begin{scheme}
(inexact-div \vari{ir} \varii{ir})         \ev \(\vari{ir}~\mathrm{div}~\varii{ir}\)
(inexact-mod \vari{ir} \varii{ir})         \ev \(\vari{ir}~\mathrm{mod}~\varii{ir}\)
(inexact-div+mod \vari{ir} \varii{ir})     \lev \(\vari{ir}~\mathrm{div}~\varii{ir}, \vari{ir}~\mathrm{mod}~\varii{ir}\)\\\>\>; two return values
(inexact-div0 \vari{ir} \varii{ir})        \ev \(\vari{ir}~\mathrm{div}_0~\varii{ir}\)
(inexact-mod0 \vari{ir} \varii{ir})        \ev \(\vari{ir}~\mathrm{mod}_0~\varii{ir}\)
(inexact-div0+mod0 \vari{ir} \varii{ir})   \lev \(\vari{ir}~\mathrm{div}_0~\varii{ir}, \vari{ir}~\mathrm{mod}_0~\varii{ir}\)\\\>\>; two return values%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{inexact-gcd}{ \vari{ii} \varii{ii} \dotsfoo}{procedure}
\proto{inexact-lcm}{ \vari{ii} \varii{ii} \dotsfoo}{procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.
\end{entry}

\begin{entry}{%
\proto{inexact-numerator}{ if}{procedure}
\proto{inexact-denominator}{ if}{procedure}}

These procedures return the numerator or denominator of 
\var{if}.  The result is computed as if \var{if} was represented
as a fraction in lowest terms.  The denominator is always positive.
The denominator of $0.0$ is defined to be $1.0$.
\end{entry}

\begin{entry}{%
\proto{inexact-floor}{ ir}{procedure}
\proto{inexact-ceiling}{ ir}{procedure}
\proto{inexact-truncate}{ ir}{procedure}
\proto{inexact-round}{ ir}{procedure}}

These procedures return inexact integers for real arguments that are
not infinities or NaNs.  For such arguments, {\cf inexact-floor}
returns the largest integer not larger than \var{ir}.  The {\cf
  inexact-ceiling} procedure returns the smallest integer not smaller than
\var{ir}.  The {\cf inexact-truncate} procedure returns the integer closest to
\var{in} whose absolute value is not larger than the absolute value of
\var{in}.  The {\cf inexact-round} procedure returns the closest integer to
\var{in}, rounding to even when \var{in} is halfway between two
integers.

\begin{rationale}
The {\cf inexact-round} procedure rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

Although infinities and NaNs are not integers, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN.
\end{entry}

\begin{entry}{%
\proto{inexact-exp}{ in}{procedure}
\proto{inexact-log}{ in}{procedure}
\rproto{inexact-log}{ \vari{in} \varii{in}}{procedure}
\proto{inexact-sin}{ in}{procedure}
\proto{inexact-cos}{ in}{procedure}
\proto{inexact-tan}{ in}{procedure}
\proto{inexact-asin}{ in}{procedure}
\proto{inexact-acos}{ in}{procedure}
\proto{inexact-atan}{ in}{procedure}
\rproto{inexact-atan}{ \vari{ir} \varii{ir}}{procedure}}

These procedures compute the usual transcendental functions.  The {\cf
  inexact-exp} procedure computes the base-$e$ exponential of
\var{in}.  The {\cf inexact-log} procedure with a single argument computes the natural logarithm
of \var{in} (not the base ten logarithm); {\cf (inexact-log \vari{in}
  \varii{in})} computes the base-\varii{in} logarithm of \vari{in}.
The {\cf inexact-asin}, {\cf inexact-acos}, and {\cf inexact-atan} procedures compute
arcsine, arccosine, and arctangent, respectively.  The two-argument
variant of {\cf inexact-atan} computes {\cf (inexact-angle
  (inexact-make-rectangular \vari{ir} \varii{ir}))} (see below).

See report section~\ref{report:transcendentalfunctions} for the underlying
mathematical operations.  In the event that these operations do not
yield a real result for the given arguments, the result may be {\cf
  +nan.0}, or may be some meaningless inexact number.
\end{entry}

\begin{entry}{%
\proto{inexact-sqrt}{ in}{procedure}}

Returns the principal square root of \var{in}. For a negative argument,
the result may be {\cf +nan.0}, or may be some meaningless inexact
number.  With $\log$ defined as in
report section~\ref{report:transcendentalfunctions}, the value of {\cf (inexact-sqrt
  \var{in})} could be expressed as

\begin{displaymath}
e^{\frac{\log \var{in}}{2}}.
\end{displaymath}
\end{entry}

\begin{entry}{%
\proto{inexact-expt}{ \vari{in} \varii{in}}{procedure}}

Returns \vari{in} raised to the power \varii{in}.  For nonzero
\vari{in},
%
\begin{displaymath}
  \vari{in}^{\varii{in}} = e^{\varii{in} \log \vari{in}}
\end{displaymath}
%
$0.0^{\var{in}}$ is $1$ if $\var{in} = 0.0$, and $0.0$ if {\cf
  (inexact-real-part \var{in})} is positive.  Otherwise,
for nonzero \vari{in}, this
procedure raises an exception with condition type {\cf\&implementation-restriction} or
returns an unspecified number.
\end{entry}

\begin{entry}{%
\proto{inexact-make-rectangular}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-make-polar}{ \vari{ir} \varii{ir}}{procedure}
\proto{inexact-real-part}{ in}{procedure}
\proto{inexact-imag-part}{ in}{procedure}
\proto{inexact-magnitude}{ in}{procedure}
\proto{inexact-angle}{ in}{procedure}}

Suppose \vari{ir}, \varii{ir}, \variii{ir}, and \variv{ir} are inexact
real numbers, and \var{in} is a complex number, such that
%
\begin{displaymath}
\var{in} = \vari{ir} + \varii{ir}i = \variii{ir} e^{i\variv{ir}}.
\end{displaymath}
%
Then (inexactly):
%
\begin{scheme}
(inexact-make-rectangular \vari{ir} \varii{ir}) \lev \var{in}
(inexact-make-polar \variii{ir} \variv{ir}) \lev \var{in}
(inexact-real-part \var{in})              \ev \vari{ir}
(inexact-imag-part \var{in})              \ev \varii{ir}
(inexact-magnitude \var{in})              \ev |\variii{ir}|
(inexact-angle \var{in})                  \ev \var{ir}\(_{\mathrm{angle}}\)%
\end{scheme}
%
where $-\pi \leq \var{ir}_{\mathrm{angle}} \leq \pi$ with
$\var{ir}_{\mathrm{angle}} = \variv{ir} + 2\pi n$ for
some integer $n$.

\begin{scheme}
(inexact-angle -1.0)         \ev \(\pi\)
(inexact-angle -1.0+0.0)     \ev \(\pi\)
(inexact-angle -1.0-0.0)     \ev -\(\pi\)\\\>; if -0.0 is distinguished%
\end{scheme}

Moreover, suppose \vari{ir}, \varii{ir} are such that either \vari{ir}
or \varii{ir} is an infinity, then
%
\begin{scheme}
(inexact-make-rectangular \vari{ir} \varii{ir}) \lev \var{in}
(inexact-magnitude \var{in})              \ev +inf.0%
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
