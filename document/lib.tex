\chapter{Libraries}
\label{librarychapter}

FIXME: The actual library chapter needs to go here

\section{Primitive syntax}

The body of a library is always a sequence of S-expressions.  Apart
from that, the concrete structure of the S-expressions that form a
library body largely depends on the libraries that are imported into
the current library.  The syntactic keywords imported determine which
of the S-expressions occurring in a library body, and which of their
sub-S-expressions are actually expressions.  While a library can
provide new means for forming expressions, a few expression types are
always available, independently from the imported libraries.
Moreover, a library might export and thus provide macros whose expand
into other forms. The syntax of the primitive expressions as well as
of macro uses are described in this section.

\subsection{Primitive expression types}
\label{primitiveexpressionsection}

The entries in this section all describe expressions, which may occur
in the place of \hyper{expression} syntactic variables.  See
also section~\ref{expressionsection}

\subsubsection*{Constant literals}\unsection

\begin{entry}{%
\pproto{\hyper{constant}}{\exprtype}}

Numerical constants, string constants, character constants, and
boolean constants evaluate ``to themselves.''
\end{entry}

\subsubsection*{Variable references}\unsection
\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

An expression consisting of a variable\index{variable}
(section~\ref{variablesection}) is a variable reference.  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is an error to reference an
unbound\index{unbound} variable.

\begin{scheme}
(define x 28) ; in the core language
x   \ev  28%
\end{scheme}
\end{entry}

\subsubsection*{Procedure calls}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

A procedure call is written by simply enclosing in parentheses
expressions for the procedure to be called and the arguments to be
passed to it.  An S-expression in an expression context is a procedure
call if \hyper{operator} is not bound as a syntactic keyword.

When an procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting
arguments.\mainindex{call}\mainindex{procedure call} In the core
language:
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

\begin{note} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.
\end{note}

\begin{note}
Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.
\end{note}

\begin{note} In many dialects of Lisp, the S-expression {\tt
()} is a legitimate expression.  In Scheme, expressions written as
list/pair S-expressions  must have at
least one subexpression, so {\tt ()} is not a syntactically valid
expression.
\end{note}

\todo{Freeman:
I think an explanation as to why evaluation order is not specified
should be included.  It should not include any reference to parallel
evaluation.  Does any existing compiler generate better code because
the evaluation order is unspecified?  Clinger: yes: T3, MacScheme v2,
probably MIT Scheme and Chez Scheme.  But that's not the main reason
for leaving the order unspecified.}

\end{entry}

\subsection{Macros}
\label{macrosection}

Scheme programs can define and use new derived expression or
definition types, called {\em macros}.\mainindex{macro}
Program-defined expression or definition types have the syntax
\begin{scheme}
(\hyper{keyword} {\hyper{datum}} ...)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
expression type.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.  The
number of the \hyper{datum}s, and their syntax, depends on the
expression type.

Each instance of a macro is called a {\em use}\index{macro use}
of the macro.
The set of rules that specifies
how a use of a macro is transcribed into a more primitive expression
is called the {\em transformer}\index{macro transformer}
of the macro.

The macro definition facility consists of two parts:

\begin{itemize}
\item A set of expressions used to establish that certain identifiers
are macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined, and

\item a facility (called {\cf syntax-case}; see
  chapter~\ref{syntaxcasechapter}) for defining macro transformers as
  Scheme code, and a derived facility (called {\cf syntax-rules}; see
  section~\ref{syntaxrulessection}) providing a pattern language for
  specifying macro transformers.
\end{itemize}

The syntactic keyword of a macro may shadow variable bindings, and local
variable bindings may shadow keyword bindings.  \index{keyword}  All macros
defined using the pattern language  are ``hygienic'' and ``referentially
transparent'' and thus preserve Scheme's lexical scoping~\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}:
\mainindex{hygienic}
\mainindex{referentially transparent}

\begin{itemize}

\item If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers.
Note that a \ide{define} at top level may or may not introduce a binding;
see section~\ref{defines}.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.

\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
