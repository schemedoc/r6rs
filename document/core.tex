%\vfill\eject
\chapter{Core language}
\label{corelanguagecchapter}

\newcommand{\syntax}{{\em Syntax: }}
\newcommand{\semantics}{{\em Semantics: }}

This chapter describes Scheme's core language.  FIXME  The initial (or
``top level'') Scheme environment starts out with a number of variables
bound to locations containing useful values, most of which are primitive
procedures that manipulate data.  For example, the variable {\cf abs} is
bound to (a location initially containing) a procedure of one argument
that computes the absolute value of a number, and the variable {\cf +}
is bound to a procedure that computes sums.  Built-in procedures that
can easily be written in terms of other built-in procedures are identified as
``library procedures''.

A program may use a top-level definition to bind any variable.  It may
subsequently alter any such binding by an assignment (see \ref{assignment}).
These operations do not modify the behavior of Scheme's built-in
procedures.  Altering any top-level binding that has not been introduced by a
definition has an unspecified effect on the behavior of the built-in procedures.

%[Deleted for R5RS because of multiple-value returns. -RK]
%A Scheme expression is a construct that returns a value, such as a
%variable reference, literal, procedure call, or conditional.

Expression types are categorized as {\em primitive} or {\em derived}.
Primitive expression types include variables and procedure calls.
Derived expression types are not semantically primitive, but can instead
be defined as macros.
With the exception of {\cf quasiquote}, whose macro definition is complex,
the derived expressions are classified as library features.
Suitable definitions are given in section~\ref{derivedsection}.

\section{Primitive expression types}
\label{primitivexps}

\subsection{Literal expressions}\unsection
\label{literalsection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}}

{\cf (quote \hyper{datum})} evaluates to \hyper{datum}.
\hyper{Datum}
may be any external representation of a Scheme object (see
section~\ref{externalreps}).  This notation is used to include literal
constants in Scheme code.

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

As noted in section~\ref{quotesection}, {\cf (quote \hyper{datum})}
may be abbreviated as \singlequote\hyper{datum}:

\begin{scheme}
'"abc"               \ev  "abc"
'145932              \ev  145932
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

Numerical constants, string constants, character constants, and boolean
constants evaluate ``to themselves''; they need not be quoted.

\begin{scheme}
'"abc"     \ev  "abc"
"abc"      \ev  "abc"
'145932    \ev  145932
145932     \ev  145932
'\schtrue  \ev  \schtrue
\schtrue   \ev  \schtrue%
\end{scheme}

As noted in section~\ref{storagemodel}, it is an error to alter 
the value of a literal expression using a mutation procedure like
{\cf set-car!}\ or {\cf string-set!}.

\end{entry}


\subsection{Procedures}\unsection
\label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{Formals} should be a formal arguments list as described below,
and \hyper{body} should be a sequence of one or more expressions.

\semantics
\vest A \lambdaexp{} evaluates to a procedure.  The environment in
effect when the \lambdaexp{} was evaluated is remembered as part of the
procedure.  When the procedure is later called with some actual
arguments, the environment in which the \lambdaexp{} was evaluated will
be extended by binding the variables in the formal argument list to
fresh locations, the corresponding actual argument values will be stored
in those locations, and the expressions in the body of the \lambdaexp{}
will be evaluated sequentially in the extended environment.
The result(s) of the last expression in the body will be returned as
the result(s) of the procedure call.

\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}a procedure}
((lambda (x) (+ x x)) 4)  \ev  8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{Formals} should have one of the following forms:

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments will be stored in the bindings of the
corresponding variables.

\item \hyper{variable}:
The procedure takes any number of arguments; when the procedure is
called, the sequence of actual arguments is converted into a newly
allocated list, and the list is stored in the binding of the
\hyper{variable}.

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
If a space-delimited period precedes the last variable, then
the procedure takes $n$ or more arguments, where $n$ is the
number of formal arguments before the period (there must
be at least one).
The value stored in the binding of the last variable will be a
newly allocated
list of the actual arguments left over after all the other actual
arguments have been matched up against the other formal arguments.
\end{itemize}

It is an error for a \hyper{variable} to appear more than once in
\hyper{formals}.

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

Each procedure created as the result of evaluating a \lambdaexp{} is
(conceptually) tagged
with a storage location, in order to make \ide{eqv?} and
\ide{eq?} work on procedures (see section~\ref{equivalencesection}).

\end{entry}


\subsection{Conditionals}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{Test}, \hyper{consequent}, and \hyper{alternate} may be arbitrary
expressions.

\semantics
An {\cf if} expression is evaluated as follows: first,
\hyper{test} is evaluated.  If it yields a true value\index{true} (see
section~\ref{booleansection}), then \hyper{consequent} is evaluated and
its value(s) is(are) returned.  Otherwise \hyper{alternate} is evaluated and its
value(s) is(are) returned.  If \hyper{test} yields a false value and no
\hyper{alternate} is specified, then the result of the expression is
unspecified.

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1%
\end{scheme}

\end{entry}


\subsection{Assignments}\unsection
\label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\hyper{Expression} is evaluated, and the resulting value is stored in
the location to which \hyper{variable} is bound.  \hyper{Variable} must
be bound either in some region\index{region} enclosing the {\cf set!}\ expression
or at top level.  The result of the {\cf set!} expression is
unspecified.

\begin{scheme}
(define x 2)
(+ x 1)                 \ev  3
(set! x 4)              \ev  \unspecified
(+ x 1)                 \ev  5%
\end{scheme}

\end{entry}

\section{Programs}

A Scheme program consists of a sequence of expressions, definitions,
and syntax definitions.
Expressions are described in chapter~\ref{expressionchapter};
definitions and syntax definitions are the subject of the rest of the
present chapter.

Programs are typically stored in files or entered interactively to a
running Scheme system, although other paradigms are possible;
questions of user interface lie outside the scope of this report.
(Indeed, Scheme would still be useful as a notation for expressing
computational methods even in the absence of a mechanical
implementation.)

Definitions and syntax definitions occurring at the top level of a program
can be interpreted
declaratively.
They cause bindings to be created in the top level
environment or modify the value of existing top-level bindings.
Expressions occurring at the top level of a program are
interpreted imperatively; they are executed in order when the program is
invoked or loaded, and typically perform some kind of initialization.

At the top level of a program {\tt(begin \hyperi{form} \dotsfoo)} is
equivalent to the sequence of expressions, definitions, and syntax definitions
that form the body of the \ide{begin}.

\todo{Cromarty, etc.: disclaimer about top level?}

\section{Definitions}
\label{defines}

Definitions are valid in some, but not all, contexts where expressions
are allowed.  They are valid only at the top level of a \hyper{program}
and at the beginning of a \hyper{body}.
\mainindex{definition}

A definition should have one of the following forms:\mainschindex{define}

\begin{itemize}

\item{\tt(define \hyper{variable} \hyper{expression})}

\item{\tt(define (\hyper{variable} \hyper{formals}) \hyper{body})}

\hyper{Formals} should be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a space-delimited period and another variable (as
in a lambda expression).  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

\item{\tt(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}

\hyper{Formal} should be a single
variable.  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}

\end{itemize}

\subsection{Top level definitions}

At the top level of a program, a definition
\begin{scheme}
(define \hyper{variable} \hyper{expression})%
\end{scheme}
has essentially the same effect as the assignment expression
\begin{scheme}
(\ide{set!}\ \hyper{variable} \hyper{expression})%
\end{scheme}
if \hyper{variable} is bound.  If \hyper{variable} is not bound,
however, then the definition will bind \hyper{variable} to a new
location before performing the assignment, whereas it would be an error
to perform a {\cf set!}\ on an unbound\index{unbound} variable.

\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}

Some implementations of Scheme use an initial environment in
which all possible variables are bound to locations, most of
which contain undefined values.  Top level definitions in
such an implementation are truly equivalent to assignments.

\todo{Rozas: equal time for opposition semantics?}


\subsection{Internal definitions}
\label{internaldefines}

Definitions may occur at the
beginning of a \hyper{body} (that is, the body of a \ide{lambda},
\ide{let}, \ide{let*}, \ide{letrec*}, \ide{letrec}, \ide{let-syntax},
or \ide{letrec-syntax}
expression or that of a definition of an appropriate form).
Such definitions are known as {\em internal definitions} \mainindex{internal
definition} as opposed to the top level definitions described above.
The variable defined by an internal definition is local to the
\hyper{body}.  That is, \hyper{variable} is bound rather than assigned,
and the region of the binding is the entire \hyper{body}.  For example,

\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}

A \hyper{body} containing internal definitions can always be converted
into a completely equivalent {\cf letrec*} expression.  For example, the
{\cf let} expression in the above example is equivalent to

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

Wherever an internal definition may occur
{\tt(begin \hyperi{definition} \dotsfoo)}
is equivalent to the sequence of definitions
that form the body of the \ide{begin}.

\section{Syntax definitions}

Syntax definitions are valid only at the top level of a \hyper{program}.
\mainindex{syntax definition}
They have the following form:\mainschindex{define-syntax}

{\tt(define-syntax \hyper{keyword} \hyper{transformer spec})}

\hyper{Keyword} is an identifier, and
the \hyper{transformer spec} should be an instance of \ide{syntax-rules}.
The top-level syntactic environment is extended by binding the
\hyper{keyword} to the specified transformer.

There is no {\cf define-syntax} analogue of internal definitions.

%[Rationale flushed because it may or may not be true and isn't the
% real rationale anyway. -RK]
%\begin{rationale}
%As discussed below, the syntax and scope rules for syntax definitions
%can give rise to syntactic ambiguities when syntactic keywords are
%shadowed.
%Further ambiguities would arise if {\cf define-syntax}
%were permitted at the beginning of a \meta{body}, with scope
%rules analogous to those for internal definitions.
%\end{rationale}

% It is an error for a program to contain more than one top-level
% \meta{definition} or \meta{syntax definition} of any identifier.
%
% [I flushed this because it isn't an error for a program to
% contain more than one top-level definition of an identifier,
% and I didn't want to introduce any gratuitous incompatibilities
% with the existing Scheme language. -- Will]

Although macros may expand into definitions and syntax definitions in
any context that permits them, it is an error for a definition or syntax
definition to shadow a syntactic keyword whose meaning is needed to
determine whether some form in the group of forms that contains the
shadowing definition is in fact a definition, or, for internal definitions,
is needed to determine the boundary between the group and the expressions
that follow the group.  For example, the following are errors:

\begin{scheme}
(define define 3)

(begin (define begin list))

(let-syntax
  ((foo (syntax-rules ()
          ((foo (proc args ...) body ...)
           (define proc
             (lambda (args ...)
               body ...))))))
  (let ((x 3))
    (foo (plus x y) (+ x y))
    (define foo x)
    (plus foo x)))
\end{scheme}



\section{Derived expression types}
\label{derivedexps}

The constructs in this section are hygienic, as discussed in
section~\ref{macrosection}.
For reference purposes, section~\ref{derivedsection} gives macro definitions
that will convert most of the constructs described in this section 
into the primitive constructs described in the previous section.

\todo{Mention that no definition of backquote is provided?}

\subsection{Conditionals}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{library \exprtype}}

\syntax
Each \hyper{clause} should be of the form
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)%
\end{scheme}
where \hyper{test} is any expression.  Alternatively, a \hyper{clause} may be
of the form
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
The last \hyper{clause} may be
an ``else clause,'' which has the form
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}
\mainschindex{else}
\mainschindex{=>}

\semantics
A {\cf cond} expression is evaluated by evaluating the \hyper{test}
expressions of successive \hyper{clause}s in order until one of them
evaluates to a true value\index{true} (see
section~\ref{booleansection}).  When a \hyper{test} evaluates to a true
value, then the remaining \hyper{expression}s in its \hyper{clause} are
evaluated in order, and the result(s) of the last \hyper{expression} in the
\hyper{clause} is(are) returned as the result(s) of the entire {\cf cond}
expression.  If the selected \hyper{clause} contains only the
\hyper{test} and no \hyper{expression}s, then the value of the
\hyper{test} is returned as the result.  If the selected \hyper{clause} uses the
\ide{=>} alternate form, then the \hyper{expression} is evaluated.
Its value must be a procedure that accepts one argument; this procedure is then
called on the value of the \hyper{test} and the value(s) returned by this
procedure is(are) returned by the {\cf cond} expression.
If all \hyper{test}s evaluate
to false values, and there is no else clause, then the result of
the conditional expression is unspecified; if there is an else
clause, then its \hyper{expression}s are evaluated, and the value(s) of
the last one is(are) returned.

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{clause} \hyperii{clause} \dotsfoo}{library \exprtype}}

\syntax
\hyper{Key} may be any expression.  Each \hyper{clause} should have
the form
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)\rm,%
\end{scheme}
where each \hyper{datum} is an external representation of some object.
All the \hyper{datum}s must be distinct.
The last \hyper{clause} may be an ``else clause,'' which has the form
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}
\schindex{else}

\semantics
A {\cf case} expression is evaluated as follows.  \hyper{Key} is
evaluated and its result is compared against each \hyper{datum}.  If the
result of evaluating \hyper{key} is equivalent (in the sense of
{\cf eqv?}; see section~\ref{eqv?}) to a \hyper{datum}, then the
expressions in the corresponding \hyper{clause} are evaluated from left
to right and the result(s) of the last expression in the \hyper{clause} is(are)
returned as the result(s) of the {\cf case} expression.  If the result of
evaluating \hyper{key} is different from every \hyper{datum}, then if
there is an else clause its expressions are evaluated and the
result(s) of the last is(are) the result(s) of the {\cf case} expression;
otherwise the result of the {\cf case} expression is unspecified.

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))            \ev  consonant%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{library \exprtype}}

The \hyper{test} expressions are evaluated from left to right, and the
value of the first expression that evaluates to a false value (see
section~\ref{booleansection}) is returned.  Any remaining expressions
are not evaluated.  If all the expressions evaluate to true values, the
value of the last expression is returned.  If there are no expressions
then \schtrue{} is returned.

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{library \exprtype}}

The \hyper{test} expressions are evaluated from left to right, and the value of the
first expression that evaluates to a true value (see
section~\ref{booleansection}) is returned.  Any remaining expressions
are not evaluated.  If all expressions evaluate to false values, the
value of the last expression is returned.  If there are no
expressions then \schfalse{} is returned.

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or (memq 'b '(a b c)) 
    (/ 3 0))                    \ev  (b c)%
\end{scheme}

\end{entry}


\subsection{Binding constructs}

The four binding constructs {\cf let}, {\cf let*}, {\cf letrec*}, and {\cf letrec}
give Scheme a block structure, like Algol 60.  The syntax of the four
constructs is identical, but they differ in the regions\index{region} they establish
for their variable bindings.  In a {\cf let} expression, the initial
values are computed before any of the variables become bound; in a
{\cf let*} expression, the bindings and evaluations are performed
sequentially; while in a {\cf letrec*} and in a {\cf letrec}
expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{library \exprtype}}

\syntax
\hyper{Bindings} should have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} should be a
sequence of one or more expressions.  It is
an error for a \hyper{variable} to appear more than once in the list of variables
being bound.

\semantics
The \hyper{init}s are evaluated in the current environment (in some
unspecified order), the \hyper{variable}s are bound to fresh locations
holding the results, the \hyper{body} is evaluated in the extended
environment, and the value(s) of the last expression of \hyper{body}
is(are) returned.  Each binding of a \hyper{variable} has \hyper{body} as its
region.\index{region}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

See also named {\cf let}, section \ref{namedlet}.

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{library \exprtype}}\nobreak

\nobreak
\syntax
\hyper{Bindings} should have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} should be a sequence of
one or more expressions.

\semantics
{\cf Let*} is similar to {\cf let}, but the bindings are performed
sequentially from left to right, and the region\index{region} of a binding indicated
by {\cf(\hyper{variable} \hyper{init})} is that part of the {\cf let*}
expression to the right of the binding.  Thus the second binding is done
in an environment in which the first binding is visible, and so on.

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{library \exprtype}}

\syntax
\hyper{Bindings} should have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} should be a sequence of
one or more expressions. It is an error for a \hyper{variable} to appear more
than once in the list of variables being bound.

\semantics
The \hyper{variable}s are bound to fresh locations holding undefined
values, the \hyper{init}s are evaluated from left to right in the
resulting environment, after the evaluation of each \hyper{init}, the
corresponding \hyper{variable} is assigned to the result,
the \hyper{body} is evaluated in the
resulting environment, and the value(s) of the last expression in
\hyper{body} is(are) returned.  Each binding of a \hyper{variable} has the
entire {\cf letrec*} expression as its region\index{region}, making it possible to
define mutually recursive procedures.

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
		\ev  5%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{library \exprtype}}

\syntax
\hyper{Bindings} should have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
and \hyper{body} should be a sequence of
one or more expressions. It is an error for a \hyper{variable} to appear more
than once in the list of variables being bound.

\semantics
The \hyper{variable}s are bound to fresh locations holding undefined
values, the \hyper{init}s are evaluated in the resulting environment (in
some unspecified order), each \hyper{variable} is assigned to the result
of the corresponding \hyper{init}, the \hyper{body} is evaluated in the
resulting environment, and the value(s) of the last expression in
\hyper{body} is(are) returned.  Each binding of a \hyper{variable} has the
entire {\cf letrec} expression as its region\index{region}, making it possible to
define mutually recursive procedures.

\begin{scheme}
%(letrec ((x 2) (y 3))
%  (letrec ((foo (lambda (z) (+ x y z))) (x 7))
%    (foo 4)))                   \ev  14
%
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))   
		\ev  \schtrue%
\end{scheme}

One restriction on {\cf letrec} is very important: it must be possible
to evaluate each \hyper{init} without assigning or referring to the value of any
\hyper{variable}.  If this restriction is violated, then it is an error.  The
restriction is necessary because Scheme passes arguments by value rather than by
name.  In the most common uses of {\cf letrec}, all the \hyper{init}s are
\lambdaexp{}s and the restriction is satisfied automatically.

% \todo{use or uses?  --- Jinx.}

\end{entry}


\subsection{Sequencing}\unsection

\begin{entry}{%
\proto{begin}{ \hyperi{expression} \hyperii{expression} \dotsfoo}{library \exprtype}}

The \hyper{expression}s are evaluated sequentially from left to right,
and the value(s) of the last \hyper{expression} is(are) returned.  This
expression type is used to sequence side effects such as input and
output.

\begin{scheme}
(define x 0)

(begin (set! x 5)
       (+ x 1))                  \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em and prints}  4 plus 1 equals 5%
\end{scheme}

\end{entry}


\subsection{Iteration}%\unsection

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{library \exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{command} \dotsfoo)}

{\cf Do} is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits after evaluating the \hyper{expression}s.

{\cf Do} expressions are evaluated as follows:
The \hyper{init} expressions are evaluated (in some unspecified order),
the \hyper{variable}s are bound to fresh locations, the results of the
\hyper{init} expressions are stored in the bindings of the
\hyper{variable}s, and then the iteration phase begins.

\vest Each iteration begins by evaluating \hyper{test}; if the result is
false (see section~\ref{booleansection}), then the \hyper{command}
expressions are evaluated in order for effect, the \hyper{step}
expressions are evaluated in some unspecified order, the
\hyper{variable}s are bound to fresh locations, the results of the
\hyper{step}s are stored in the bindings of the
\hyper{variable}s, and the next iteration begins.

\vest If \hyper{test} evaluates to a true value, then the
\hyper{expression}s are evaluated from left to right and the value(s) of
the last \hyper{expression} is(are) returned.  If no \hyper{expression}s
are present, then the value of the {\cf do} expression is unspecified.

\vest The region\index{region} of the binding of a \hyper{variable}
consists of the entire {\cf do} expression except for the \hyper{init}s.
It is an error for a \hyper{variable} to appear more than once in the
list of {\cf do} variables.

\vest A \hyper{step} may be omitted, in which case the effect is the
same as if {\cf(\hyper{variable} \hyper{init} \hyper{variable})} had
been written instead of {\cf(\hyper{variable} \hyper{init})}.

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}

%\end{entry}


\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{library \exprtype}}

\label{namedlet}
``Named {\cf let}'' is a variant on the syntax of \ide{let} which provides
a more general looping construct than {\cf do} and may also be used to express
recursions.
It has the same syntax and semantics as ordinary {\cf let}
except that \hyper{variable} is bound within \hyper{body} to a procedure
whose formal arguments are the bound variables and whose body is
\hyper{body}.  Thus the execution of \hyper{body} may be repeated by
invoking the procedure named by \hyper{variable}.

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

\end{entry}

\subsection{Quasiquotation}\unsection
\label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype} \nopagebreak
\pproto{\backquote\hyper{qq template}}{\exprtype}}

``Backquote'' or ``quasiquote''\index{backquote} expressions are useful
for constructing a list or vector structure when most but not all of the
desired structure is known in advance.  If no
commas\index{comma} appear within the \hyper{qq template}, the result of
evaluating
\backquote\hyper{qq template} is equivalent to the result of evaluating
\singlequote\hyper{qq template}.  If a comma\mainschindex{,} appears within the
\hyper{qq template}, however, the expression following the comma is
evaluated (``unquoted'') and its result is inserted into the structure
instead of the comma and the expression.  If a comma appears followed
immediately by an at-sign (\atsign),\mainschindex{,@} then the following
expression must evaluate to a list; the opening and closing parentheses
of the list are then ``stripped away'' and the elements of the list are
inserted in place of the comma at-sign expression sequence.  A comma
at-sign should only appear within a list or vector \hyper{qq template}.

% struck: "(in the sense of {\cf equal?})" after "equivalent"

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)%
\end{scheme}

Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost backquote.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

The two notations
 \backquote\hyper{qq template} and {\tt (quasiquote \hyper{qq template})}
 are identical in all respects.
 {\cf,\hyper{expression}} is identical to {\cf (unquote \hyper{expression})},
 and
 {\cf,@\hyper{expression}} is identical to {\cf (unquote-splicing \hyper{expression})}.
The external syntax generated by \ide{write} for two-element lists whose
car is one of these symbols may vary between implementations.
\mainschindex{`}

\begin{scheme}
(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  (list 3 4)
'(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  `(list ,(+ 1 2) 4)
     {\em{}i.e.,} (quasiquote (list (unquote (+ 1 2)) 4))%
\end{scheme}

Unpredictable behavior can result if any of the symbols
\ide{quasiquote}, \ide{unquote}, or \ide{unquote-splicing} appear in
positions within a \hyper{qq template} otherwise than as described above.

\end{entry}

\section{Macros}
\label{macrosection}

Scheme programs can define and use new derived expression types,
 called {\em macros}.\mainindex{macro}
Program-defined expression types have the syntax
\begin{scheme}
(\hyper{keyword} {\hyper{datum}} ...)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
expression type.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.  The
number of the \hyper{datum}s, and their syntax, depends on the
expression type.

Each instance of a macro is called a {\em use}\index{macro use}
of the macro.
The set of rules that specifies
how a use of a macro is transcribed into a more primitive expression
is called the {\em transformer}\index{macro transformer}
of the macro.

The macro definition facility consists of two parts:

\begin{itemize}
\item A set of expressions used to establish that certain identifiers
are macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined, and

\item a pattern language for specifying macro transformers.
\end{itemize}

The syntactic keyword of a macro may shadow variable bindings, and local
variable bindings may shadow keyword bindings.  \index{keyword}  All macros
defined using the pattern language  are ``hygienic'' and ``referentially
transparent'' and thus preserve Scheme's lexical scoping~\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}:
\mainindex{hygienic}
\mainindex{referentially transparent}


\begin{itemize}

\item If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers.
Note that a \ide{define} at top level may or may not introduce a binding;
see section~\ref{defines}.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.

\end{itemize}

%The low-level facility permits non-hygienic macros to be written,
%and may be used to implement the high-level pattern language.

% The fourth section describes some features that would make the
% low-level macro facility easier to use directly.

\subsection{Binding constructs for syntactic keywords}
\label{bindsyntax}

{\cf Let-syntax} and {\cf letrec-syntax} are
analogous to {\cf let} and {\cf letrec}, but they bind
syntactic keywords to macro transformers instead of binding variables
to locations that contain values.  Syntactic keywords may also be
bound at top level; see section~\ref{define-syntax}.

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} should have the form
\begin{scheme}
((\hyper{keyword} \hyper{transformer spec}) \dotsfoo)%
\end{scheme}
Each \hyper{keyword} is an identifier,
each \hyper{transformer spec} is an instance of {\cf syntax-rules}, and
\hyper{body} should be a sequence of one or more expressions.  It is an error
for a \hyper{keyword} to appear more than once in the list of keywords
being bound.

\semantics
The \hyper{body} is expanded in the syntactic environment
obtained by extending the syntactic environment of the
{\cf let-syntax} expression with macros whose keywords are
the \hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has \hyper{body} as its region.

\begin{scheme}
(let-syntax ((when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if \schtrue))
    (when if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
Same as for {\cf let-syntax}.

\semantics
 The \hyper{body} is expanded in the syntactic environment obtained by
extending the syntactic environment of the {\cf letrec-syntax}
expression with macros whose keywords are the
\hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{bindings}
as well as the \hyper{body} within its region,
so the transformers can
transcribe expressions into uses of the macros
introduced by the {\cf letrec-syntax} expression.

\begin{scheme}
(letrec-syntax
  ((my-or (syntax-rules ()
            ((my-or) \schfalse)
            ((my-or e) e)
            ((my-or e1 e2 ...)
             (let ((temp e1))
               (if temp
                   temp
                   (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

\end{entry}

\section{Equivalence predicates}
\label{equivalencesection}

A \defining{predicate} is a procedure that always returns a boolean
value (\schtrue{} or \schfalse).  An \defining{equivalence predicate} is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, {\cf eq?}\ is the finest or most
discriminating, and {\cf equal?}\ is the coarsest.  {\cf Eqv?}\ is
slightly less discriminating than {\cf eq?}.  \todo{Pitman doesn't like
this paragraph.  Lift the discussion from the Maclisp manual.  Explain
why there's more than one predicate.}


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns \schtrue{} if \vari{obj} and \varii{obj} should
normally be regarded as the same object.  This relation is left slightly
open to interpretation, but the following partial specification of
{\cf eqv?} holds for all implementations of Scheme.

The {\cf eqv?} procedure returns \schtrue{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are both \schtrue{} or both \schfalse.

\item \vari{obj} and \varii{obj} are both symbols and

\begin{scheme}
(string=? (symbol->string obj1)
          (symbol->string obj2))
    \ev  \schtrue%
\end{scheme}

\begin{note} 
This assumes that neither \vari{obj} nor \varii{obj} is an ``uninterned
symbol'' as alluded to in section~\ref{symbolsection}.  This report does
not presume to specify the behavior of {\cf eqv?} on implementation-dependent
extensions.
\end{note}

\item \vari{obj} and \varii{obj} are both numbers, are numerically
equal (see {\cf =}, section~\ref{numbersection}), and are either both
exact\index{exact} or both inexact\index{inexact}.

\item \vari{obj} and \varii{obj} are both characters and are the same
character according to the {\cf char=?} procedure
(section~\ref{charactersection}).

\item both \vari{obj} and \varii{obj} are the empty list.

\item \vari{obj} and \varii{obj} are pairs, vectors, or strings that denote the
same locations in the store (section~\ref{storagemodel}).

\item \vari{obj} and \varii{obj} are procedures whose location tags are
equal (section~\ref{lambda}).
\end{itemize}

The {\cf eqv?} procedure returns \schfalse{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are of different types
(section~\ref{disjointness}).

\item one of \vari{obj} and \varii{obj} is \schtrue{} but the other is
\schfalse{}.

\item \vari{obj} and \varii{obj} are symbols but

\begin{scheme}
(string=? (symbol->string \vari{obj})
          (symbol->string \varii{obj}))
    \ev  \schfalse%
\end{scheme}

\item one of \vari{obj} and \varii{obj} is an exact number but the other
is an inexact number.

\item \vari{obj} and \varii{obj} are numbers for which the {\cf =}
procedure returns \schfalse{}.

\item \vari{obj} and \varii{obj} are characters for which the {\cf char=?}
procedure returns \schfalse{}.

\item one of \vari{obj} and \varii{obj} is the empty list but the other
is not.

\item \vari{obj} and \varii{obj} are pairs, vectors, or strings that denote
distinct locations.

\item \vari{obj} and \varii{obj} are procedures that would behave differently
(return different value(s) or have different side effects) for some arguments.

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(eqv? \#f 'nil)                  \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))		         \ev  \schtrue%
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified%
\end{scheme}

The next set of examples shows the use of {\cf eqv?}\ with procedures
that have local state.  {\cf Gen-counter} must return a distinct
procedure every time, since each procedure has its own internal counter.
{\cf Gen-loser}, however, returns equivalent procedures each time, since
the local state does not affect the value or side effects of the
procedures.

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

% Objects of distinct types must never be regarded as the same object,
% except that \schfalse{} and the empty list\index{empty list} are permitted to
% be identical.
%
% \begin{scheme}
% (eqv? '() \schfalse)    \ev  \unspecified%
% \end{scheme}

Since it is an error to modify constant objects (those returned by
literal expressions), implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of {\cf eqv?} on constants is sometimes
implementation-dependent.

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

\begin{rationale} 
The above definition of {\cf eqv?} allows implementations latitude in
their treatment of procedures and literals:  implementations are free
either to detect or to fail to detect that two procedures or two literals
are equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf Eq?}\ is similar to {\cf eqv?}\ except that in some cases it is
capable of discerning distinctions finer than those detectable by
{\cf eqv?}.

\vest {\cf Eq?}\ and {\cf eqv?}\ are guaranteed to have the same
behavior on symbols, booleans, the empty list, pairs, procedures,
and non-empty
strings and vectors.  {\cf Eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when {\cf eqv?}\ would also return
true.  {\cf Eq?} may also behave differently from {\cf eqv?} on empty
vectors and empty strings.

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}

\todo{Needs to be explained better above.  How can this be made to be
not confusing?  A table maybe?}

\begin{rationale} It will usually be possible to implement {\cf eq?}\ much
more efficiently than {\cf eqv?}, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute {\cf eqv?}\ of two numbers in
constant time, whereas {\cf eq?}\ implemented as pointer comparison will
always finish in constant time.  {\cf Eq?}\ may be used like {\cf eqv?}\
in applications using procedures to implement objects with state since
it obeys the same constraints as {\cf eqv?}.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{library procedure}}

{\cf Equal?} recursively compares the contents of pairs, vectors, and
strings, applying {\cf eqv?} on other objects such as numbers and symbols.
A rule of thumb is that objects are generally {\cf equal?} if they print
the same.  {\cf Equal?}\ may fail to terminate if its arguments are
circular data structures.

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}

\end{entry}

\section{Numbers}
\label{numbersection}
\index{number}

Numerical computation has traditionally been neglected by the Lisp
community.  Until Common Lisp there was no carefully thought out
strategy for organizing numerical computation, and with the exception of
the MacLisp system \cite{Pitman83} little effort was made to
execute numerical code efficiently.  This report recognizes the excellent work
of the Common Lisp committee and accepts many of their recommendations.
In some ways this report simplifies and generalizes their proposals in a manner
consistent with the purposes of Scheme.

It is important to distinguish between the mathematical numbers, the
Scheme numbers that attempt to model them, the machine representations
used to implement the Scheme numbers, and notations used to write numbers.
This report uses the types \type{number}, \type{complex}, \type{real},
\type{rational}, and \type{integer} to refer to both mathematical numbers
and Scheme numbers.  Machine representations such as fixed point and
floating point are referred to by names such as \type{fixnum} and
\type{flonum}.

%%R4%% I did some reorganizing here to move the discussion of mathematical
% numbers before the discussion of the Scheme numbers, hoping that this
% would help to motivate the discussion of representation independence.

\subsection{Numerical types}
\label{numericaltypes}
\index{numerical types}

%%R4%% A Scheme system provides data of type \type{number}, which is the most
%general numerical type supported by that system.
%\type{Number} is
%likely to be a complicated union type implemented in terms of
%\type{fixnum}s, \type{bignum}s, \type{flonum}s, and so forth, but this
%should not be apparent to a naive user.  What the user should see is
%that the usual operations on numbers produce the mathematically
%expected results, within the limits of the implementation.

%%R4%%  I rewrote the following paragraph to make the various levels of
% the tower into subsets of each other, instead of relating them by
% injections.  I think the injections tended to put people in the frame
% of mind of thinking about coercions between non-overlapping numeric
% types in mainstream programming languages.

\vest Mathematically, numbers may be arranged into a tower of subtypes
%%R4%% with injections relating adjacent levels of the tower:
in which each level is a subset of the level above it:
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{number} \\
\> \tupe{complex} \\
\> \tupe{real} \\
\> \tupe{rational} \\
\> \tupe{integer} 
\end{tabbing}

For example, 3 is an integer.  Therefore 3 is also a rational,
a real, and a complex.  The same is true of the Scheme numbers
that model 3.  For Scheme numbers, these types are defined by the
predicates \ide{number?}, \ide{complex?}, \ide{real?}, \ide{rational?},
and \ide{integer?}.

There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

%%R4%% I moved "Implementations of Scheme are not required to implement
% the whole tower..." to the subsection on implementation restrictions.

Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an implementation
of Scheme may use fixnum, flonum, and perhaps other representations for
numbers, this should not be apparent to a casual programmer writing
simple programs.

It is necessary, however, to distinguish between numbers that are
represented exactly and those that may not be.  For example, indexes
into data structures must be known exactly, as must some polynomial
coefficients in a symbolic algebra system.  On the other hand, the
results of measurements are inherently inexact, and irrational numbers
may be approximated by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers are
required, Scheme explicitly distinguishes exact from inexact numbers.
This distinction is orthogonal to the dimension of type.

\subsection{Exactness}

%%R4%% I tried to direct the following paragraph away from philosophizing
% about the exactness of mathematical numbers, and toward philosophizing
% about the exactness of Scheme numbers.

\mainindex{exactness} \label{exactly}
Scheme numbers are either \type{exact} or \type{inexact}.  A number is
\tupe{exact} if it was written as an exact constant or was derived from
\tupe{exact} numbers using only \tupe{exact} operations.  A number is
\tupe{inexact} if it was written as an inexact constant,
%%R4%% models a quantity (e.g., a measurement) known only approximately,
if it was
derived using \tupe{inexact} ingredients, or if it was derived using
\tupe{inexact} operations. Thus \tupe{inexact}ness is a contagious
property of a number.
%%R4%% The rest of this paragraph (from R3RS) has been dropped.

\vest If two implementations produce \tupe{exact} results for a
computation that did not involve \tupe{inexact} intermediate results,
the two ultimate results will be mathematically equivalent.  This is
generally not true of computations involving \tupe{inexact} numbers
since approximate methods such as floating point arithmetic may be used,
but it is the duty of each implementation to make the result as close as
practical to the mathematically ideal result.

\vest Rational operations such as {\cf +} should always produce
\tupe{exact} results when given \tupe{exact} arguments.
%%R4%%If an implementation is
%unable to represent an \tupe{exact} result (for example, if it does not
%support infinite precision integers and rationals)
If the operation is unable to produce an \tupe{exact} result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an \tupe{inexact} value.
%%R4%%Such a coercion may cause an error later.
See section~\ref{restrictions}.

\vest With the exception of \ide{inexact->exact}, the operations described in
this section must generally return inexact results when given any inexact
arguments.  An operation may, however, return an \tupe{exact} result if it can
prove that the value of the result is unaffected by the inexactness of its
arguments.  For example, multiplication of any number by an \tupe{exact} zero
may produce an \tupe{exact} zero result, even if the other argument is
\tupe{inexact}.

\subsection{Implementation restrictions}

\index{implementation restriction}\label{restrictions}

\vest Implementations of Scheme are not required to implement the whole
tower of subtypes given in section~\ref{numericaltypes},
but they must implement a coherent subset consistent with both the
purposes of the implementation and the spirit of the Scheme language.
For example, an implementation in which all numbers are \tupe{real}
may still be quite useful.

\vest Implementations may also support only a limited range of numbers of
any type, subject to the requirements of this section.  The supported
range for \tupe{exact} numbers of any type may be different from the
supported range for \tupe{inexact} numbers of that type.  For example,
an implementation that uses flonums to represent all its
\tupe{inexact} \tupe{real} numbers may
support a practically unbounded range of \tupe{exact} \tupe{integer}s
and \tupe{rational}s
while limiting the range of \tupe{inexact} \tupe{real}s (and therefore
the range of \tupe{inexact} \tupe{integer}s and \tupe{rational}s)
to the dynamic range of the flonum format.
Furthermore
the gaps between the representable \tupe{inexact} \tupe{integer}s and
\tupe{rational}s are
likely to be very large in such an implementation as the limits of this
range are approached.

\vest An implementation of Scheme must support exact integers
throughout the range of numbers that may be used for indexes of
lists, vectors, and strings or that may result from computing the length of a
list, vector, or string.  The \ide{length}, \ide{vector-length},
and \ide{string-length} procedures must return an exact
integer, and it is an error to use anything but an exact integer as an
index.  Furthermore any integer constant within the index range, if
expressed by an exact integer syntax, will indeed be read as an exact
integer, regardless of any implementation restrictions that may apply
outside this range.  Finally, the procedures listed below will always
return an exact integer result provided all their arguments are exact integers
and the mathematically expected result is representable as an exact integer
within the implementation:

\begin{scheme}
+            -             *
quotient     remainder     modulo
max          min           abs
numerator    denominator   gcd
lcm          floor         ceiling
truncate     round         rationalize
expt%
\end{scheme}

\vest Implementations are encouraged, but not required, to support
\tupe{exact} \tupe{integer}s and \tupe{exact} \tupe{rational}s of
practically unlimited size and precision, and to implement the
above procedures and the {\cf /} procedure in
such a way that they always return \tupe{exact} results when given \tupe{exact}
arguments.  If one of these procedures is unable to deliver an \tupe{exact}
result when given \tupe{exact} arguments, then it may either report a
violation of an
implementation restriction or it may silently coerce its result to an
\tupe{inexact} number.  Such a coercion may cause an error later.

%%R4%% I moved this stuff here.
% It seems to me that the only thing that this requires is that
% implementations that support inexact numbers have to have both
% exact and inexact representations for the integers 0 through 15.
% If that's what it's saying, I'd rather say it that way.
% On the other hand, letting the limit be as small as 15 sounds a
% tad silly, though I think I understand how that number was arrived at.
% (Or is 35 the number?)
%
%Implementations are encouraged, but not required, to support \tupe{inexact}
%numbers.  For any implementation that supports \tupe{inexact} numbers,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include all non-negative
%integers up to some limit specified by the implementation.  This limit
%must be 16 or greater.  The
%\ide{exact\coerce{}inexact} and \ide{inexact\coerce{}exact}
%procedures implement the natural one-to-one correspondence between
%the \tupe{inexact} and \tupe{exact} integers within this range.

\vest An implementation may use floating point and other approximate 
representation strategies for \tupe{inexact} numbers.
%%R4%% The following sentence seemed a bit condescending as well as
% awkward.  It didn't seem to be very enforceable, so I flushed it.
%
%This is not to
%say that implementors need not use the best known algorithms for
%\tupe{inexact} computations---only that approximate methods of high
%quality are allowed.
%
This report recommends, but does not require, that the IEEE 32-bit
and 64-bit floating point standards be followed by implementations that use
flonum representations, and that implementations using
other representations should match or exceed the precision achievable
using these floating point standards~\cite{IEEE}.

\vest In particular, implementations that use flonum representations
must follow these rules: A \tupe{flonum} result
must be represented with at least as much precision as is used to express any of
the inexact arguments to that operation.  It is desirable (but not required) for
potentially inexact operations such as {\cf sqrt}, when applied to \tupe{exact}
arguments, to produce \tupe{exact} answers whenever possible (for example the
square root of an \tupe{exact} 4 ought to be an \tupe{exact} 2).
If, however, an
\tupe{exact} number is operated upon so as to produce an \tupe{inexact} result
(as by {\cf sqrt}), and if the result is represented as a \tupe{flonum}, then
the most precise \tupe{flonum} format available must be used; but if the result
is represented in some other way then the representation must have at least as
much precision as the most precise \tupe{flonum} format available.

Although Scheme allows a variety of written
%%R4%% representations of 
notations for
numbers, any particular implementation may support only some of them.
%%R4%%
For example, an implementation in which all numbers are \tupe{real}
need not support the rectangular and polar notations for complex
numbers.  If an implementation encounters an \tupe{exact} numerical constant that
it cannot represent as an \tupe{exact} number, then it may either report a
violation of an implementation restriction or it may silently represent the
constant by an \tupe{inexact} number.


\subsection{Numerical operations}

The reader is referred to section~\ref{typeconventions} for a summary
of the naming conventions used to specify restrictions on the types of
arguments to numerical routines.
%%R4%% The following sentence has already been said twice, and the
% term "exactness-preserving" is no longer defined by the Report.
%
%  Remember that
%an exactness-preserving operation may coerce its result to inexact if the
%implementation is unable to represent it exactly.
The examples used in this section assume that any numerical constant written
using an \tupe{exact} notation is indeed represented as an \tupe{exact}
number.  Some examples also assume that certain numerical constants written
using an \tupe{inexact} notation can be represented without loss of
accuracy; the \tupe{inexact} constants were chosen so that this is
likely to be true in implementations that use flonums to represent
inexact numbers.

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object is
of the named type, and otherwise they return \schfalse{}.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
%%R4%% The new section on implementation restrictions subsumes: 
% Not every system
%supports all of these types; for example, it is entirely possible to have a
%Scheme system that has only \tupe{integer}s.  Nonetheless every implementation
%of Scheme must have all of these predicates.

If \vr{z} is an inexact complex number, then {\cf (real? \vr{z})} is true if
and only if {\cf (zero? (imag-part \vr{z}))} is true.  If \vr{x} is an inexact
real number, then {\cf (integer? \vr{x})} is true if and only if
{\cf (= \vr{x} (round \vr{x}))}.

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schtrue
(real? \#e1e10)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
The behavior of these type predicates on \tupe{inexact} numbers
is unreliable, since any inaccuracy may affect the result.
\end{note}

\begin{note}
In many implementations the \ide{rational?} procedure will be the same
as \ide{real?}, and the \ide{complex?} procedure will be the same as
\ide{number?}, but unusual implementations may be able to represent
some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{procedure}
\proto{inexact?}{ \vr{z}}{procedure}}

These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates
is true.

\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{procedure}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}}

%- Some implementations allow these procedures to take many arguments, to 
%- facilitate range checks.  
These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

These predicates are required to be transitive.

\begin{note}
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
\end{note}

\begin{note}
While it is not an error to compare \tupe{inexact} numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of \ide{=} and \ide{zero?}.
When in doubt, consult a numerical analyst.
\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{library procedure}
\proto{positive?}{ \vr{x}}{library procedure}
\proto{negative?}{ \vr{x}}{library procedure}
\proto{odd?}{ \vr{n}}{library procedure}
\proto{even?}{ \vr{n}}{library procedure}}

These numerical predicates test a number for a particular property,
returning \schtrue{} or \schfalse.  See note above.

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{library procedure}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{library procedure}}

These procedures return the maximum or minimum of their arguments.

\begin{scheme}
(max 3 4)              \ev  4    ; exact
(max 3.9 4)            \ev  4.0  ; inexact%
\end{scheme}

\begin{note}
If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If {\cf min} or
{\cf max} is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{procedure}
\proto{*}{ \vri{z} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.
%- These procedures are exactness preserving.

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vri{z} \vrii{z}}{procedure}
\rproto{-}{ \vr{z}}{procedure}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{optional procedure}
\proto{/}{ \vri{z} \vrii{z}}{procedure}
\rproto{/}{ \vr{z}}{procedure}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{optional procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.
%- These procedures are exactness preserving, except that division may
%- coerce its result to inexact in implementations that do not support
%- \tupe{ratnum}s. 

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{library procedure}}

{\cf Abs} returns the absolute value of its argument.  
%- {\cf Abs} is exactness preserving when its argument is real.
\begin{scheme}
(abs -7)                \ev  7
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{modulo}{ \vri{n} \vrii{n}}{procedure}}

These procedures implement number-theoretic (integer)
division.  \vrii{n} should be non-zero.  All three procedures
return integers.  If \vri{n}/\vrii{n} is an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vri{n}/\vrii{n}
    (remainder \vri{n} \vrii{n})  \ev 0
    (modulo \vri{n} \vrii{n})     \ev 0
\end{scheme}
If \vri{n}/\vrii{n} is not an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vr{n_q}
    (remainder \vri{n} \vrii{n})  \ev \vr{n_r}
    (modulo \vri{n} \vrii{n})     \ev \vr{n_m}
\end{scheme}
where \vr{n_q} is $\vri{n}/\vrii{n}$ rounded towards zero,
$0 < |\vr{n_r}| < |\vrii{n}|$, $0 < |\vr{n_m}| < |\vrii{n}|$,
\vr{n_r} and \vr{n_m} differ from \vri{n} by a multiple of \vrii{n},
\vr{n_r} has the same sign as \vri{n}, and
\vr{n_m} has the same sign as \vrii{n}.

From this we can conclude that for integers \vri{n} and \vrii{n} with
\vrii{n} not equal to 0,
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (quotient \vri{n} \vrii{n}))
           (remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
provided all numbers involved in that computation are exact.

\begin{scheme}
(modulo 13 4)           \ev  1
(remainder 13 4)        \ev  1

(modulo -13 4)          \ev  3
(remainder -13 4)       \ev  -1

(modulo 13 -4)          \ev  -3
(remainder 13 -4)       \ev  1

(modulo -13 -4)         \ev  -1
(remainder -13 -4)      \ev  -1

(remainder -13 -4.0)    \ev  -1.0  ; inexact%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{library procedure}
\proto{lcm}{ \vri{n} \dotsfoo}{library procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.
%- These procedures are exactness preserving.

%%R4%% I added the inexact example.
\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; inexact
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{procedure}
\proto{denominator}{ \vr{q}}{procedure}}

These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
%- The remarks about denominators are new.
%- Clearly, they are exactness-preserving procedures.
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (exact->inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}
}

These procedures return integers.
\vest {\cf Floor} returns the largest integer not larger than \vr{x}.
{\cf Ceiling} returns the smallest integer not smaller than~\vr{x}.
{\cf Truncate} returns the integer closest to \vr{x} whose absolute
value is not larger than the absolute value of \vr{x}.  {\cf Round} returns the
closest integer to \vr{x}, rounding to even when \vr{x} is halfway between two
integers.

\begin{rationale}
{\cf Round} rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

\begin{note}
If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the {\cf inexact->exact} procedure.
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; inexact

(round 7/2)           \ev  4    ; exact
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{library procedure}
%- \proto{rationalize}{ x}{procedure}
}

{\cf Rationalize} returns the {\em simplest} rational number
differing from \vr{x} by no more than \vr{y}.  A rational number $r_1$ is
{\em simpler} \mainindex{simplest rational} than another rational number
$r_2$ if $r_1 = p_1/q_1$ and $r_2 = p_2/q_2$ (in lowest terms) and $|p_1|
\leq |p_2|$ and $|q_1| \leq |q_2|$.  Thus $3/5$ is simpler than $4/7$.
Although not all rationals are comparable in this ordering (consider $2/7$
and $3/5$) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler $2/5$ lies
between $2/7$ and $3/5$).  Note that $0 = 0/1$ is the simplest rational of
all.

\begin{scheme}
(rationalize
  (inexact->exact .3) 1/10)  \ev 1/3    ; exact
(rationalize .3 1/10)        \ev \#i1/3  ; inexact%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{procedure}
\proto{log}{ \vr{z}}{procedure}
\proto{sin}{ \vr{z}}{procedure}
\proto{cos}{ \vr{z}}{procedure}
\proto{tan}{ \vr{z}}{procedure}
\proto{asin}{ \vr{z}}{procedure}
\proto{acos}{ \vr{z}}{procedure}
\proto{atan}{ \vr{z}}{procedure}
\rproto{atan}{ \vr{y} \vr{x}}{procedure}}

These procedures are part of every implementation that supports
%%R4%%
general
real numbers; they compute the usual transcendental functions.  {\cf Log}
computes the natural logarithm of \vr{z} (not the base ten logarithm).
{\cf Asin}, {\cf acos}, and {\cf atan} compute arcsine ($\sin^{-1}$),t
arccosine ($\cos^{-1}$), and arctangent ($\tan^{-1}$), respectively.
The two-argument variant of {\cf atan} computes {\tt (angle
(make-rectangular \vr{x} \vr{y}))} (see below), even in implementations
that don't support general complex numbers.

In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of $\log z$ is defined to be the one whose imaginary
part lies in the range from $-\pi$ (exclusive) to $\pi$ (inclusive).
$\log 0$ is undefined.
With $\log$ defined this way, the values of $\sin^{-1} z$, $\cos^{-1} z$,
and $\tan^{-1} z$ are according to the following formul\ae:
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

The above specification follows~\cite{CLtL}, which in turn
cites~\cite{Penfield81}; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.

%%R4%%
\todo{The cited references are likely to change their branch cuts
soon to allow for the possibility of distinct positive and negative
zeroes, as in IEEE floating point.  We may not want to follow those
changes, since we may want a complex number with zero imaginary part
(whether positive or negative zero) to be treated as a real.  I don't
think there are any better standards for complex arithmetic than the
ones cited, so we're really on our own here.}

\end{entry}


\begin{entry}{%
\proto{sqrt}{ \vr{z}}{procedure}}

Returns the principal square root of \vr{z}.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{procedure}}

Returns \vri{z} raised to the power \vrii{z}.  For $z_1 \neq 0$
$${z_1}^{z_2} = e^{z_2 \log {z_1}}$$
$0^z$ is 1 if $z = 0$ and 0 otherwise.
\end{entry}

%- \begin{entry}{%- 
%- \proto{approximate}{ z x}{procedure}}
%- 
%- Returns an approximation to \vr{z} in a representation whose precision is
%- the same as that 
%- of the representation of \vr{x}, which must be an inexact number.  The
%- result is always inexact.
%- 
%- \begin{scheme}
%- (approximate 3.1415926535 1F10)
%-         \ev  3.14159F0
%- (approximate 3.1415926535 \#I65535)
%-         \ev \#I3
%- (approximate 3.14F0 1L8)
%-         \ev  3.14L0
%- (approximate 3.1415926535F0 1L8)
%-         \ev  3.14159L0
%- \end{scheme}
%- \end{entry}



\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{procedure}
\proto{make-polar}{ \vriii{x} \vriv{x}}{procedure}
\proto{real-part}{ \vr{z}}{procedure}
\proto{imag-part}{ \vr{z}}{procedure}
\proto{magnitude}{ \vr{z}}{procedure}
\proto{angle}{ \vr{z}}{procedure}}

These procedures are part of every implementation that supports
%%R4%%
general
complex numbers.  Suppose \vri{x}, \vrii{x}, \vriii{x}, and \vriv{x} are
real numbers and \vr{z} is a complex number such that
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{{\displaystyle{\hbox{$i$}} \vriv{x}}}$$
Then
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$
\end{scheme}
where $-\pi < x_{angle} \le \pi$ with $x_{angle} = \vriv{x} + 2\pi n$
for some integer $n$.

\begin{rationale}
{\cf Magnitude} is the same as \ide{abs} for a real argument,
but {\cf abs} must be present in all implementations, whereas
{\cf magnitude} need only be present in implementations that support
general complex numbers.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{exact->inexact}{ \vr{z}}{procedure}
\proto{inexact->exact}{ \vr{z}}{procedure}}

{\cf Exact\coerce{}inexact} returns an \tupe{inexact} representation of \vr{z}.
The value returned is the
\tupe{inexact} number that is numerically closest to the argument.  
%%R4%%For
%\tupe{exact} arguments which have no reasonably close \tupe{inexact} equivalent,
%it is permissible to signal an error.
If an \tupe{exact} argument has no reasonably close \tupe{inexact} equivalent,
then a violation of an implementation restriction may be reported.

{\cf Inexact\coerce{}exact} returns an \tupe{exact} representation of
\vr{z}.  The value returned is the \tupe{exact} number that is numerically
closest to the argument.
%%R4%%  For \tupe{inexact} arguments which have no
%reasonably close \tupe{exact} equivalent, it is permissible to signal
%an error.
If an \tupe{inexact} argument has no reasonably close \tupe{exact} equivalent,
then a violation of an implementation restriction may be reported.

%%R%% I moved this to the section on implementation restrictions.
%For any implementation that supports \tupe{inexact} quantities,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include the non-negative
%integers up to a limit specified by the implementation.  The limit
%must be big enough to represent all digits in reasonable radices, and
%may correspond to some natural word size for the implementation.  For
%such integers, these procedures implement the natural one-to-one
%correspondence between the representations.

These procedures implement the natural one-to-one correspondence between
\tupe{exact} and \tupe{inexact} integers throughout an
implementation-dependent range.  See section~\ref{restrictions}.

\end{entry}

\medskip

\subsection{Numerical input and output}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}}

\vr{Radix} must be an exact integer, either 2, 8, 10, or 16.  If omitted,
\vr{radix} defaults to 10.
The procedure {\cf number\coerce{}string} takes a
number and a radix and returns as a string an external representation of
the given number in the given radix such that
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))
\end{scheme}
is true.  It is an error if no possible result makes this expression true.

If \vr{z} is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent and trailing
zeroes) needed to make the above expression
true~\cite{howtoprint,howtoread};
otherwise the format of the result is unspecified.

The result returned by {\cf number\coerce{}string}
never contains an explicit radix prefix.

\begin{note}
The error case can occur only when \vr{z} is not a complex number
or is a complex number with a non-rational real or imaginary part.
\end{note}

\begin{rationale}
If \vr{z} is an inexact number represented using flonums, and
the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}

%%R4%% I didn't include the (string->number string radix exactness)
% case, since I haven't heard any resolution of the coding to be used
% for the third argument.

Returns a number of the maximally precise representation expressed by the
given \vr{string}.  \vr{Radix} must be an exact integer, either 2, 8, 10,
or 16.  If supplied, \vr{radix} is a default radix that may be overridden
by an explicit radix prefix in \vr{string} (e.g. {\tt "\#o177"}).  If \vr{radix}
is not supplied, then the default radix is 10.  If \vr{string} is not
a syntactically valid notation for a number, then {\cf string->number}
returns \schfalse{}.

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0
(string->number "15\#\#")       \ev  1500.0%
\end{scheme}

\begin{note}
The domain of {\cf string->number} may be restricted by implementations
in the following ways.  {\cf String->number} is permitted to return
\schfalse{} whenever \vr{string} contains an explicit radix prefix.
If all numbers supported by an implementation are real, then
{\cf string->number} is permitted to return \schfalse{} whenever
\vr{string} uses the polar or rectangular notations for complex
numbers.  If all numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
the fractional notation is used.  If all numbers are exact, then
{\cf string->number} may return \schfalse{} whenever
an exponent marker or explicit exactness prefix is used, or if
a {\tt \#} appears in place of a digit.  If all inexact
numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
a decimal point is used.
\end{note}

\end{entry}

\section{Booleans}
\label{booleansection}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}  What really
matters, though, are the objects that the Scheme conditional expressions
({\cf if}, {\cf cond}, {\cf and}, {\cf or}, {\cf do}) treat as
true\index{true} or false\index{false}.  The phrase ``a true value''\index{true}
(or sometimes just ``true'') means any object treated as true by the
conditional expressions, and the phrase ``a false value''\index{false} (or
``false'') means any object treated as false by the conditional expressions.

\vest Of all the standard Scheme values, only \schfalse{}
% is guaranteed to count
counts as false in conditional expressions.
%  It is not
% specified whether the empty list\index{empty list} counts as false
% or as true in conditional expressions.
Except for \schfalse{},
% and possibly the empty list,
all standard Scheme values, including \schtrue,
pairs, the empty list, symbols, numbers, strings, vectors, and procedures,
count as true.

%\begin{note}
%In some implementations the empty list counts as false, contrary
%to the above.
%Nonetheless a few examples in this report assume that the
%empty list counts as true, as in \cite{IEEEScheme}.
%\end{note}

% \begin{rationale}
% For historical reasons some implementations regard \schfalse{} and the
% empty list as the same object.  These implementations therefore cannot
% make the empty list count as true in conditional expressions.
% \end{rationale}

\begin{note}
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both \schfalse{} and the empty list \index{empty list}
from the symbol \ide{nil}.
\end{note}

\vest Boolean constants evaluate to themselves, so they do not need to be quoted
in programs.

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{library procedure}}

{\cf Not} returns \schtrue{} if \var{obj} is false, and returns
\schfalse{} otherwise.

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{library procedure}}

{\cf Boolean?} returns \schtrue{} if \var{obj} is either \schtrue{} or
\schfalse{} and returns \schfalse{} otherwise.

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

 
\section{Pairs and lists}
\label{listsection}

A \defining{pair} (sometimes called a \defining{dotted pair}) is a
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure {\cf cons}.
The car and cdr fields are accessed by the procedures {\cf car} and
{\cf cdr}.  The car and cdr fields are assigned by the procedures
{\cf set-car!}\ and {\cf set-cdr!}.

Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list\index{empty list} or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set \var{X} such that

\begin{itemize}
\item The empty list is in \var{X}.
\item If \var{list} is in \var{X}, then any pair whose cdr field contains
      \var{list} is also in \var{X}.
\end{itemize}

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

The empty list\mainindex{empty list} is a special object of its own type
(it is not a pair); it has no elements and its length is zero.

\begin{note}
The above definitions imply that all lists have finite length and are
terminated by the empty list.
\end{note}

A chain of pairs not ending in the empty list is called an
\defining{improper list}.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

\begin{scheme}
(a b c . d)%
\end{scheme}

is equivalent to

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

Whether a given pair is a list depends upon what is stored in the cdr
field.  When the \ide{set-cdr!} procedure is used, an object can be a
list one moment and not the next:

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

%It is often convenient to speak of a homogeneous list of objects
%of some particular data type, as for example \hbox{\cf (1 2 3)} is a list of
%integers.  To be more precise, suppose \var{D} is some data type.  (Any
%predicate defines a data type consisting of those objects of which the
%predicate is true.)  Then
%
%\begin{itemize}
%\item The empty list is a list of \var{D}.
%\item If \var{list} is a list of \var{D}, then any pair whose cdr is
%      \var{list} and whose car is an element of the data type \var{D} is also a
%      list of \var{D}.
%\item There are no other lists of \var{D}.
%\end{itemize}

Within literal expressions and representations of objects read by the
\ide{read} procedure, the forms \singlequote\hyper{datum}\schindex{'},
\backquote\hyper{datum}, {\tt,}\hyper{datum}\schindex{,}, and
{\tt,@}\hyper{datum} denote two-ele\-ment lists whose first elements are
the symbols \ide{quote}, \ide{quasiquote}, \hbox{\ide{unquote}}, and
\ide{unquote-splicing}, respectively.  The second element in each case
is \hyper{datum}.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  \todo{Can or need this be stated
more carefully?} That is, according to Scheme's grammar, every
\meta{expression} is also a \meta{datum} (see section~\ref{datum}).
Among other things, this permits the use of the {\cf read} procedure to
parse Scheme programs.  See section~\ref{externalreps}. 
 

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

{\cf Pair?} returns \schtrue{} if \var{obj} is a pair, and otherwise
returns \schfalse.

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

Returns a newly allocated pair whose car is \vari{obj} and whose cdr is
\varii{obj}.  The pair is guaranteed to be different (in the sense of
{\cf eqv?}) from every existing object.

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the car field of \var{pair}.  Note that it is an
error to take the car of the empty list\index{empty list}.

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the cdr field of \var{pair}.
Note that it is an error to take the cdr of the empty list.

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}  
Stores \var{obj} in the car field of \var{pair}.
The value returned by {\cf set-car!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Stores \var{obj} in the cdr field of \var{pair}.
The value returned by {\cf set-cdr!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{library procedure}


\begin{entry}{%
\proto{caar}{ pair}{library procedure}
\proto{cadr}{ pair}{library procedure}
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}
\proto{cdddar}{ pair}{library procedure}
\proto{cddddr}{ pair}{library procedure}}

These procedures are compositions of {\cf car} and {\cf cdr}, where
for example {\cf caddr} could be defined by

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{library procedure}}

Returns \schtrue{} if \var{obj} is the empty list\index{empty list},
otherwise returns \schfalse.

% \begin{note}
% In implementations in which the empty
% list is the same as \schfalse{}, {\cf null?} will return \schtrue{}
% if \var{obj} is \schfalse{}.
% \end{note}
 
\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{library procedure}}

Returns \schtrue{} if \var{obj} is a list, otherwise returns \schfalse{}.
By definition, all lists have finite length and are terminated by
the empty list.

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{library procedure}}

Returns a newly allocated list of its arguments.

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{library procedure}}

\nodomain{\var{List} must be a list.}
Returns the length of \var{list}.

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{library procedure}}

\nodomain{All \var{list}s should be lists.}
Returns a list consisting of the elements of the first \var{list}
followed by the elements of the other \var{list}s.

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}

The resulting list is always newly allocated, except that it shares
structure with the last \var{list} argument.  The last argument may
actually be any object; an improper list results if the last argument is not a
proper list.  \todo{This is pretty awkward.  I should get Bartley to fix this.}

\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{library procedure}}

\nodomain{\var{List} must be a list.}
Returns a newly allocated list consisting of the elements of \var{list}
in reverse order.

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{library procedure}}

Returns the sublist of \var{list} obtained by omitting the first \vr{k}
elements.  It is an error if \var{list} has fewer than \vr{k} elements.
{\cf List-tail} could be defined by

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{library procedure}}

Returns the \vr{k}th element of \var{list}.  (This is the same
as the car of {\tt(list-tail \var{list} \vr{k})}.)
It is an error if \var{list} has fewer than \vr{k} elements.

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (inexact->exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}


%\begin{entry}{%
%\proto{last-pair}{ list}{library procedure}}
%
%Returns the last pair in the nonempty, possibly improper, list \var{list}.
%{\cf Last-pair} could be defined by
%
%\begin{scheme}
%(define last-pair
%  (lambda (x)
%    (if (pair? (cdr x))
%        (last-pair (cdr x))
%        x)))%
%\end{scheme} 
% 
%\end{entry}


\begin{entry}{%
\proto{memq}{ obj list}{library procedure}
\proto{memv}{ obj list}{library procedure}
\proto{member}{ obj list}{library procedure}}

These procedures return the first sublist of \var{list} whose car is
\var{obj}, where the sublists of \var{list} are the non-empty lists
returned by {\tt (list-tail \var{list} \var{k})} for \var{k} less
than the length of \var{list}.  If
\var{obj} does not occur in \var{list}, then \schfalse{} (not the empty list) is
returned.  {\cf Memq} uses {\cf eq?}\ to compare \var{obj} with the elements of
\var{list}, while {\cf memv} uses {\cf eqv?}\ and {\cf member} uses {\cf equal?}.

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{library procedure}
\proto{assv}{ obj alist}{library procedure}
\proto{assoc}{ obj alist}{library procedure}}

\domain{\var{Alist} (for ``association list'') must be a list of
pairs.}  These procedures find the first pair in \var{alist} whose car field is \var{obj},
and returns that pair.  If no pair in \var{alist} has \var{obj} as its
car, then \schfalse{} (not the empty list) is returned.  {\cf Assq} uses
{\cf eq?}\ to compare \var{obj} with the car fields of the pairs in \var{alist},
while {\cf assv} uses {\cf eqv?}\ and {\cf assoc} uses {\cf equal?}.

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
Although they are ordinarily used as predicates,
{\cf memq}, {\cf memv}, {\cf member}, {\cf assq}, {\cf assv}, and {\cf assoc} do not
have question marks in their names because they return useful values rather
than just \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}


\section{Symbols}
\label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eqv?}) if and only if their
names are spelled the same way.  This is exactly the property needed to
represent identifiers\index{identifier} in programs, and so most
implementations of Scheme use them internally for that purpose.  Symbols
are useful for many other applications; for instance, they may be used
the way enumerated values are used in Pascal.

A symbol literal is formed using {\cf quote}.  Any character within a
symbol literal may be specified by its scalar value, using the {\tt
  \sharpsign\backwhack{}x} escape notation.

\begin{scheme}
Hello \ev Hello
'H\backwhack{}x65;llo \ev Hello
'$\lambda$ \ev $\lambda$
'\backwhack{}x3BB; \ev $\lambda$
(string->symbol "a b") \ev a\backwhack{}x20;b
(string->symbol "a\backwhack{}\backwhack{}b") \ev a\backwhack{}x5C;b
'a\backwhack{}x20;b \ev a\backwhack{}x20;b
'|a b| \>\>; \emph{parse error}
\>\>\textrm{; (illegal character}
\>\>\textrm{; vertical bar)}
'a\backwhack{}nb  \>\>; \emph{parse error}
\>\>\textrm{; (illegal use of backslash)}
'a\backwhack{}x20 \>\>; \emph{parse error}
\>\>\textrm{; (missing semi-colon to}
\>\>\textrm{; terminate \backwhack{}x escape)}
\end{scheme}

\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as a string.  It is an error
to apply mutation procedures like \ide{string-set!} to strings returned
by this procedure.

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}. 

\begin{scheme}
(eq? 'mISSISSIppi 'mississippi)  \lev  \schfalse
(string->symbol "mISSISSIppi")  \lev%
  {\rm{}the symbol with name} "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{Characters}
\label{charactersection}

\mainindex{Unicode}
\mainindex{scalar value}

\defining{Characters} are objects that represent Unicode scalar
values~\cite{Unicode41}.

\begin{note}
  Unicode defines a standard mapping between sequences of {\em code
  points}\mainindex{code point} (integers in the range 0 to \#x10FFFF
  in the latest version of the standard) and human-readable
  ``characters.'' More precisely, Unicode distinguishes between
  glyphs, which are printed for humans to read, and characters, which
  are abstract entities that map to glyphs (sometimes in a way that's
  sensitive to surrounding characters).  Furthermore, different
  sequences of code points sometimes correspond to the same character.
  The relationships among code points, characters, and glyphs are
  subtle and complex.

  Despite this complexity, most things that a literate human would
  call a ``character'' can be represented by a single code point in
  Unicode (though there may exist code-point sequences that represent
  that same character). For example, Roman letters, Cyrillic letters,
  Hebrew consonants, and most Chinese characters fall into this
  category. Thus, the ``code point'' approximation of ``character''
  works well for many purposes. It is thus appropriate to define
  Scheme characters as Unicode {\em scalar values}\mainindex{scalar
    value}, which includes all code points except those designated as
  surrogates. A \defining{surrogate} is a code point in the range
  \#xD800 to \#xDFFF that is used in pairs in the UTF-16 encoding to
  encode a supplementary character (whose code is in the range
  \#x10000 to \#x10FFFF).
\end{note}


%There is no requirement that the data type of
%characters be disjoint from other data types; implementations are
%encouraged to have a separate character data type, but may choose to
%represent characters as integers, strings, or some other type.

\todo{Fix}
Characters written in the \sharpsign\backwhack{} notation are self-evaluating.
That is, they do not have to be quoted in programs.  
%The \sharpsign\backwhack{}
%notation is not an essential part of Scheme, however.  Even implementations
%that support the \sharpsign\backwhack{} notation for input do not have to
%support it for output.

\vest Some of the procedures that operate on characters ignore the
difference between upper case and lower case.  The procedures that
ignore case have \hbox{``{\tt -ci}''} (for ``case
insensitive'') embedded in their names.


\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}

\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{n}}{procedure}}

Given a character, {\cf char\coerce{}integer} returns its scalar value
as an exact integer.  Given an exact integer that is
s scalar value, i.e.\ a number in $\left[0, \#x\textrm{D7FF}\right] \cup
\left[\#x\textrm{E000}, \#x\textrm{10FFFF}\right]$,
{\cf integer\coerce{}char}
returns its associated character.

\begin{scheme}
(integer->char 32) \ev \sharpsign\backwhack{}space
(char->integer (integer->char 5000))
\ev 5000
(integer->char \sharpsign{}xD800) \ev \textit{error}
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}}

\label{characterequality}
\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures impose a total ordering on the set of characters
according to their scalar values.

\begin{scheme}
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}\ss) \ev \schtrue
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{char-upcase}{ char}{library procedure}
\proto{char-downcase}{ char}{library procedure}
\proto{char-titlecase}{ char}{library procedure}
\proto{char-foldcase}{ char}{library procedure}}

\nodomain{\var{Char} must be a character.}
These procedures take a character argument and return a character
result. If the argument is an upper case or title case character, and if
there is a single character which is its lower case form, then
{\cf char-downcase} returns that character. If the argument is a lower case
or title case character, and if there is a single character which is
its uppercase form, then {\cf char-upcase} returns that character.
If the argument is a lower case
or upper case character, and if there is a single character which is
its titlecase form, then {\cf char-titlecase} returns that character.
Finally, if the character has a case-folded character, {\cf char-foldcase}
returns that character. Otherwise, the character returned is the same
as the argument. For Turkic characters \.I ({\tt \#\backwhack{}x130})
and \i{} ({\tt \#\backwhack{}x131}),
{\cf char-foldcase} behaves as the identity function, otherwise it is the
same as {\cf char-downcase} composed with {\cf char-upcase}.
%
Otherwise, the character returned is the same as the argument.

\begin{scheme}
(char-upcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-downcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i
(char-titlecase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-foldcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i

(char-upcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-downcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-titlecase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-foldcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss

(char-upcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$
(char-titlecase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$

(char-upcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\varsigma$
(char-titlecase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\sigma$
\end{scheme}

\begin{note}
  Unicode defines locale-independent mappings from scalar values to
  scalar values for upcase, downcase, titlecase, and case-folding
  operations. (These mappings can be extracted from {\cf
    UnicodeData.txt} and {\cf CaseFolding.txt} from the Unicode
  Consortium, ignoring Turkic mappings in the latter.) These
  procedures map characters consistent with the Unicode specification.

  Note that these character-based procedures are an incomplete
  approximation to case conversion, even ignoring the user's locale;
  in general, case mappings require the context of a string, both in
  arguments and in result. See {\cf string-upcase} and {\cf
    string-downcase} for more general case-conversion procedures.
\end{note}
\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{library procedure}
\proto{char-ci<?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{library procedure}
\proto{char-ci>?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{library procedure}
\proto{char-ci<=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{library procedure}
\proto{char-ci>=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{library procedure}}

\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures are similar to {\cf char=?}\ et cetera, but operate
on the case-folded versions of the characters.

\begin{scheme}
(char-ci<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse
(char-ci=? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schtrue
(char-ci=? \sharpsign\backwhack{}$\varsigma$ \sharpsign\backwhack{}$\sigma$) \ev \schtrue
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{library procedure}
\proto{char-numeric?}{ char}{library procedure}
\proto{char-whitespace?}{ char}{library procedure}
\proto{char-upper-case?}{ letter}{library procedure}
\proto{char-lower-case?}{ letter}{library procedure}
\proto{char-title-case?}{ letter}{library procedure}}

These procedures return \schtrue{} if their arguments are alphabetic,
numeric, whitespace, upper case, lower case, or title case characters,
respectively, otherwise they return \schfalse.

A character is alphabetic if it is a Unicode letter, i.e.\ if it is in
one of categories Lu, Ll, Lt, Lm, and Lo.  A character is numeric if
it is in categeory Nd.  A characters is whitespace if it is in one of
the space, line, or paragraph separator categories (Zs, Zl or Zp), or
if is Unicode 9 (Horizontal tabulation), Unicode 10 (Line feed),
Unicode 11 (Vertical tabulation), Unicode 12 (Form feed), or Unicode
13 (Carriage return).  A character is upper case if it has the Unicode
``Uppercase'' property, lower case if it has the ``Lowercase''
property, and title case if it is in the Lt general category,
respectively.

\begin{scheme}
(char-alphabetic? \sharpsign\backwhack{}a) \ev \schtrue{}
(char-numeric? \sharpsign\backwhack{}1) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}space) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}x00A0) \ev \schtrue{}
(char-upper-case? \sharpsign\backwhack{}$\Sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}$\sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}x00AA) \ev \schtrue{}
(char-title-case? \sharpsign\backwhack{}I) \ev \schfalse{}
(char-title-case? \sharpsign\backwhack{}x01C5) \ev \schtrue{}
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{char-general-category}{ char}{library procedure}}

This procedure takes a character and returns a symbol representing its
Unicode general category, one of \ide{lu}, \ide{ll}, \ide{lt},
\ide{lm}, \ide{lo}, \ide{mn}, \ide{mc}, \ide{me}, \ide{nd}, \ide{nl},
\ide{no}, \ide{ps}, \ide{pe}, \ide{pi}, \ide{pf}, \ide{pd}, \ide{pc},
\ide{po}, \ide{sc}, \ide{sm}, \ide{sk}, \ide{so}, \ide{zs}, \ide{zp},
\ide{zl}, \ide{cc}, \ide{cf}, \ide{cs}, \ide{co}, or \ide{cn}.

\begin{scheme}
(char-general-category \#\backwhack{}a) \ev ll
(char-general-category \#\backwhack{}space) \lev zs
(char-general-category \#\backwhack{}x10FFFF) \lev cn  
\end{scheme}
\end{entry}


\section{Strings}
\label{stringsection}

Strings are sequences of characters.  

\vest The {\em length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed when the
string is created.  The \defining{valid indexes} of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

\vest In phrases such as ``the characters of \var{string} beginning with
index \var{start} and ending with index \var{end},'' it is understood
that the index \var{start} is inclusive and the index \var{end} is
exclusive.  Thus if \var{start} and \var{end} are the same index, a null
substring is referred to, and if \var{start} is zero and \var{end} is
the length of \var{string}, then the entire string is referred to.

\vest Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The versions that ignore case
have \hbox{``{\cf -ci}''} (for ``case insensitive'') embedded in their
names.


\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{procedure}
\rproto{make-string}{ \vr{k} char}{procedure}}

%\domain{\vr{k} must be a non-negative integer, and \var{char} must be
%a character.}  
{\cf Make-string} returns a newly allocated string of
length \vr{k}.  If \var{char} is given, then all elements of the string
are initialized to \var{char}, otherwise the contents of the
\var{string} are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{library procedure}}

Returns a newly allocated string composed of the arguments.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string}.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{procedure}}

\domain{\vr{k} must be a valid index of \var{string}.}
{\cf String-ref} returns character \vr{k} of \var{string} using zero-origin indexing.
\end{entry}


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{%\var{String} must be a string, 
\vr{k} must be a valid index of \var{string}%, and \var{char} must be a character
.}
{\cf String-set!} stores \var{char} in element \vr{k} of \var{string}
and returns an unspecified value.  % <!>

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vari{string} \varii{string}}{library procedure}}

Returns \schtrue{} if the two strings are the same length and contain the same
characters in the same positions, otherwise returns \schfalse.

\begin{scheme}
(string=? "Strae" "Strasse") \ev \schfalse
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string<?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string>?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string<=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string>=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}}

These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, {\cf string<?}\ is
the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters.  If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.

\begin{scheme}
(string<? "z" "\ss") \ev \schtrue
(string<? "z" "zz") \ev \schtrue
(string<? "z" "Z") \ev \schfalse
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{string-upcase}{ \var{string}}{library procedure}
\proto{string-downcase}{ \var{string}}{library procedure}
\proto{string-titlecase}{ \var{string}}{library procedure}
\proto{string-foldcase}{ \var{string}}{library procedure}}

These procedures take a string argument argument and return a string
result.  They are defined as in terms of Unicode's locale-independent
case mappings from scalar-value sequences to scalar-value sequences.
In particular, the length of the result string can be different than
the length of the input string.

The {\cf string-upcase} procedure converts a string to upper case,
{\cf string-downcase} converts a string to lowercase. The {\cf
  string-foldcase} procedure converts the string to its case-folded
counterpart, using the full case-folding mapping, but without the
special mappings for Turkic languages.  The {\cf string-titlecase}
procedure converts the first character to title case in each
contiguous sequence of cased characters within \var{string}, and it
downcases all other cased characters; for the purposes of detecting
cased-character sequences, case-ignorable characters are ignored
(i.e., they do not interrupt the sequence).

\begin{scheme}
(string-upcase "Hi") \ev "HI"
(string-downcase "Hi") \ev "hi"
(string-foldcase "Hi") \ev "hi"

(string-upcase "Stra\ss{}e") \ev "STRASSE"
(string-downcase "Stra\ss{}e") \ev "stra\ss{}e"
(string-foldcase "Stra\ss{}e") \ev "strasse"
(string-downcase "STRASSE")  \ev "strasse"

(string-downcase "$\Sigma$") \ev "$\sigma$"

; \textrm{Chi Alpha Omicron Sigma}:
(string-upcase "$\mathit{XAO}\Sigma$") \ev "$\mathit{XAO}\Sigma$" 
(string-downcase "$\mathit{XAO}\Sigma$") \ev "$\chi\alpha{}o\varsigma$"
(string-downcase "$\mathit{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\varsigma$"
(string-downcase "$\mathit{XAO}\Sigma~\Sigma$") \ev "$\chi\alpha{}o\varsigma~\sigma$"
(string-foldcase "$\mathit{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\sigma$"
(string-upcase "$\chi\alpha{}o\varsigma$") \ev "$\mathit{XAO}\Sigma$"
(string-upcase "$\chi\alpha{}o\sigma$") \ev "$\mathit{XAO}\Sigma$"

(string-titlecase "kNock KNoCK")
\ev "Knock Knock"
(string-titlecase "who's there?")
\ev "Who's There?"
(string-titlecase "r6rs") \ev "R6Rs"
(string-titlecase "R6RS") \ev "R6Rs"
\end{scheme}

\begin{note}
  These mappings can be extracted from {\cf UnicodeData.txt}, {\cf
    SpecialCasing.txt}, and {\cf CaseFolding.txt} from the Unicode
  Consortium.

  Since each of these procedures is locale-independent, they may not
  be completely appropriate for some locales.
\end{note}

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string-ci<?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string-ci>?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string-ci<=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}
\proto{string-ci>=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{library procedure}}

\nodomain{Both \vari{string} and \varii{string} must be strings.}
These procedures are similar to {\cf string=?}\ et cetera, but operate
on the fold-cased versions of the strings.

\begin{scheme}
(string-ci<? "z" "Z") \ev \schfalse
(string-ci=? "z" "Z") \ev \schtrue
(string-ci=? "Stra\ss{}e" "Strasse") 
\ev \schtrue
(string-ci=? "Stra\ss{}e" "STRASSE")
\ev \schtrue
(string-ci=? "$\mathit{XAO}\Sigma$" "$\chi\alpha{}o\sigma$")
\ev \schtrue
\end{scheme}

\begin{note}
These procedures could be defined as follows:
%
\begin{scheme}
; string-ci-comparator itself is not part of the
; specification; it is used only to define 
; other procedures
(define (string-ci-comparator cs-comp)
  (lambda (a-string b-string)
    (cs-comp (string-foldcase a-string)
             (string-foldcase b-string))))

(define string-ci=? (string-ci-comparator string=?))
(define string-ci<? (string-ci-comparator string<?))
(define string-ci>? (string-ci-comparator string>?))
(define string-ci<=? (string-ci-comparator string<=?))
(define string-ci>=? (string-ci-comparator string>=?))
\end{scheme}
\end{note}

\end{entry}

\begin{entry}{%
\proto{substring}{ string start end}{library procedure}}

\domain{\var{String} must be a string, and \var{start} and \var{end}
must be exact integers satisfying
$$0 \leq \var{start} \leq \var{end} \leq \hbox{\tt(string-length \var{string})\rm.}$$}
{\cf Substring} returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} (inclusive) and ending with index
\var{end} (exclusive).
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{library procedure}}

Returns a newly allocated string whose characters form the concatenation of the
given strings.

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{library procedure}
\proto{list->string}{ list}{library procedure}}

{\cf String\coerce{}list} returns a newly allocated list of the
characters that make up the given string.  {\cf List\coerce{}string}
returns a newly allocated string formed from the characters in the list
\var{list}, which must be a list of characters. {\cf String\coerce{}list}
and {\cf list\coerce{}string} are
inverses so far as {\cf equal?}\ is concerned.  
%Implementations that provide
%destructive operations on strings should ensure that the result of
%{\cf list\coerce{}string} is newly allocated.

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{library procedure}}

Returns a newly allocated copy of the given \var{string}.

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string char}{library procedure}}

Stores \var{char} in every element of the given \var{string} and returns an
unspecified value.  % <!>

\end{entry}

\begin{entry}{
\proto{string-normalize-nfd}{ \var{string}}{library procedure}
\proto{string-normalize-nfkd}{ \var{string}}{library procedure}
\proto{string-normalize-nfc}{ \var{string}}{library procedure}
\proto{string-normalize-nfkc}{ \var{string}}{library procedure}}
  
These procedures take a string argument argument and return a string
result.  They each return a string that is the input string normalized
to Unicode form D, KD, C, or KC, respectively.

\begin{scheme}
(string-normalize-nfd "\backwhack{}xE9;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}xE9;")
\ev "\backwhack{}xE9;"
(string-normalize-nfd "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}xE9;"
\end{scheme}
\end{entry}

\section{Vectors}
\label{vectorsection}

Vectors are heterogenous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time required to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The {\em valid indexes}\index{valid indexes} of a
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Like list constants, vector constants must be quoted:

\begin{scheme}
'\#(0 (2 2 2 2) "Anna")  \lev  \#(0 (2 2 2 2) "Anna")%
\end{scheme}

\todo{Pitman sez: The visual similarity to lists is bound to be confusing
to some.  Elaborate on the distinction.}


\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{library procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-ref} returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (let ((i (round (* 2 (acos -1)))))
              (if (inexact? i)
                  (inexact->exact i)
                  i))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-set!} stores \var{obj} in element \vr{k} of \var{vector}.
The value returned by {\cf vector-set!}\ is unspecified.  % <!>

\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{library procedure}
\proto{list->vector}{ list}{library procedure}}

{\cf Vector->list} returns a newly allocated list of the objects contained
in the elements of \var{vector}.  {\cf List->vector} returns a newly
created vector initialized to the elements of the list \var{list}.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-fill!}{ vector fill}{library procedure}}

Stores \var{fill} in every element of \var{vector}.
The value returned by {\cf vector-fill!}\ is unspecified.  % <!>

\end{entry}


\section{Control features}
\label{proceduresection}
 
% Intro flushed; not very a propos any more.
% Procedures should be discussed somewhere, however.

This chapter describes various primitive procedures which control the
flow of program execution in special ways.
The {\cf procedure?}\ predicate is also described here.

\todo{{\tt Procedure?} doesn't belong in a section with the name
``control features.''  What to do?}

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

\domain{\var{Proc} must be a procedure and \var{args} must be a list.}
Calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{args})} as the actual
arguments.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{library procedure}}

\domain{The \var{list}s must be lists, and \var{proc} must be a
procedure taking as many arguments as there are {\it list}s
and returning a single value.  If more
than one \var{list} is given, then they must all be the same length.}
{\cf Map} applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.
The dynamic order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{library procedure}}

The arguments to {\cf for-each} are like the arguments to {\cf map}, but
{\cf for-each} calls \var{proc} for its side effects rather than for its
values.  Unlike {\cf map}, {\cf for-each} is guaranteed to call \var{proc} on
the elements of the \var{list}s in order from the first element(s) to the
last, and the value returned by {\cf for-each} is unspecified.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}}

\label{continuations} \domain{\var{Proc} must be a procedure of one
argument.} The procedure {\cf call-with-current-continuation} packages
up the current continuation (see the rationale below) as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead use the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of \var{before} and \var{after} thunks installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation to the original call to \callcc.

\vest The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

\vest The following examples show only the most common ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-with-current-continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is extremely useful for implementing a
wide variety of advanced control structures.

\vest Whenever a Scheme expression is evaluated there is a
\defining{continuation} wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.  If the expression is
evaluated at top level, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers do not
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
{\cf Call-with-current-continuation} allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.

\vest Most programming languages incorporate one or more special-purpose
escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
invented a general purpose escape operator called the J-operator.  John
Reynolds~\cite{Reynolds72} described a simpler but equally powerful
construct in 1972.  The {\cf catch} special form described by Sussman
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
\ide{catch} construct could be provided by a procedure instead of by a
special syntactic construct, and the name
{\cf call-with-current-continuation} was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name \ide{call/cc} instead.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

Delivers all of its arguments to its continuation.
{\tt Values} might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))
\end{scheme}

The continuations of all commands (represented by \meta{command} in
the formal syntax) within a sequence of expressions (represented by
\meta{sequence} in the formal syntax) in {\cf lambda}, {\cf
  begin}, {\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf
  case}, {\cf cond}, and {\cf do} forms take an arbitrary number of
values.

Except for these and the continuations created by the {\cf
  call-with-values} procedure, all other continuations take exactly
one value.  The effect of passing an inappropriate number of values to
a continuation is unspecified.
\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

Calls its \var{producer} argument with no values and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

Calls \var{thunk} without arguments, returning the result(s) of this call.
\var{Before} and \var{after} are called, also without arguments, as required
by the following rules (note that in the absence of calls to continuations
captured using \ide{call-with-current-continuation} the three arguments are
called once each, in order).  \var{Before} is called whenever execution
enters the dynamic extent of the call to \var{thunk} and \var{after} is called
whenever it exits that dynamic extent.  The dynamic extent of a procedure
call is the period between when the call is initiated and when it
returns.  In Scheme, because of {\cf call-with-current-continuation}, the
dynamic extent of a call may not be a single, connected time period.
It is defined as follows:
\begin{itemize}
\item The dynamic extent is entered when execution of the body of the
called procedure begins.

\item The dynamic extent is also entered when execution is not within
the dynamic extent and a continuation is invoked that was captured
(using {\cf call-with-current-continuation}) during the dynamic extent.

\item It is exited when the called procedure returns.

\item It is also exited when execution is within the dynamic extent and
a continuation is invoked that was captured while not within the
dynamic extent.
\end{itemize}

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{after}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{after} associated with the second (inner) call to
{\cf dynamic-wind} is called first.

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{before}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{before} associated with the first (outer) call to
{\cf dynamic-wind} is called first.

If invoking a continuation requires calling the \var{before} from one call
to {\cf dynamic-wind} and the \var{after} from another, then the \var{after}
is called first.

The effect of using a captured continuation to enter or exit the dynamic
extent of a call to \var{before} or \var{after} is undefined.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)
\end{scheme}
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
