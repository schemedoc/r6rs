\chapter{Mutable pairs}
\label{pairmutationchapter}

The procedures provided by the \deflibrary{r6rs mutable-pairs} library allow assigning values to
the car and cdr fields of pairs.  In programs that use them, the
criteria for determining the validity of list arguments are more
complex than with only immutable lists.
Section~\ref{mutablelistargumentsection} spells out the definitions
needed for clarifying the specifications of procedures accepting
lists.  Section~\ref{proceduresmutablelistargumentssection} clarifies
the specifications of the procedures of this report using these
definitions.

\section{Procedures}

\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}  
Stores \var{obj} in the car field of \var{pair}.
Returns the unspecified value.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \theunspecified
(set-car! (g) 3)             \ev  \unspecified%
          ; should raise \exception{\&contract}
\end{scheme}

Passing an immutable pair to {\cf set-car!} should cause an exception
with condition type {\cf\&contract} to be raised.
\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Stores \var{obj} in the cdr field of \var{pair}.
Returns the unspecified value.

Passing an immutable pair to {\cf set-cdr!} should cause an exception
with condition type {\cf\&contract} to be raised.

\begin{scheme}
(let ((x (list 'a 'b 'c 'a))
      (y (list 'a 'b 'c 'a 'b 'c 'a)))
  (set-cdr! (list-tail x 2) x)
  (set-cdr! (list-tail y 5) y)
  (list
   (equal? x x)
   (equal? x y)
   (equal? (list x y 'a) (list y x 'b)))) \lev  (\schtrue{} \schtrue{} \schfalse{})
\end{scheme}
\end{entry}

\section{Mutable list arguments}
\label{mutablelistargumentsection}

Through the {\cf set-car!} and {\cf set-cdr!} procedures, lists are
mutable in Scheme, so a pair that is the head of a list at one moment
may not always be the head of a list:
%
\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \theunspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \theunspecified
(list? x)               \ev  \schfalse%
\end{scheme}

Any procedures defined in this
report specified as accepting a list argument must check if that
argument indeed appears to be a list.  This checking is complicated by
the fact that many procedures accepting lists such as {\cf map} or
{\cf filter} call arbitrary procedures that are passed as arguments.
These argument procedures may mutate the list while it is being
traversed.  Moreover, in the presence of concurrent evaluation,
whether a pair is the head of a list is not computable in general.

Consequently, procedures like {\cf length} are only required to check
that a list argument is a \textit{plausible list\index{plausible
    list}}.  Informally, a plausible list is an object that appears as
a list during a sequential traversal, where that traversal must also
detect a cycle.  In particular, a plausible immutable list is always a list.
A more formal definition follows:

Plausible lists are defined with respect to the time interval between
the time an argument is passed to the specified procedure and the
first return of a value to that procedure's continuation.

The times are in any global time that satisfies the axioms proposed in
chapter 2 of MIT AI TR-633~\cite{AITR633}.

\begin{note}
In most implementations,
the definitions above are believed to be invariant under
transformations of global time that are allowed by those axioms.
\end{note}

A \textit{plausible list up to $n$ between times $t_0$ and $t_n$} is a
Scheme value $x$ such that
%
\begin{enumerate}
\item $x$ is a pair, and $n$ is $0$; or
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list up to $n-1$ between
  times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible list up to and including $n$} is a plausible list
up to $n$ where case 2 does not apply either directly or through
recursion.

A \textit{plausible list of length $n$ between times $t_0$ and $t_n$}
is a Scheme value $x$ such that

\begin{enumerate}
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list of length $n-1$
  between times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible prefix of length $n$ between times $t_0$ and
  $t_n$} is a sequence of Scheme values $x_0,\ldots,x_n$ and strictly
increasing times $t_1,\ldots,t_n$ such that $x_0$ through $x_{n-1}$
are pairs, $x_n$ is either the empty list or a pair, and taking the
cdr of a pair $x_{i-1}$ at time $t_i$ yields $x_i$.

\textit{A plausible alist up to $n$ between times $t_0$ and $t_n$} is
a plausible list up to $n$ between $t_0$ and $t_n$ such that, for all
possible choices of the times $t_1$ and pairs $p$ mentioned in part
(3) above, there exists a time $t_2$ such that $t_1 < t_2 < t_n$ and
the car of $p$ at time $t_2$ is a pair.

\textit{A plausible alist of length $n$} is defined similarly, as is
\textit{a plausible alist prefix of length $n$}.

\textit{A plausible list (alist) between times $t_0$ and $t_n$} is a
plausible list (alist) of some length $n$ between those times.

\section{Procedures with list arguments}
\label{proceduresmutablelistargumentssection}

This section contains clarifications to the domains of the procedures of the base
library and the \library{r6rs lists} library.

\subsection{Base-library procedures}

These are clarifications to the domains of the procedures of the base
library described in sections~\ref{listsection} and \ref{controlsection}:

\begin{entry}{%
\irproto{list?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a plausible list, otherwise returns
\schfalse{}.
\end{entry}

\begin{entry}{%
\irproto{list-tail}{ l \vr{k}}{procedure}}

\domain{\var{L} must be a plausible list up to \var{k}.}
\end{entry}

\begin{entry}{%
\irproto{list-ref}{ l \vr{k}}{procedure}}

\domain{\var{L} must be a plausible list up to and including \var{k}.}
\end{entry}

\begin{entry}{%
\irproto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s must be plausible lists, and \var{proc} must be a
procedure taking as many arguments as there are {\it list}s
and returning a single value.  If more
than one \var{list} is given, a natural number $n$ must exist such
that all \varj{list} are plausible lists of length $n$.}
\end{entry}

\begin{entry}{%
\irproto{list->string}{ list}{procedure}}

\domain{\var{List} must be a plausible list where, for every
  natural number $n$ and for every plausible prefix $x_i$ of that argument
  of length $n$, there exists a time $t$ with $t_i < t <
  t_r$, where $t_r$ is the time of first return from {\cf
    list\coerce{}string}, for which the car of $x_i$ is a character.}
\end{entry}

\begin{entry}{%
\irproto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}
\domain{\var{Proc} must be a procedure and \var{args} must be a
  plausible list.}
\end{entry}

\subsection{List utilities}

These are clarifications to the domains of the procedures of the \library{r6rs lists}
library described in chapter~\ref{listutilities}:

\begin{entry}{%
\irproto{forall}{ proc \vari{l} \varii{l} \dotsfoo}{procedure}
\irproto{exists}{ proc \vari{l} \varii{l} \dotsfoo}{procedure}}

\domain{For the \var{l}s, there must exist a natural number $n$
  such that all \var{l}s are plausible lists of length $n$, they
  must be values of according the conditions specified below.
  \var{Proc} must be a procedure taking as many arguments as there are
  \var{l}s.}

If the \var{l}s are not as specified, then a natural number $n$ must
exist where each \varj{l} is the first Scheme value of a plausible
prefix of length $n$ such that the car of the last value $x_n$ of that
prefix satisfies the given condition (i.e.\ the procedure returns a
false value with {\cf forall} or a true value with {\cf exists}) at
some time after $t_n$ and before the procedure returns.
\end{entry}

\begin{entry}{%
\irproto{memp}{ proc l}{procedure}
\irproto{member}{ obj l}{procedure}
\irproto{memv}{ obj l}{procedure}
\irproto{memq}{ obj l}{procedure}
}

\domain{\var{Proc} must be a procedure taking a single argument.
  \var{L} must be a plausible list or a value according to the
  conditions specified below.}

If \var{l} is not a plausible list, then it must be such that a
natural number $n$ exists where \var{l} is the first Scheme value of a
plausible prefix of length $n$ such that the car of the last value $x_n$ of that
prefix satisfies the given condition at some time after $t_n$ and before
the procedure returns.
\end{entry}

\begin{entry}{%
\irproto{assp}{ proc al}{procedure}
\irproto{assoc}{ obj al}{procedure}
\irproto{assv}{ obj al}{procedure}
\irproto{assq}{ obj al}{procedure}}

\domain{\var{Al} (for ``association list'') must be a a plausible
  alist or a value according to the conditions specified below.
  \var{Proc} must be a procedure taking a single argument.}

If \var{al} is not a plausible alist, then a natural number $n$ must
exist such that \var{al} is the first Scheme value of a plausible
prefix of length $n$ such that every Scheme value $x_1$ through $x_n$
of that prefix is a pair, and $x_n$ has a pair as its car at some time
after $t_n$, and at some time after that the car of that pair is the
first argument, all before the procedure returns.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
