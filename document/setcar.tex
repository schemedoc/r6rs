\chapter{Mutable pairs}
\label{pairmutationchapter}

The procedures provided by the \deflibrary{r6rs mutable-pairs} library
allow new values to be assigned to the car and cdr fields of
previously allocated pairs.  In programs that use this library,
the criteria for determining the validity of list arguments are more
complex than in programs whose lists are immutable.
Section~\ref{mutablelistargumentsection} spells out the definitions
that are needed to clarify the specifications of procedures that
accept lists.
Section~\ref{proceduresmutablelistargumentssection} uses those
definitions to clarify the specifications of procedures that
are described by this report.

\section{Procedures}

\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}  
Stores \var{obj} in the car field of \var{pair}.
Returns the unspecified value.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \theunspecified
(set-car! (g) 3)             \ev  \unspecified\\\>; should raise \exception{\&contract}
\end{scheme}

If an immutable pair is passed to {\cf set-car!}, an exception
with condition type {\cf\&contract} should be raised.
\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Stores \var{obj} in the cdr field of \var{pair}.
Returns the unspecified value.

If an immutable pair is passed to {\cf set-cdr!}, an exception
with condition type {\cf\&contract} should be raised.

\begin{scheme}
(let ((x (list 'a 'b 'c 'a))
      (y (list 'a 'b 'c 'a 'b 'c 'a)))
  (set-cdr! (list-tail x 2) x)
  (set-cdr! (list-tail y 5) y)
  (list
   (equal? x x)
   (equal? x y)
   (equal? (list x y 'a) (list y x 'b)))) \lev  (\schtrue{} \schtrue{} \schfalse{})
\end{scheme}
\end{entry}

\section{Mutable list arguments}
\label{mutablelistargumentsection}

Through the {\cf set-car!} and {\cf set-cdr!} procedures, lists are
mutable in Scheme, so a pair that is the head of a list at one moment
may not always be the head of a list:
%
\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \theunspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \theunspecified
(list? x)               \ev  \schfalse%
\end{scheme}

Any procedures defined in this
report that are specified to accept a list argument must check if that
argument indeed appears to be a list.  This checking is complicated by
the fact that some such procedures, e.g. {\cf map} and
{\cf filter}, call arbitrary procedures that are passed as arguments.
These procedures may mutate the list while it is being
traversed.  Moreover, in the presence of concurrent evaluation,
whether a pair is the head of a list is not computable in general.

Consequently, procedures like {\cf length} are only required to confirm
that a list argument is a
\textit{plausible list\index{plausible list}}.
Informally, a plausible list is an object that appears to
be a list during a sequential traversal, where that traversal
must also attempt to detect a cycle.
In particular, an immutable plausible list is always a list.
A more formal definition follows.

Plausible lists are defined with respect to the time interval between
the time an argument is passed to the specified procedure and the
first return of a value to that procedure's continuation.

\begin{note}
  In most implementations, the
  definitions that follow are believed to be
  invariant under reasonable transformations
  of global time \cite{AITR633}.
\end{note}

A \textit{plausible list up to $n$ between times $t_0$ and $t_n$} is a
Scheme value $x$ such that
%
\begin{enumerate}
\item $x$ is a pair, and $n$ is $0$; or
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list up to $n-1$ between
  times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible list up to and including $n$} is a
Scheme value $x$ such that
%
\begin{enumerate}
\item $x$ is a pair, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list up to and including $n-1$ between
  times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible list of length $n$ between times $t_0$ and $t_n$}
is a Scheme value $x$ such that

\begin{enumerate}
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list of length $n-1$
  between times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible prefix of length $n$ between times $t_0$ and
  $t_n$} is a sequence of Scheme values $x_0,\ldots,x_n$ and strictly
increasing times $t_1,\ldots,t_n$ such that $x_0$ through $x_{n-1}$
are pairs, $x_n$ is either the empty list or a pair, and taking the
cdr of $x_{i-1}$ at time $t_i$ yields $x_i$.

\textit{A plausible alist up to $n$ between times $t_0$ and $t_n$} is
a Scheme value $x$ such that
\begin{enumerate}
\item $x$ is a pair, and $n$ is $0$; or
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exist times
  $t_1$ and $t_1^\prime$ in $(t_0,t_n]$ such that
  the car of $x$ at time $t_1^\prime$ is a pair and
  the cdr of $x$ at time $t_1$ is a plausible alist up to $n-1$
  between times $t_1$ and $t_n$.
\end{enumerate}

\textit{A plausible alist of length $n$} is defined similarly, as is
\textit{a plausible alist prefix of length $n$}.

\textit{A plausible list (alist) between times $t_0$ and $t_n$} is a
plausible list (alist) of some length $n$ between those times.

\section{Procedures with list arguments}
\label{proceduresmutablelistargumentssection}

This section clarifies the domains of procedures in the base
library and the \library{r6rs lists} library.

\subsection{Base-library procedures}

These are clarifications to the domains of the procedures of the base
library described in sections~\ref{listsection}, \ref{stringsection},
and \ref{controlsection}:

\begin{entry}{%
\irproto{list?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a list that is not modified
by {\cf set-cdr!} between entry and exit.
Returns \schfalse{} if \var{obj} is not a plausible list.
Otherwise, this procedure returns an unspecified boolean
or does not return at all.

\begin{note}
The unspecified and non-terminating cases can occur only
in implementations that allow the argument to be modified
by concurrent execution, which is beyond the scope of this
document.
To reduce the number of unspecified cases that must be
mentioned, the rest of this chapter will mostly ignore
the possibility of unspecified behavior being caused by
concurrent execution.
\end{note}
\end{entry}

\begin{entry}{%
\irproto{length}{ list}{procedure}}

\domain{\var{List} must be a plausible list.}

\begin{note}
In other words, an exception must be raised if \var{list}
is not a plausible list.
That \var{list} is a plausible list is not by
itself sufficient to avoid the exception, however.
If \var{list} is a plausible list, but is
mutated in certain ways during the call to {\cf length},
then an exception may still be raised.
This can occur only in implementations that allow
concurrent execution.  The rest of this chapter
will mostly ignore the possibility of exceptions being
caused by concurrent modification of an argument.
\end{note}
\end{entry}

\begin{entry}{%
\irproto{append}{ list \dotsfoo{} obj}{procedure}}

\domain{All \var{list}s must be plausible lists.}
\end{entry}

\begin{entry}{%
\irproto{reverse}{ list}{procedure}}

\domain{\var{List} must be a plausible list.}
\end{entry}

\begin{entry}{%
\irproto{list-tail}{ l \vr{k}}{procedure}}

\domain{\var{L} must be a plausible list up to \var{k}.}
\end{entry}

\begin{entry}{%
\irproto{list-ref}{ l \vr{k}}{procedure}}

\domain{\var{L} must be a plausible list up to and including \var{k}.}
\end{entry}

\begin{entry}{%
\irproto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{\var{Proc} must be a procedure; if any of the \varj{list}
are nonempty, then \var{proc} must take as many arguments as there
are \varj{list}.
A natural number $n$ must exist such
that all \varj{list} are plausible lists of length $n$.}

\begin{note}
In other words, an exception must be raised if no such $n$ exists.
The existence of a natural number $n$ such that
all of the \var{list}s are plausible lists of length $n$
is not by itself sufficient to avoid the exception, however.
If \var{proc} mutates the lists in certain ways during the
call to {\cf map}, then an exception may still be raised,
even in systems that do not allow concurrent execution.
\end{note}
\begin{scheme}
(let* ((ones (list 1))
       (f (lambda (x)
            (set-cdr! ones (list x))
            (set! ones (cdr ones))
            2)))
  ; ones is a plausible list
  (map f ones))              \ev \unspecified\\\>; may not terminate
\end{scheme}
\end{entry}

\begin{entry}{%
\irproto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{A natural number $n$ must exist such
that all \varj{list} are plausible lists of length $n$.}
\end{entry}

\begin{entry}{%
\irproto{list->string}{ list}{procedure}}

\domain{\var{List} must be a plausible list where, for every
  natural number $n$ and for every plausible prefix $x_i$ of that argument
  of length $n$, there exists a time $t$ with $t_i < t <
  t_r$, where $t_r$ is the time of first return from {\cf
    list\coerce{}string}, for which the car of $x_i$ is a character.}
\end{entry}

\begin{entry}{%
\irproto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

\domain{\var{Proc} must be a procedure and \var{args} must be a
  plausible list.}
\end{entry}

\subsection{List utilities}

These are clarifications to the domains of the procedures
of the \library{r6rs lists}
library described in chapter~\ref{listutilities}:

\begin{entry}{%
\irproto{find}{ proc list}{procedure}}

\domain{\var{Proc} must be a procedure; it must take a single argument
    if \var{list} is non-empty.
    Either there exists a natural number $n$ such
    that \var{list} is a plausible list of length $n$
    between entry and some subsequent time before exit,
    or there exists a natural number $n$,
    Scheme objects $x_j$, and times $t_j$
    such that
    $list, x_1, \dots, x_n$ and $t_1, \ldots, t_n$
    is a plausible prefix up to and including $n$, where
    $t_1$ is after entry and $t_n$ is before exit
    and there exists $t^\prime$ before exit such that
    $t^\prime > t_n$,
    the car of $x_n$ at $t^\prime$ is $y$,
    and a call to \var{proc} with argument $y$ at some time
    after $t^\prime$ but before exit
    yields a true value.}
\end{entry}

\begin{entry}{%
\irproto{for-all}{ proc \vari{l} \varii{l} \dotsfoo{} \varn{l}}{procedure}
\irproto{exists}{ proc \vari{l} \varii{l} \dotsfoo{} \varn{l}}{procedure}}

\domain{\var{Proc} must be a procedure; if any \varj{l} is
    nonempty, then \var{proc} must take as many arguments
    as there are \var{l}s.
    Either there exists a natural number $k$ such
    that every $l_i$ is a plausible list of length $k$
    between entry and some subsequent time before exit,
    or there exists a natural number $k$,
    Scheme objects $x_{i,j}$, and times $t_{i,j}$
    such that for every $l_i$:
    $l_i, x_{i,1}, \dots, x_{i,k}$ and $t_{i,1}, \ldots, t_{i,k}$
    is a plausible prefix up to and including $k$, where
    $t_{i,1}$ is after entry and $t_{i,k}$ is before exit
    and there exist $t_i^\prime$ before exit such that
    $t_i^\prime > t_{i,k}$ (where $t_{i,0}$ is defined to be $t_0$),
    the car of $x_{i,k}$ at $t_i^\prime$ is $y_i$,
    and a call to \var{proc} on the $y_i$ at some time
    after the maximum of the $t_i^\prime$ but before exit
    yields a false value (for {\cf for-all}) or a true
    value (for {\cf exists}).}
\end{entry}

\begin{entry}{%
\irproto{filter}{ proc list}{procedure}
\irproto{partition}{ proc list}{procedure}
}

\domain{\var{Proc} must be a procedure; it must take a single argument
    if \var{list} is non-empty.
    \var{List} must be a plausible list.}
\end{entry}

\begin{entry}{%
\irproto{fold-left}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}
\irproto{fold-right}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{\var{Kons} must be a
  procedure; if the \var{list}s are non-empty, it must take one more
  argument than there are {\it list}s.
    There must exist a natural number $n$ such
    that every \var{list} is a plausible list of length $n$
    between entry and some subsequent time before exit.}
\end{entry}

\begin{entry}{%
\irproto{remp}{ proc list}{procedure}
\irproto{remove}{ obj list}{procedure}
\irproto{remv}{ obj list}{procedure}
\irproto{remq}{ obj list}{procedure}}

\domain{\var{Proc} must be a procedure; it must take a single argument
    if \var{list} is non-empty.
    \var{List} must be a plausible list.}
\end{entry}

\begin{entry}{%
\irproto{memp}{ proc l}{procedure}
\irproto{member}{ obj l}{procedure}
\irproto{memv}{ obj l}{procedure}
\irproto{memq}{ obj l}{procedure}
}

\domain{\var{Proc} must be a procedure;
  if \var{l} is nonempty, then it must take a single argument.
  \var{L} must be a plausible list or a value according to the
  conditions specified below.}

If \var{l} is not a plausible list, then it must be such that a
natural number $n$ exists where \var{l} is the first Scheme value of a
plausible prefix of length $n$ such that
the car of the last value $x_n$ of that
prefix satisfies the given condition at some time after $t_n$ and before
the procedure returns.
\end{entry}

\begin{entry}{%
\irproto{assp}{ proc al}{procedure}
\irproto{assoc}{ obj al}{procedure}
\irproto{assv}{ obj al}{procedure}
\irproto{assq}{ obj al}{procedure}}

\domain{\var{Al} (for ``association list'') must be a a plausible
  alist or a value according to the conditions specified below.
  \var{Proc} must be a procedure; if \var{al} is nonempty, then
  \var{proc} must take a single argument.}

If \var{al} is not a plausible alist, then a natural number $n$ must
exist such that \var{al} is the first Scheme value of a plausible
prefix of length $n$ such that every Scheme value $x_1$ through $x_n$
of that prefix is a pair, and $x_n$ has a pair as its car at some time
after $t_n$, and at some time after that the car of that pair is the
first argument (or, for {\cf assp}, a value for which \var{proc}
returns true), all before the procedure returns.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
