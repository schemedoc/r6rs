\section{Primitive I/O}
\label{primiosection}

This section defines the \deflibrary{r6rs i/o primitive} library, a
simple, primitive I/O subsystem.  It provides unbuffered I/O, and is
close to what a typical operating system offers. Thus, its interface
is suitable for implementing high-throughput and zero-copy I/O.

This library also allows programs to implement custom data
sources and sinks via a simple interface.
It handles only blocking I/O.

\subsection{File names}
\label{filenamesection}

Some of the procedures described in this chapter accept a file name as an
argument. Valid values for such a file name include strings that name a file
using the native notation of filesystem paths on the implementation's underlying
operating system.
A \var{filename} parameter name means that the
corresponding argument must be a file name.

Some implementations will provide a more
abstract representation of file names. Indeed, most operating
systems do not use strings for representing file names, but rather byte
or word sequences. Moreover, the string notation is difficult to manipulate, and
it is not portable across operating systems.

\subsection{File options}
\label{fileoptionssection}

\mainindex{file options}
When opening a file, the various procedures in this library accept a
{\cf file-options} object that encapsulates flags to specify how
the file is to be opened. A {\cf file-options} object is an enum-set
(see chapter~\ref{enumerationschapter}) over the symbols constituting
valid file options.
A \var{file-options} parameter name means that the
corresponding argument must be a file-options object.

\begin{entry}{%
\proto{file-options}{ \hyper{file-options name} \dotsfoo}{\exprtype}}

Each \hyper{file-options name} must be an \meta{identifier}.
The {\cf file-options} syntax returns a file-options object that 
encapsulates the
specified options. The following options (all affecting output
only) have predefined meaning:

\begin{itemize}   
\item {\cf create} create file if it does not already exist
\item {\cf exclusive} an exception with condition type
  {\cf\&i/o-file-already-exists} is raised if this
  option and {\cf create} are both set and the file already exists
\item {\cf truncate}
  file is truncated
\end{itemize}

\meta{Identifiers}s other than those listed above may be used as \hyper{file-options name}s;
they have implementation-specific meaning, if any.

The file-options object returned by {\cf (file-options)} specifies,
when supplied to an operation opening a file for output, that the file
must exist (otherwise an exception with condition type
{\cf\&i/o-file-exists-not} is raised) and its data is unchanged by the
operation.

\begin{rationale}
  The flags specified above represent only a common subset of
  meaningful options on popular platforms.  The {\cf file-options}
  form does not restrict the \hyper{file-options name}s, so 
  implementations can extend the file options by platform-specific
  flags.
\end{rationale}
\end{entry}   

\subsection{Readers and writers}

The objects representing input data sources are called readers, and
those representing output data sinks are called writers.
Both readers and writer are unbuffered, and they operate purely on binary data.  
Although some
reader and writer objects might conceivably have something to do with
files or devices, programmers should never assume so.
A \var{reader} parameter name means that the
corresponding argument must be a reader.
A \var{writer} parameter name means that the
corresponding argument must be a writer.

The \library{r6rs i/o primitive} library has one condition type
specific to readers and writers:

\begin{entry}{%
\ctproto{i/o-reader/writer}
\proto{i/o-reader-writer-error?}{ obj}{procedure}
\proto{i/o-error-reader/writer}{ condition}{procedure}}

This condition type could be defined by

\begin{scheme}
(define-condition-type \&i/o-reader/writer \&i/o
  i/o-reader/writer-error?
  (reader/writer i/o-error-reader/writer))
\end{scheme}

This condition type allows specifying the particular reader or writer
with which an I/O error is associated. Conditions raised by the
procedures exported by the \library{r6rs i/o primitive} may include an {\cf\&i/o-reader/writer} 
condition, but they are not required to do so.
\end{entry}

\subsection{I/O buffers}

\begin{entry}{%
\proto{make-i/o-buffer}{ size}{procedure}}

\domain{\var{Size} must be a non-negative exact integer.} The {\cf make-i/o-buffer} procedure
creates a bytes object of size \var{size} with undefined contents.
Callers of the procedures from the \library{r6rs i/o primitive} library  are encouraged to use bytes
objects created by {\cf make-i/o-buffer} because they might have
alignment and placement characteristics that {\cf make reader-read!}
and {\cf writer-write!} more efficient.  (Those procedures are still
required to work on regular bytes objects, however.)
\end{entry}

\subsection{Readers}

The purpose of reader objects is to represent the output of arbitrary
algorithms in a form amenable to imperative I/O.
A reader allows reading an infinite sequence of bytes punctuated
by end of file objects.

\begin{entry}{%
\proto{reader?}{ obj}{procedures}}
   
Returns \schtrue{} if \var{obj} is a reader, otherwise returns \schfalse.
\end{entry}

\begin{entry}{%
\pproto{(make-simple-reader \var{id} \var{descriptor}}{procedure}}
\mainschindex{make-simple-reader}{\tt\obeyspaces\\
    \var{chunk-size} \var{read!} \var{available} \var{get-position}
    \var{set-position!} \var{end-position} \var{close})}

Returns a reader object. \var{Id} must be a string naming the reader,
provided for informational purposes only. \var{Descriptor} may be any
object; the procedures described in this section do not use it internally for any
purpose, but \var{descriptor} can be extracted from the reader object via
{\cf reader-descriptor}. Thus, \var{descriptor} can be used to keep the
internal state of certain kinds of readers.
   
\var{Chunk-size} must be a positive exact integer, and it represents a recommended
efficient size for the read operations on this reader. This integer is typically the
block size of the buffers of the operating system. As such, it is only a
hint for clients of the reader---calls to the \var{read!} procedure (see below)
may specify a different read count.

The remaining arguments are procedures.  For each such procedure, an
operation exists that calls that procedure.  For example, the {\cf
  reader-read!} operation, when called on a simple reader, calls
its \var{read!} procedure.
These procedures should check that their arguments are
of the appropriate types.  The operations that call them perform
no checking beyond ensuring that their \var{reader} arguments are
simple readers, and, if applicable, that the reader supports the operation.
These procedures must raise
exceptions with condition types as specified above when they encounter an
exceptional situation. When they do not, the effects are unspecified.

\var{Get-position}, \var{set-position!}, and \var{end-position} may be
omitted, in which case the corresponding arguments must be \schfalse.
   
\begin{itemize}
\item {\cf (\var{read!} \var{bytes} \var{start} \var{count})}
       
  \var{Start} and \var{count} must be non-negative exact integers.
  The \var{read!} procedure
  reads up to \var{count} bytes from the reader and writes them
  into \var{bytes} starting at index
  start. \var{Bytes} must have size at least $\var{start} +
  \var{count}$. The result is the number of bytes read as an
  exact integer. The result is 0 if \var{read!} encounters an end of file, or if
  count is 0. If \var{count} is positive, \var{read!} blocks until at
  least one byte has been read or until it has encountered an end of file.
  
  \var{Bytes} must be a bytes object, but may or may not be one returned by {\cf
    make-i/o-buffer}.
  
  \var{Count} may or may not be the same as the chunk size of the
  reader.

\item {\cf (\var{available})}
       
  Returns an estimate of the total number of bytes left in the
  reader. The result is either an exact integer, or
  \schfalse{} if no such estimate is possible. There is no guarantee
  that this estimate has any specific relationship to the true
  number of available bytes.

\item {\cf (\var{get-position})}
       
  When present, \var{get-position}
  returns the current position in the 
  reader as an exact integer, counting the number of bytes since the
  beginning of the source. (Ends of file do not count as bytes.)
  
\item {\cf (\var{set-position!} \var{pos})}
       
  When present, \var{set-position!} moves to position \var{pos} (which
  must be a non-negative exact integer) in the reader.
       
\item {\cf (\var{end-position})}
       
  When present, \var{end-position} returns the position in the reader
  of the next end of file, without changing the current position.

\item {\cf (\var{close})}
       
  Marks the reader as closed, performs any necessary
  cleanup, and releases the resources associated with the reader.
  Further operations on the reader must raise an exception with
  condition type {\cf\&assertion}.
\end{itemize}

\end{entry}

\begin{entry}{%
\proto{reader-id}{ reader}}
   
Returns a string naming the reader, provided for informational
purposes only. For a file reader returned by {\cf open-file-reader} or
{\cf open-file-reader+writer}, the result is a string representation of the file
name.
  
For a reader created by {\cf make-simple-reader}, the result is the value that was
supplied as the \var{id} argument to {\cf make-simple-reader}.
\end{entry}

\begin{entry}{%
\proto{reader-descriptor}{ reader}{procedure}}
   
For a reader created by {\cf make-simple-reader}, the result is the value that was
supplied as the descriptor argument to {\cf make-simple-reader}.
   
For all other readers, the result is an unspecified value.
\end{entry}

\begin{entry}{%
\proto{reader-chunk-size}{ reader}{procedure}}
   
Returns a positive exact integer that represents a recommended
efficient size of the read operations on this reader. The result is typically the
block size of the buffers of the operating system. As such, it is only a
hint for clients of the reader---calls to the {\cf reader-read!} procedure (see
below) may specify a different read count.

For a reader created by {\cf make-simple-reader}, the result is the
value that was supplied as the chunk-size argument to {\cf
  make-simple-reader}.
\end{entry}

\begin{entry}{%
\proto{reader-read!}{ reader bytes start count}{procedure}}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integers.  \var{Bytes} must have at least $\var{start} +
\var{count}$ elements.} The {\cf reader-read!} procedure 
reads up to \var{count} bytes from the reader and writes them into
\var{bytes} starting at index
\var{start}.  The result is the number of bytes read
as an exact integer. The result is 0 if {\cf reader-read!} encounters an end of file, or
if \var{count} is 0.  If \var{count} is positive, {\cf reader-read!}
blocks until at least one byte has been
read or until it has encountered end of file.
   
\var{Bytes} may or may not be a bytes object returned by {\cf
  make-i/o-buffer}, but {\cf reader-read!} may operate
more efficiently if it is.
   
\var{Count} may or may not be the same as the chunk size of the
reader, but {\cf reader-read!} may operate more
efficiently if it is.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-read!}
tail-calls the \var{read!} procedure of reader with the remaining
arguments.
\end{entry}

\begin{entry}{%
\proto{reader-available}{ reader}{procedure}}
   
Returns an estimate of the total number of available bytes left in the
stream. The result is either an exact integer, or \schfalse{} if no such
estimate is possible. There is no guarantee that this estimate has
any specific relationship to the true number of available bytes.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-available}
tail-calls the \var{available} procedure of reader.
\end{entry}   

\begin{entry}{%
\proto{reader-has-get-position?}{ reader}{procedure}
\proto{reader-get-position}{ reader}{procedure}}

The {\cf reader-has-get-position?} procedure \schtrue{} if \var{reader}
supports the {\cf reader-get-position} procedure, and \schfalse{}
otherwise.  For a simple reader, {\cf reader-has-get-position?}
returns \schtrue{} if it has a \var{get-position} procedure.
   
When {\cf reader-has-get-position} returns \schtrue{} for reader, {\cf
  reader-get-position} returns the current position in the byte stream
as an exact integer counting the number of bytes since the beginning
of the stream.  Otherwise, an exception with condition type
{\cf\&assertion} is raised.

For a reader created by {\cf make-simple-reader}, {\cf
  reader-get-position} tail-calls the \var{get-position} procedure of
\var{reader}.
\end{entry}

\begin{entry}{%
\proto{reader-has-set-position!?}{ reader}{procedure}
\proto{reader-set-position!}{ reader pos}{procedure}}

\domain{\var{Pos} must be a non-negative exact integer.}

The {\cf reader-has-set-position!?} procedure \schtrue{} if \var{reader}
supports the {\cf reader-set-position!} procedure, and \schfalse{}
otherwise.  For a simple reader, {\cf reader-has-set-position!?}
returns \schtrue{} if it has a \var{set-position!} procedure.

When {\cf reader-has-set-position!?} returns \schtrue{} for
\var{reader}, {\cf reader-set-position!}  moves to position \var{pos}
in the stream.  Otherwise, an {\cf exception} with condition type
{\cf\&assertion} is raised.

For a reader created by {\cf make-simple-reader}, {\cf
  reader-set-position!} tail-calls the \var{set-position!} procedure
of \var{reader} with the \var{pos} argument.  For readers not created
by {\cf make-simple-reader}, the result values are unspecified.
\end{entry}

\begin{entry}{%
\proto{reader-has-end-position?}{ reader}{procedure}
\proto{reader-end-position}{ reader}{procedure}}

The {\cf reader-has-end-position?} procedure \schtrue{} if \var{reader}
supports the {\cf reader-end-position} procedure, and \schfalse{}
otherwise.  For a simple reader, {\cf reader-has-end-position?}
returns \schtrue{} if it has a \var{end-position} procedure.
   
When {\cf reader-has-end-position?} returns \schtrue{} for
\var{reader}, {\cf reader-end-position} returns the position in the
byte stream of the next end of file, without changing the current
position.  Otherwise, an exception with condition type {\cf\&assertion}
is raised.

For a reader created by {\cf make-simple-reader}, {\cf
  reader-end-position} tail-calls the \var{end-position} procedure of
\var{reader}.
\end{entry}

\begin{entry}{%
\proto{reader-close}{ reader}{procedure}}
   
Marks \var{reader} as closed, performs any necessary cleanup, and
releases the resources associated with the reader. Further operations
on the reader must raise an exception with condition type
{\cf\&assertion}.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-close} tail-calls the
\var{close} procedure of reader.  For all other readers, the return
values are unspecified.
\end{entry}

\begin{entry}{%
\proto{open-bytes-reader}{ bytes}{procedure}}

Returns a \defining{bytes reader} that uses 
\var{bytes}, a bytes object, as its contents. The result reader supports
the {\cf reader-get-position}, {\cf reader-set-position!}, and {\cf reader-end-position}
operations.
If the contents of \var{bytes} are modified after 
{\cf open-bytes-reader} has been called, the effect on the reader is unspecified.
\end{entry}

\begin{entry}{%
\proto{open-file-reader}{ filename}{procedure}
\rproto{open-file-reader}{ filename file-options}{procedure}}
   
Returns a reader connected to the file named by \var{filename}.
The \var{file-options} object, which may determine various aspects of the returned reader
(see section~\ref{fileoptionssection}) defaults to {\cf (file-options)} if not
present.
The result reader supports {\cf reader-get-position},
{\cf reader-set-position!}, and {\cf reader-end-position} operations.
\end{entry} 

\begin{entry}{%
\proto{standard-input-reader}{}{procedure}}
   
Returns a reader connected to the standard input. The meaning of
``standard input'' is implementation-dependent.
\end{entry}

\subsection{Writers}

The purpose of writer objects is to represent the input of arbitrary
algorithms in a form amenable to imperative I/O.

\begin{entry}{%
\proto{writer?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a writer, otherwise returns \schfalse.
\end{entry}

\begin{entry}{%
\pproto{(make-simple-writer \var{id} \var{descriptor}}{procedure}}
\mainschindex{make-simple-writer}{\tt\obeyspaces\\
    \var{chunk-size} \var{write!} \var{get-position} \var{set-position!}
    \var{end-position} \var{close})}
   
Returns a writer object. \var{Id} must be a string naming the writer,
provided for informational purposes only. \var{Descriptor} may be any
object; the procedures described in this section do not use it internally for any
purpose, but \var{descriptor} can be extracted from the writer object via
{\cf writer-descriptor}. Thus, \var{descriptor} can be used to keep the
internal state of certain kinds of writers.

\var{Chunk-size} must be a positive exact integer, and it is the
recommended efficient size of the write operations on this writer. As
such, it is only a hint for clients of the writer---calls to the
\var{write!} procedure (see below) may specify a different write
count.

The remaining arguments are procedures.  For each such procedure, an
operation exists that calls that procedure.  For example, the {\cf
  writer-write!} operation, when called on a simple writer, calls
its \var{write!} procedure.
These procedures should check that their arguments are
of the appropriate types.  The operations that call them perform
no checking beyond ensuring that their \var{writer} arguments are
indeed writers, and, if applicable, that the writer supports the operation.
These procedures must raise
exceptions with condition types as specified above when they encounter an
exceptional situation. When they do not, the effects are unspecified.

\var{Get-position}, \var{set-position!}, and \var{end-position} may be
omitted, in which case the corresponding arguments must be \schfalse.

\begin{itemize}
\item {\cf (\var{write!} \var{bytes} \var{start} \var{count})}
   
  \var{Start} and \var{count} must be non-negative exact integers.
  The \var{write!} procedure
  writes up to \var{count} bytes in bytes object \var{bytes}
  starting at index \var{start}. Before writing any bytes, {\cf write!} blocks
  until it can write at least one byte. The result is the number of bytes
  actually written as a positive exact integer.
  
  \var{Bytes} must be a bytes object, but may or may not be one returned by {\cf
    make-i/o-buffer}.
  
  \var{Count} may or may not be the same as the chunk size of the
  reader.

\item {\cf (\var{get-position})}
   
  When present, \var{get-position} returns the current position in the byte
  stream as an exact integer counting the number of bytes since the
  beginning of the stream.
   
\item {\cf (\var{set-position!} \var{pos})}
   
  When present, \var{set-position!} moves to position \var{pos} (which must be a
  non-negative exact integer) in the stream.
  
\item {\cf (\var{end-position})}
   
    When present, \var{end-position} returns the byte position of the next end
    of file without changing the current position.
   
\item {\cf (\var{close})}
  
  Marks the writer as closed, performs any necessary
  cleanup, and releases the resources associated with the writer. Further
  operations on the writer must raise an exception with condition type
  {\cf\&assertion}.
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{writer-id}{ writer}{procedure}}
   
Returns a string naming the writer, provided for informational
purposes only. For a file writer returned by {\cf open-file-writer}
or {\cf open-file-reader+writer}, the result is a string
representation of the file name.
   
For a writer created by {\cf make-simple-writer}, the result is the
value of the \var{id} field of the argument writer.
\end{entry}

\begin{entry}{%
\proto{writer-descriptor}{ writer}{procedure}}
   
  For a writer created by {\cf make-simple-writer}, {\cf write-descriptor} 
  returns the value of the
  \var{descriptor} field of the argument writer.
  
  For all other writers, the result is an unspecified value.
\end{entry}

\begin{entry}{%
\proto{writer-chunk-size}{ writer}{procedure}}
   
Returns a positive exact integer, and is the recommended efficient
size of the write operations on this writer. As such, it is only a hint for
clients of the writer---calls to {\cf writer-write!} (see below) may specify a
different write count.

For a writer created by {\cf make-simple-writer}, the result is the value of the
\var{chunk-size} field of the argument writer.
\end{entry}

\begin{entry}{%
\proto{writer-write!}{ writer bytes start count}{procedure}}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integers. \var{Bytes} must have at least $\var{start} +
\var{count}$ elements.} The {\cf writer-write!} procedure
writes up to \var{count} bytes in bytes object \var{bytes}
starting at index \var{start}. Before writing any bytes, {\cf write-write!} blocks
until it can write at least one byte. The result is the number of bytes
actually written as a positive exact integer.
   
\var{Bytes} may or may not be a bytes object returned by {\cf
  make-i/o-buffer}, but {\cf writer-write!} may operate
more efficiently if it is.

\var{Count} may or may not be the same as the chunk size of the reader, but
 {\cf writer-write!} may operate more efficiently if it is.

For a writer created by {\cf make-simple-writer}, {writer-write!} tail-calls the
\var{write!} procedure of writer with the remaining arguments.  For
all other writers, the result values are unspecified.
\end{entry}   

\begin{entry}{%
\proto{writer-has-get-position?}{ writer}{procedure}
\proto{writer-get-position}{ writer}{procedure}}

The {\cf writer-has-get-position?} procedure \schtrue{} if \var{writer}
supports the {\cf writer-get-position} procedure, and \schfalse{}
otherwise.  For a simple writer, {\cf writer-has-get-position?}
returns \schtrue{} if it has a \var{get-position} procedure.
   
When {\cf writer-has-get-position?} returns \schtrue{} for
\var{writer}, {\cf writer-get-position}
returns the current position in the byte stream as
an exact integer counting the number of bytes since the beginning of
the stream.  Otherwise, an exception with condition
type {\cf\&assertion} is raised.

For a writer created by {\cf make-simple-writer}, {\cf
  writer-get-position} calls the \var{get-position} procedure of
\var{writer}.
\end{entry}

\begin{entry}{%
\proto{writer-has-set-position!?}{ writer}{procedure}
\proto{writer-set-position!}{ writer pos}{procedure}}

\domain{\var{Pos} must be a non-negative exact integer.}

The {\cf writer-has-set-position!?} procedure \schtrue{} if \var{writer}
supports the {\cf writer-set-position!} procedure, and \schfalse{}
otherwise.  For a simple writer, {\cf writer-has-set-position!?}
returns \schtrue{} if it has a \var{set-position!} procedure.

When {\cf writer-has-set-position!?} returns \schtrue{} for
\var{writer}, {\cf writer-set-position!}
moves to position \var{pos} (which must be a non-negative
exact integer) in the stream.
Otherwise, an exception with condition type
{\cf\&assertion} is raised.  

For a writer created by {\cf make-simple-writer}, {\cf
  writer-set-position!} calls the \var{set-position!}  procedure of
\var{writer} with the \var{pos} argument.  For writers not created by
{\cf make-simple-reader}, the result values are unspecified.
\end{entry}

\begin{entry}{%
\proto{writer-has-end-position?}{ writer}{procedure}
\proto{writer-end-position}{ writer}{procedure}}

The {\cf writer-has-end-position?} procedure \schtrue{} if \var{writer}
supports the {\cf writer-end-position} procedure, and \schfalse{}
otherwise.  For a simple writer, {\cf writer-has-end-position?}
returns \schtrue{} if it has a \var{end-position} procedure.
  
When {\cf writer-has-end-position?} returns \schtrue{} for writer,
{\cf writer-end-position}
returns the byte position of the next end of file, without
changing the current position.  Otherwise, an exception with condition
type {\cf\&assertion} is raised.
   
For a writer created by {\cf make-simple-writer}, {\cf
  writer-end-position} calls the \var{end-position} procedure of
\var{writer}.
\end{entry}

\begin{entry}{%
\proto{writer-close}{ writer}{procedure}}
   
Marks the writer as closed, performs any necessary cleanup, and
releases the resources associated with the writer. Further operations
on the writer must raise an exception with condition type
{\cf\&assertion}.
   
For a writer created by {\cf make-simple-writer}, calls the
\var{close} procedure of \var{writer}.  For all other writers,
the result values are unspecified.
\end{entry}

\begin{entry}{%
\proto{open-bytes-writer}{}{procedure}}
   
Returns a \defining{bytes writer} that can yield everything written to it as
a bytes object. The result writer supports the {\cf writer-get-position},
{\cf writer-set-position!}, and {\cf writer-end-position} operations.
\end{entry}

\begin{entry}{%
\proto{writer-bytes}{ writer}{procedure}}
   
\domain{The \var{writer} argument must be a bytes writer.}
The {\cf writer-bytes} procedure
returns a bytes object containing the data written to
writer in sequence. Doing this in no way invalidates the writer or
change its store.
The effect of modifying the contents of the returned bytes object
on \var{writer} is unspecified.
\end{entry}

\begin{entry}{%
\proto{clear-writer-bytes!}{ writer}{procedure}}

\domain{\var{Writer} must be a bytes writer.}
The {\cf clear-writer-bytes!} 
procedure clears the bytes object associated with \var{writer},
associating it with an empty bytes object.
\end{entry}

\begin{entry}{%
\proto{open-file-writer}{ filename}{procedure}
\rproto{open-file-writer}{ filename file-options}{procedure}}
   
Returns a writer connected to the file named by \var{filename}.
The \var{file-options} object, which determines various aspects of the returned writer
(see section~\ref{fileoptionssection})
defaults to {\cf (file-options)} if not
present. The result writer supports the {\cf writer-get-position},
{\cf writer-set-position!}, and {\cf writer-end-position} operations.
\end{entry}

\begin{entry}{%
\proto{standard-output-writer}{}{procedure}}
   
Returns a writer connected to the standard output. The meaning of
``standard output'' is implementation-dependent.
\end{entry}

\begin{entry}{%
\proto{standard-error-writer}{}{procedure}}
   
Returns a writer connected to the standard error. The meaning of
``standard error'' is implementation-dependent.
\end{entry}   

\subsection{Opening files for reading and writing}

\begin{entry}{%
\proto{open-file-reader+writer}{ filename}{procedure}
\rproto{open-file-reader+writer}{ filename file-options}{procedure}}
   
Returns two values: a reader and a writer connected to the file
named by \var{filename}. The \var{file-options} object, which determines various aspects of
the returned writer and possibly the reader (see
section~\ref{fileoptionssection}), defaults to
{\cf (file-options)} if not present. The result reader supports
the {\cf reader-get-position}, {\cf reader-set-position!}, {\cf
  reader-end-position}, and the result writer supports the {\cf writer-get-position}, {\cf
  writer-set-position!}, {\cf writer-end-position} operations.

\begin{note}
  The {\cf open-file-reader+writer} procedure enables opening 
  a file for simultaneous input and
  output in environments where it is not possible to call
  {\cf open-file-reader} and {\cf open-file-writer} on the same file.
\end{note}     
\end{entry}

\subsection{Examples}

\begin{schemenoindent}
; Algorithmic reader producing an infinite
; stream of blanks:

(define (make-infinite-blanks-reader)
  (make-simple-reader
    "<blanks, blanks, and more blanks>"
    \schfalse{}
    4096
    (lambda (bytes start count)
      (let loop ((index 0))
        (if (>= index count)
            index
            (begin
              (bytes-u8-set! bytes (+ start index) 32)
              (loop (+ 1 index))))))
    (lambda ()
      1000) ; some number
    \schfalse{} \schfalse{} \schfalse{}
    unspecific))
 
; Sample implementation of bytes writer

(define-record-type (buffer
                     make-buffer buffer?)
  (fields (mutable bytes
                   buffer-bytes set-buffer-bytes!)
          (mutable size
                   buffer-set-size set-buffer-size!)))

(define (open-bytes-writer)
  (let ((buffer
         (make-buffer (make-bytes 512) 0))
        (pos 0))

    (define (ensure-open)
      (if (not buffer)
          (raise (condition
                  (\&message
                   (message "bytes writer closed"))
                  (\&assertion)
                  (\&i/o-reader/writer
                   (reader/writer writer))))))

    (define writer
      (make-simple-writer
       "<bytes writer>"
       buffer
       3
       (lambda (bytes start count)
         (ensure-open)
         ;; resize buffer if necessary
         (let loop ((length 
                     (bytes-length
                       (buffer-bytes buffer))))
           (cond
            ((> (+ pos count) length)
             (loop (* 2 length)))
            ((> length (bytes-length (car buffer)))
             (let ((new-buffer (make-bytes length)))
               (bytes-copy! (buffer-bytes buffer) 0
                            new-buffer 0
                            (buffer-size buffer))
               (set-buffer-bytes! buffer new-buffer)))))

         (bytes-copy! bytes start
                      (buffer-bytes buffer) pos
                      count)
         (set-buffer-size!
           buffer
           (max (buffer-size buffer) (+ pos count)))
         (set! pos (+ pos count))
         count)
       (lambda ()
         (ensure-open)
         pos)
       (lambda (new-pos)
         (ensure-open)
         (if (<= new-pos (buffer-size buffer))
             (set! pos new-pos)
             (raise
              (condition
               (\&message
                (message "invalid position"))
               (\&i/o-invalid-position
                (position new-pos))))))
       (lambda ()
         (ensure-open)
         (buffer-size buffer))
       (lambda ()
         (set-buffer-bytes! buffer \schfalse{}))))
    writer))

(define (writer-bytes writer)
  (let* ((buffer (writer-descriptor writer))
         (target (make-bytes (buffer-size buffer))))
    (bytes-copy! (buffer-bytes buffer) 0
                 target 0
                 (buffer-size buffer))
    target))
\end{schemenoindent}
                
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
