\section{Primitive I/O}
\label{primiosection}

This section defines the \deflibrary{r6rs i/o primitive} library, a
simple, primitive I/O subsystem.  It provides unbuffered I/O, and is
close to what a typical operating system offers. Thus, its interface
is suitable for implementing high-throughput and zero-copy I/O.

This library also allows programs to implement custom data
sources and sinks via a simple interface.
It handles only blocking-I/O.

\subsection{File names}

Some of the procedures described here accept a file name as an
argument. Valid values for such a file name include strings that name a file
using the native notation of filesystem paths on the implementation's underlying
operating system.
A \var{filename} parameter name means that the
corresponding argument shall be a file name.

Some implementations will provide a more
abstract representation of file names. Indeed, most operating
systems do not use strings for representing file names, but rather byte
or word sequences. Moreover, the string notation is difficult to manipulate, and
it is not portable across operating systems.

\subsection{File options}
\label{fileoptionssection}

\mainindex{file options}
When opening a file, the various procedures in this library accept a
{\cf file-options} object that encapsulates flags to specify how
the file is to be opened. A {\cf file-options} object is an enum-set
(see section~\ref{enumerationssection}) over the symbols constituting
valid file options.
A \var{file-options} parameter name means that the
corresponding argument shall be a file-options object.

\begin{entry}{%
\proto{file-options}{ \hyper{file-options name} \dotsfoo}{\exprtype}}

Each \hyper{file-options name} shall be an \meta{identifier}.
The {\cf file-options} syntax returns a file-options object that 
encapsulates the
specified options. The following options (all affecting output
only) have predefined meaning:

\begin{itemize}   
\item {\cf create} create file if it does not already exist
\item {\cf exclusive} an exception with condition type
  {\cf\&i/o-file-already-exists} will be exclusive raised if this
  option and {\cf create} are both set and the file already exists
\item {\cf truncate}
  file is truncated
\end{itemize}

\meta{Identifiers}s other than those listed above may be used as \hyper{file-options name}s;
they have implementation-specific meaning, if any.

The file-options object returned by {\cf (file-options)} specifies,
when supplied to an operation opening a file for output, that the file
shall exist (otherwise an exception with condition type
{\cf\&i/o-file-exists-not} is raised) and its data is unchanged by the
operation.

\begin{rationale}
  The flags specified above represent only a common subset of
  meaningful options on popular platforms.  The {\cf file-options}
  form does not restrict the \hyper{file-options name}s so that
  implementations can extend the file options by platform-specific
  flags.
\end{rationale}
\end{entry}   

\subsection{Readers and Writers}

The objects representing input data sources are called readers, and
those representing output data sinks are called writers.
Both readers and writer are unbuffered, and they operate purely on binary data.  
Although some
reader and writer objects might conceivably have something to do with
files or devices, programmers should never assume it.
A \var{reader} parameter name means that the
corresponding argument shall be a reader.
A \var{writer} parameter name means that the
corresponding argument shall be a writer.

The \library{r6rs i/o primitive} library has one condition type
specific to readers and writers:

\begin{entry}{%
\ctproto{i/o-reader/writer}
\proto{i/o-reader-writer-error?}{ obj}{procedure}
\proto{i/o-error-reader/writer}{ condition}{procedure}}

This condition type could be defined by

\begin{scheme}
(define-condition-type \&i/o-reader/writer \&i/o
  i/o-reader/writer-error?
  (reader/writer i/o-error-reader/writer))
\end{scheme}

This condition type allows specifying the particular reader or writer
with which an I/O error is associated. Conditions raised by the
procedures exported by the \library{r6rs i/o primitive} may include an {\cf\&i/o-reader/writer} 
condition, but they are not required to do so.
\end{entry}

\subsection{I/O buffers}

\begin{entry}{%
\proto{make-i/o-buffer}{ size}{procedure}}

\domain{\var{Size} shall be a non-negative exact integer.} The {\cf make-i/o-buffer} procedure
creates a bytes object of size \var{size} with undefined contents.
Callers of the procedures from\library{r6rs i/o primitive}  are encouraged to use bytes
objects created by {\cf make-i/o-buffer}, because they might have
alignment and placement characteristics that {\cf make reader-read!}
and {\cf writer-write!} more efficient.  (Those procedures are still
required to work on regular bytes objects, however.)
\end{entry}

\subsection{Readers}

The purpose of reader objects is to represent the output of arbitrary
algorithms in a form susceptible to imperative I/O.

\begin{entry}{%
\proto{reader?}{ obj}{procedures}}
   
Returns \schtrue{} if \var{obj} is a reader, otherwise returns \schfalse.
\end{entry}

\begin{entry}{%
\pproto{(make-simple-reader \var{id} \var{descriptor}}{procedure}}
\mainschindex{make-simple-reader}{\tt\obeyspaces\\
    \var{chunk-size} \var{read!} \var{available} \var{get-position}
    \var{set-position!} \var{end-position} \var{close})}

Returns a reader object. \var{Id} shall be a string naming the reader,
provided for informational purposes only. \var{Descriptor} may be any
object; the procedures described in this section will not use it internally for any
purpose, but \var{descriptor} can be extracted from the reader object via
{\cf reader-descriptor}. Thus, \var{descriptor} can be used to keep the
internal state of certain kinds of readers.
   
\var{Chunk-size} shall be a positive exact integer, and it represents a recommended
efficient size of the read operations on this reader. This integer is typically the
block size of the buffers of the operating system. As such, it is only a
hint for clients of the reader---calls to the \var{read!} procedure (see below)
may specify a different read count.

The remaining arguments are procedures.  For each such procedure, an
operation exists that will call that procedure.  For example, the {\cf
  reader-read!} operation, when called on a simple reader, will call
its \var{read!} procedure.
It is encouraged that these procedures check that their arguments are
of the appropriate types.  The operations that call them will perform
no checking beyond ensuring that their \var{reader} arguments are
indeed readers, and, if applicable, that the reader supports the operation.
These procedures must raise
exceptions with condition types as specified above when they encounter an
exceptional situation. When they do not, the effects are unspecified.

\var{Get-position}, \var{set-position!}, and \var{end-position} may be
omitted, in which case the corresponding arguments shall be \schfalse.
   
\begin{itemize}
\item {\cf (\var{read!} \var{bytes} \var{start} \var{count})}
       
  \var{Start} and \var{count} shall be non-negative exact integers.
  The \var{read!} procedure
  reads up to \var{count} bytes from the reader and writes them
  into \var{bytes}, which shall be a bytes object, starting at index
  start. \var{Bytes} shall have size at least $\var{start} +
  \var{count}$. The result is the number of bytes read as an
  exact integer. The result is 0 if \var{read!} encounters an end of file, or if
  count is 0. If \var{count} is positive, \var{read!} blocks until at
  least one byte has been read or until it has encountered an end of file.
  
  \var{Bytes} may or may not be a bytes object returned by {\cf
    make-i/o-buffer}, but \var{read!} may operate
  more efficiently if it is.
  
  \var{Count} may or may not be the same as the chunk size of the
  reader, but \var{read!} may operate more
  efficiently if it is.

\item {\cf (\var{available})}
       
  Returns an estimate of the total number of bytes left in the
  reader. The result is either an exact integer, or
  \schfalse{} if no such estimate is possible. There is no guarantee
  that this estimate will have any specific relationship to the true
  number of available bytes.

\item {\cf (\var{get-position})}
       
  When present, \var{get-position}
  returns the current position in the 
  reader as an exact integer, counting the number of bytes since the
  beginning of the source. (Ends of file do not count as bytes.)
  
\item {\cf (\var{set-position!} \var{pos})}
       
  When present, \var{set-position!} moves to position \var{pos} (which
  shall be a non-negative exact integer) in the reader.
       
\item {\cf (\var{end-position})}
       
  When present, \var{end-position} returns the position in the reader
  of the next end of file, without changing the current position.

\item {\cf (\var{close})}
       
  Marks the reader as closed, performs any necessary
  cleanup, and releases the resources associated with the reader.
  Further operations on the reader shall raise an exception with
  condition type {\cf\&contract}.
\end{itemize}

\end{entry}

\begin{entry}{%
\proto{reader-id}{ reader}}
   
Returns a string naming the reader, provided for informational
purposes only. For a file reader returned by {\cf open-file-reader} or
{\cf open-file-reader+writer}, the result will be a string representation of the file
name.
  
For a reader created by {\cf make-simple-reader}, the result is the value that was
supplied as the \var{id} argument to {\cf make-simple-reader}.
\end{entry}

\begin{entry}{%
\proto{reader-descriptor}{ reader}{procedure}}
   
For a reader created by {\cf make-simple-reader}, the result is the value that was
supplied as the descriptor argument to {\cf make-simple-reader}.
   
For all other readers, the result is an unspecified value.
\end{entry}

\begin{entry}{%
\proto{reader-chunk-size}{ reader}{procedure}}
   
Returns a positive exact integer that represents a recommended
efficient size of the read operations on this reader. The result is typically the
block size of the buffers of the operating system. As such, it is only a
hint for clients of the reader---calls to the {\cf reader-read!} procedure (see
below) may specify a different read count.

For a reader created by {\cf make-simple-reader}, the result is the
value that was supplied as the chunk-size argument to {\cf
  make-simple-reader}.
\end{entry}

\begin{entry}{%
\proto{reader-read!}{ reader bytes start count}{procedure}}
   
\domain{\var{Start} and \var{count} shall be non-negative exact
  integers.  \var{Bytes} shall have at least $\var{start} +
\var{count}$ elements.} The {\cf reader-read!} procedure 
reads up to \var{count} bytes from the reader and writes them into
\var{bytes} starting at index
\var{start}.  The result is the number of bytes read
as an exact integer. The result is 0 if {\cf reader-read!} encounters an end of file, or
if \var{count} is 0.  If \var{count} is positive, {\cf reader-read!}
blocks until at least one byte has been
read or until it has encountered end of file.
   
\var{Bytes} may or may not be a bytes object returned by {\cf
  make-i/o-buffer}, but {\cf reader-read!} may operate
more efficiently if it is.
   
\var{Count} may or may not be the same as the chunk size of the
reader, but {\cf reader-read!} may operate more
efficiently if it is.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-read!}
tail-calls the \var{read!} procedure of reader with the remaining
arguments.
\end{entry}

\begin{entry}{%
\proto{reader-available}{ reader}{procedure}}
   
Returns an estimate of the total number of available bytes left in the
stream. The result is either an exact integer, or \schfalse{} if no such
estimate is possible. There is no guarantee that this estimate will have
any specific relationship to the true number of available bytes.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-available}
tail-calls the \var{available} procedure of reader.
\end{entry}   

\begin{entry}{%
\proto{reader-has-get-position?}{ reader}{procedure}}
   
Returns \schtrue{} if reader supports the {\cf reader-get-position}
procedure, and \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{reader-get-position}{ reader}{procedure}}
   
When {\cf reader-has-get-position} returns \schtrue{} for reader,
{\cf reader-get-position}
returns the current position in the byte stream as an exact integer
counting the number of bytes since the beginning of the stream.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-get-position} tail-calls the
\var{get-position} procedure of reader, if present. If reader does not
have a \var{get-position} procedure, an exception with condition type
{\cf\&contract} is raised.
\end{entry}

\begin{entry}{%
\proto{reader-has-set-position!?}{ reader}{procedure}}
   
Returns \schtrue{} if reader supports the {\cf reader-set-position!} operation, and
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{reader-set-position!}{ reader pos}{procedure}}

\domain{\var{Pos} shall be a non-negative exact integer.}
When {\cf reader-has-set-position!?} returns \schtrue{} for
\var{reader}, {\cf reader-set-position!}
moves to position \var{pos} in the stream.
 
For a reader created by {\cf make-simple-reader}, {\cf reader-set-position!} tail-calls the
\var{set-position!} procedure of \var{reader} with the \var{pos}
argument, if present.  If \var{reader} does not support the operation,
an {\cf exception} with condition type {\cf\&contract} is raised.
For readers not created by {\cf make-simple-reader}, the result values
are unspecified.
\end{entry}

\begin{entry}{%
\proto{reader-has-end-position?}{ reader}{procedure}}
   
Returns \schtrue{} if reader supports the {\cf reader-end-position}
operation, and \schfalse{} otherwise.
\end{entry}   

\begin{entry}{%
\proto{reader-end-position}{ reader}{procedure}}
   
When {\cf reader-has-end-position?} returns \schtrue{} for \var{reader},
{\cf reader-end-position}
returns the position in the byte stream of the next end of file,
without changing the current position.
   
For a reader created by {\cf mmake-simple-reader}, {\cf reader-end-position} tail-calls the
\var{end-position} procedure of \var{reader}, if present. If
\var{reader} does not have a \var{end-position} procedure, an
exception with condition type {\cf\&contract} is raised.
\end{entry}

\begin{entry}{%
\proto{reader-close}{ reader}{procedure}}
   
Marks \var{reader} as closed, performs any necessary cleanup, and
releases the resources associated with the reader. Further operations
on the reader must raise an exception with condition type
{\cf\&contract}.
   
For a reader created by {\cf make-simple-reader}, {\cf reader-close} tail-calls the
\var{close} procedure of reader.  For all other readers, the return
values are unspecified.
\end{entry}

\begin{entry}{%
\proto{open-bytes-reader}{ bytes}{procedure}}

Returns a \defining{bytes reader} that uses 
\var{bytes}, a bytes object, as its contents. The result reader supports
the {\cf reader-get-position}, {\cf reader-set-position!}, and \var{reader-end-position}
operations.
The effect of modifying the contents of \var{bytes}, after 
{\cf open-bytes-reader} has been called, on the reader is unspecified.
\end{entry}

\begin{entry}{%
\proto{open-file-reader}{ filename}{procedure}
\rproto{open-file-reader}{ filename file-options}{procedure}}
   
Returns a reader connected to the file named by \var{filename}.
The \var{file-options} object, which may determine various aspects of the returned reader
(see section~\ref{fileoptionssection}) defaults to {\cf (file-options)} if not
present.
The result reader supports {\cf reader-get-position},
{\cf reader-set-position!}, and {\cf reader-end-position} operations.
\end{entry} 

\begin{entry}{%
\proto{standard-input-reader}{}{procedure}}
   
Returns a reader connected to the standard input. The meaning of
``standard input'' is implementation-dependent.
\end{entry}

\subsection{Writers}

The purpose of writer objects is to represent the input of arbitrary
algorithms in a form susceptible to imperative I/O.

\begin{entry}{%
\proto{writer?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a writer, otherwise returns \schfalse.
\end{entry}

\begin{entry}{%
\pproto{(make-simple-writer \var{id} \var{descriptor}}{procedure}}
\mainschindex{make-simple-writer}{\tt\obeyspaces\\
    \var{chunk-size} \var{write!} \var{get-position} \var{set-position!}
    \var{end-position} \var{close})}
   
Returns a writer object. \var{Id} shall be a string naming the writer,
provided for informational purposes only. \var{Descriptor} may be any
object; the procedures described in this section will not use it internally for any
purpose, but \var{descriptor} can be extracted from the writer object via
{\cf writer-descriptor}. Thus, \var{descriptor} can be used to keep the
internal state of certain kinds of writers.

\var{Chunk-size} shall be a positive exact integer, and it is the
recommended efficient size of the write operations on this writer. As
such, it is only a hint for clients of the writer---calls to the
\var{write!} procedure (see below) may specify a different write
count.

The remaining arguments are procedures.  For each such procedure, an
operation exists that will call that procedure.  For example, the {\cf
  writer-write!} operation, when called on a simple writer, will call
its \var{write!} procedure.
It is encouraged that these procedures check that their arguments are
of the appropriate types.  The operations that call them will perform
no checking beyond ensuring that their \var{writer} arguments are
indeed writers, and, if applicable, that the writer supports the operation.
These procedures must raise
exceptions with condition types as specified above when they encounter an
exceptional situation. When they do not, the effects are unspecified.

\var{Get-position}, \var{set-position!}, and \var{end-position} may be
omitted, in which case the corresponding arguments shall be \schfalse.

\begin{itemize}
\item {\cf (\var{write!} \var{bytes} \var{start} \var{count})}
   
  \var{Start} and \var{count} shall be non-negative exact integers.
  The \var{write!} procedure
  writes up to \var{count} bytes in bytes object \var{bytes}
  starting at index \var{start}. Before writing any bytes, {\cf write!} blocks
  until it can write at least one byte. The result is the number of bytes
  actually written as a positive exact integer.
  
  \var{Bytes} may or may not be a bytes object returned by {\cf
    make-i/o-buffer}, but {\cf writer-write!} may operate more
  efficiently if it is.
  
  \var{Count} may or may not be the same as the chunk size of the
  reader, but {\cf writer-write!} may operate more
  efficiently if it is.

\item {\cf (\var{get-position})}
   
  When present, \var{get-position} returns the current position in the byte
  stream as an exact integer counting the number of bytes since the
  beginning of the stream.
   
\item {\cf (\var{set-position!} \var{pos})}
   
  When present, \var{set-position!} moves to position \var{pos} (which shall be a
  non-negative exact integer) in the stream.
  
\item {\cf (\var{end-position})}
   
    When present, \var{end-position} returns the byte position of the next end
    of file without changing the current position.
   
\item {\cf (\var{close})}
  
  Marks the writer as closed, performs any necessary
  cleanup, and releases the resources associated with the writer. Further
  operations on the writer must raise an exception with condition type
  {\cf\&contract}.
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{writer-id}{ writer}{procedure}}
   
Returns string naming the writer, provided for informational
purposes only. For a file writer returned by {\cf open-file-writer}
or {\cf open-file-reader+writer}, the result is a string
representation of the file name.
   
For a writer created by {\cf make-simple-writer}, the result is the
value of the \var{id} field of the argument writer.
\end{entry}

\begin{entry}{%
\proto{writer-descriptor}{ writer}{procedure}}
   
  For a writer created by {\cf make-simple-writer}, {\cf write-descriptor} 
  returns the value of the
  \var{descriptor} field of the argument writer.
  
  For all other writers, the result is an unspecified value.
\end{entry}

\begin{entry}{%
\proto{writer-chunk-size}{ writer}{procedure}}
   
Returns a positive exact integer, and is the recommended efficient
size of the write operations on this writer. As such, it is only a hint for
clients of the writer---calls to {\cf writer-write!} (see below) may specify a
different write count.

For a writer created by {\cf make-simple-writer}, the result is the value of the
\var{chunk-size} field of the argument writer.
\end{entry}

\begin{entry}{%
\proto{writer-write!}{ writer bytes start count}{procedure}}
   
\domain{\var{Start} and \var{count} shall be non-negative exact
  integers. \var{Bytes} shall have at least $\var{start} +
\var{count}$ elements.} The {\cf writer-write!} procedure
writes up to \var{count} bytes in bytes object \var{bytes}
starting at index \var{start}. Before writing any bytes, {\cf write-write!} blocks
until it can write at least one byte. The result is the number of bytes
actually written as a positive exact integer.
   
\var{Bytes} may or may not be a bytes object returned by {\cf
  make-i/o-buffer}, but {\cf writer-write!} may operate
more efficiently if it is.

\var{Count} may or may not be the same as the chunk size of the reader, but
 {\cf writer-write!} may operate more efficiently if it is.

For a writer created by {\cf make-simple-writer}, {writer-write!} tail-calls the
\var{write!} procedure of writer with the remaining arguments.  For
all other writers, the result values are unspecified.
\end{entry}   

\begin{entry}{%
\proto{writer-has-get-position?}{ writer}{procedure}}
   
Returns \schtrue{} if writer supports the {\cf
  writer-get-position} operation, and \schfalse{} otherwise.
\end{entry}   

\begin{entry}{%
\proto{writer-get-position}{ writer}{procedure}}
   
When {\cf writer-has-get-position?} returns \schtrue{} for
\var{writer}, {\cf writer-get-position}
returns the current position in the byte stream as
an exact integer counting the number of bytes since the beginning of
the stream.
  
For a writer created by {\cf make-simple-writer}, 
{\cf writer-get-position} calls the
\var{get-position} procedure of \var{writer}, if present. If \var{writer}
does not have a get-position procedure, an exception with condition
type {\cf\&contract} is raised.
\end{entry}

\begin{entry}{%
\proto{writer-has-set-position!?}{ writer}{procedure}}
   
Returns \schtrue{} if writer supports the \var{writer-set-position!} operation, and
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{writer-set-position!}{ writer pos}{procedure}}
   
When {\cf writer-has-set-position!?} returns \schtrue{} for
\var{writer}, {\cf writer-set-position!}
moves to position \var{pos} (which shall be a non-negative
exact integer) in the stream.
   
For a writer created by {\cf make-simple-writer}, {\cf writer-set-position!} calls the
\var{set-position!}  procedure of \var{writer} with the \var{pos}
argument, if present. If \var{writer} does not have a
\var{set-position!} procedure, an exception with condition type
{\cf\&contract} is raised.  For writers not created by {\cf
  make-simple-writer}, the result values are unspecified.
\end{entry}

\begin{entry}{%
\proto{writer-has-end-position?}{ writer}{procedure}}
   
Returns \schtrue{} if \var{writer} supports the {\cf
  writer-end-position} operation, and \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{writer-end-position}{ writer}{procedure}}
   
When {\cf writer-has-end-position?} returns \schtrue{} for writer,
{\cf writer-end-position}
returns the byte position of the next end of file, without
changing the current position.
   
For a writer created by {\cf make-simple-writer}, 
{\cf writer-end-position} calls the
\var{end-position} procedure of \var{writer}, if present. If \var{writer}
does not have a \var{end-position} procedure, an exception with condition
type {\cf\&contract} is raised.
\end{entry}

\begin{entry}{%
\proto{writer-close}{ writer}{procedure}}
   
Marks the writer as closed, performs any necessary cleanup, and
releases the resources associated with the writer. Further operations
on the writer must raise an exception with condition type
{\cf\&contract}.
   
For a writer created by {\cf make-simple-writer}, calls the
\var{close} procedure of \var{writer}.  For all other writers,
the result values are unspecified.
\end{entry}

\begin{entry}{%
\proto{open-bytes-writer}{}{procedure}}
   
Returns a \defining{bytes writer} that can yield everything written to it as
a bytes object. The result writer supports the {\cf writer-get-position},
{\cf writer-set-position!}, and {\cf writer-end-position} operations.
operations.
\end{entry}

\begin{entry}{%
\proto{writer-bytes}{ writer}{procedure}}
   
\domain{The \var{writer} argument shall be a bytes writer.}
The {\cf writer-bytes} procedure
returns a bytes object containing the data written to
writer in sequence. Doing this in no way invalidates the writer or
change its store.
The effect of modifying the contents of the returned bytes object
on \var{writer} is unspecified.
\end{entry}

\begin{entry}{%
\proto{clear-writer-bytes!}{ writer}{procedure}}

\domain{\var{Writer} shall be a bytes writer.}
The {\cf clear-writer-bytes!} 
procedure clears the bytes object associated with \var{writer},
associating it with an empty bytes object.
\end{entry}

\begin{entry}{%
\proto{open-file-writer}{ filename}{procedure}
\rproto{open-file-writer}{ filename file-options}{procedure}}
   
Returns a writer connected to the file named by \var{filename}.
The \var{file-options} object, which determines various aspects of the returned writer
(see section~\ref{fileoptionssection})
defaults to {\cf (file-options)} if not
present. The result writer supports the {\cf writer-get-position},
{\cf writer-set-position!}, and {\cf writer-end-position} operations.
\end{entry}

\begin{entry}{%
\proto{standard-output-writer}{}{procedure}}
   
Returns a writer connected to the standard output. The meaning of
``standard output'' is implementation-dependent.
\end{entry}

\begin{entry}{%
\proto{standard-error-writer}{}{procedure}}
   
Returns a writer connected to the standard error. The meaning of
``standard error'' is implementation-dependent.
\end{entry}   

\subsection{Opening files for reading and writing}

\begin{entry}{%
\proto{open-file-reader+writer}{ filename}{procedure}
\rproto{open-file-reader+writer}{ filename file-options}{procedure}}
   
Returns two values: a reader and a writer connected to the file
named by \var{filename}. The \var{file-options} object, which determines various aspects of
the returned writer and possibly the reader (see
section~\ref{fileoptionssection}), defaults to
{\cf (file-options)} if not present. The result reader supports
the {\cf reader-get-position}, {\cf reader-set-position!}, {\cf
  reader-end-position}, and the result writer supports the {\cf writer-get-position}, {\cf
  writer-set-position!}, {\cf writer-end-position} operations.

\begin{note}
  The {\cf open-file-reader+writer} procedure enables opening 
  a file for simultaneous input and
  output in environments where it is not possible to call
  {\cf open-file-reader} and {\cf open-file-writer} on the same file.
\end{note}     
\end{entry}

\subsection{Examples}

\begin{schemenoindent}
; Algorithmic reader producing an infinite
; stream of blanks:

(define (make-infinite-blanks-reader)
  (make-simple-reader
    "<blanks, blanks, and more blanks>"
    \schfalse{}
    4096
    (lambda (bytes start count)
      (let loop ((index 0))
        (if (>= index count)
            index
            (begin
              (bytes-u8-set! bytes (+ start index) 32)
              (loop (+ 1 index))))))
    (lambda ()
      1000) ; some number
    \schfalse{} \schfalse{} \schfalse{}
    unspecific))
 
; Sample implementation of bytes writer

(define-record-type (buffer
                     make-buffer buffer?)
  (fields (mutable bytes
                   buffer-bytes set-buffer-bytes!)
          (mutable size
                   buffer-set-size set-buffer-size!)))

(define (open-bytes-writer)
  (let ((buffer
         (make-buffer (make-bytes 512) 0))
        (pos 0))

    (define (ensure-open)
      (if (not buffer)
          (raise (condition
                  (\&message
                   (message "bytes writer closed"))
                  (\&contract)
                  (\&i/o-reader/writer
                   (reader/writer writer))))))

    (define writer
      (make-writer
       "<bytes writer>"
       buffer
       3
       (lambda (bytes start count)
         (ensure-open)
         ;; resize buffer if necessary
         (let loop ((length 
                     (bytes-length
                       (buffer-bytes buffer))))
           (cond
            ((> (+ pos count) length)
             (loop (* 2 length)))
            ((> length (bytes-length (car buffer)))
             (let ((new-buffer (make-bytes length)))
               (bytes-copy! (buffer-bytes buffer) 0
                            new-buffer 0
                            (buffer-size buffer))
               (set-buffer-bytes! buffer new-buffer)))))

         (bytes-copy! bytes start
                      (buffer-bytes buffer) pos
                      count)
         (set-buffer-size!
           buffer
           (max (buffer-size buffer) (+ pos count)))
         (set! pos (+ pos count))
         count)
       (lambda ()
         (ensure-open)
         pos)
       (lambda (new-pos)
         (ensure-open)
         (if (<= new-pos (buffer-size buffer))
             (set! pos new-pos)
             (raise
              (condition
               (\&message
                (message "invalid position"))
               (\&i/o-invalid-position
                (position new-pos))))))
       (lambda ()
         (ensure-open)
         (buffer-size buffer))
       (lambda ()
         (set-buffer-bytes! buffer \schfalse{}))))
    writer))

(define (writer-bytes writer)
  (let* ((buffer (writer-descriptor writer))
         (target (make-bytes (buffer-size buffer))))
    (bytes-copy! (buffer-bytes buffer) 0
                 target 0
                 (buffer-size buffer))
    target))
\end{schemenoindent}
                
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
