% 1. Structure of the language

\chapter{Overview of Scheme}
\label{semanticchapter}

This chapter gives an overview of Scheme's semantics.  A
detailed informal semantics is the subject of
the following chapters.  For reference
purposes, section~\ref{formalsemanticssection} provides a formal
semantics of Scheme.

\vest Following Algol, Scheme is a statically scoped programming
language.  Each use of a variable is associated with a lexically
apparent binding of that variable.

\vest Scheme has latent as opposed to manifest types.  Types
are associated with values (also called objects\mainindex{object}) rather than
with variables.  (Some authors refer to languages with latent types as
weakly typed or dynamically typed languages.)  Other languages with
latent types are Python, Ruby, Smalltalk, and other dialects of Lisp.  Languages
with manifest types (sometimes referred to as strongly typed or
statically typed languages) include Algol 60, C, C\#, Java, Haskell and ML.

\vest All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.
No Scheme object is ever destroyed.  The reason that
implementations of Scheme do not (usually!)\ run out of storage is that
they are permitted to reclaim the storage occupied by an object if
they can prove that the object cannot possibly matter to any future
computation.  Other languages in which most objects have unlimited
extent include C\#, Haskell, ML, Python, Ruby, Smalltalk and other Lisp dialects.

\vest Implementations of Scheme are required to be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure.  Thus with a properly tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call
mechanics, so that special iteration constructs are useful only as
syntactic sugar.  See section~\ref{proper tail recursion}.

\vest Scheme was one of the first languages to support procedures as
objects in their own right.  Procedures can be created dynamically,
stored in data structures, returned as results of procedures, and so
on.  Other languages with these properties include Common Lisp,
Haskell, ML, Python, Ruby, and Smalltalk.

\vest One distinguishing feature of Scheme is that continuations, which
in most other languages only operate behind the scenes, also have
``first-class'' status.  Continuations are useful for implementing a
wide variety of advanced control constructs, including non-local exits,
backtracking, and coroutines.  See section~\ref{continuations}.

\vest Arguments to Scheme procedures are always passed by value, which
means that the actual argument expressions are evaluated before the
procedure gains control, whether the procedure needs the result of the
evaluation or not.  C, C\#, Common Lisp, Python, Ruby, and Smalltalk
are other languages that always pass arguments by value.  This is
distinct from the lazy-evaluation semantics of Haskell, or the
call-by-name semantics of Algol 60, where an argument expression is
not evaluated unless its value is needed by the procedure.  Note that
call-by-value refers to a different distinction than the distinction
between by-value and by-reference passing in Pascal.  In Scheme, all
data structures are passed by-reference.

\vest Scheme's model of arithmetic is designed to remain as
independent as possible of the particular ways in which numbers are
represented within a computer. In Scheme, every integer is a rational
number, every rational is a real, and every real is a complex number.
Scheme distinguishes between exact arithmetic, which corresponds to
the mathematical ideal, and inexact arithmetic on approximations.
Exact arithmetic includes arithmetic on integers, rationals and
complex numbers.

FIXME: overview of the language to be added

\section{Programs and libraries}

A Scheme consists of a set of \textit{libraries\index{library}}, each
of which defines a part of the program connected to the others through
explicitly specified exports and imports.  A library consists of a set
of import and export FIXME specifications and a body, which contains
the code defining the library.  Chapter~\ref{librarychapter} describes
the syntax and semantics for libraries.  The subsequent chapters
describe various standard libraries provided by a Scheme system.  In
particular, chapter~\ref{baselibrarychapter} describes a base
library defining most of the constructs traditionally associated with
Scheme programs.

The division between the base library and other standard libraries is
based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or
run-time libraries rather than in terms of other standard procedures
 or syntactic forms are not part of the base library, but defined in
separate libraries.  Examples include the fixnum and flonum libraries,
the exceptions and conditions libraries, and the libraries for
records.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
