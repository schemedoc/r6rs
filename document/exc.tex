\chapter{Exceptions and conditions}
\label{exceptionsconditionschapter}

Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

The exception system allows the program, when it detects an
exceptional situation, to pass control to an exception handler, and
to dynamically establish such exception handlers.  Exception
handlers are always invoked with an object describing the exceptional
situation.  Scheme's condition system provides a standardized taxonomy
of such descriptive objects, as well as a facility for extending the
taxonomy.

\section{Exceptions}
\label{exceptionssection}
\mainindex{exceptions}

This section describes Scheme's exception-handling and
exception-raising constructs provided by the \deflibrary{r6rs
  exceptions} library.

\begin{note}
  This specification follows SRFI~34~\cite{srfi34}.
\end{note}

Exception handlers are one-argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

\mainindex{current exception handler}The program raises an exception
by invoking the current exception handler, passing to it an object
encapsulating information about the exception. Any procedure accepting
one argument may serve as an exception handler and any object may be
used to represent an exception.

The system maintains the current exception handler as part of the
\defining{dynamic environment} of the program, the context for {\tt
  dynamic-wind}. The dynamic environment can be thought of as that
part of a continuation that does not specify the destination of any
returned values. It includes the {\tt dynamic-wind} context and the
current exception handler.

When a program begins its execution, the current
exception handler is expected to handle all {\cf\&serious}
conditions by interrupting execution, reporting that an
exception has been raised, and displaying information
about the condition object that was provided.  The handler
may then exit, or may provide a choice of other options.
Moreover, the exception handler is expected to return when
passed any other non-{\cf\&serious} condition.
Interpretation of these expectations necessarily depends
upon the nature of the system in which programs are executed,
but the intent is that users perceive the raising of an
exception as a controlled escape from the situation that
raised the exception, not as a crash.

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{\var{Handler} should be a
procedure that accepts one argument.
\var{Thunk} must be a procedure that accepts zero arguments.}  The {\cf
with-exception-handler} procedure returns the results of invoking
\var{thunk}.  \var{Handler} is installed as the current
exception handler for the dynamic extent (as determined by {\tt
  dynamic-wind}) of the invocation of \var{thunk}.

\implresp The implementation must check the restrictions on
\var{handler} to the extent performed by applying it as described,
when it is called as a result of a call to {\cf raise} or {\cf
  raise-continuable}.
\end{entry}

\begin{entry}{%
\pproto{(guard (\hyper{variable} \hyperi{clause} \hyperii{clause} \dotsfoo)  \hyper{body})}{\exprtype}}
\mainschindex{guard}

\syntax
Each \hyper{clause} must have the same form as a {\tt cond} clause.
(See report section~\extref{report:cond}{Derived conditionals}.)

\semantics 
Evaluating a {\tt guard} form evaluates \hyper{body} with an exception
handler that binds the raised object to \hyper{variable} and within the scope of
that binding evaluates the clauses as if they were the clauses of a
{\tt cond} expression. That implicit {\tt cond} expression is evaluated with the
continuation and dynamic environment of the {\tt guard} expression. If every
\hyper{clause}'s \hyper{test} evaluates to false and there is no else clause, then
{\cf raise} is re-invoked on the raised object within the dynamic
environment of the original call to raise except that the current
exception handler is that of the {\tt guard} expression.  
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

Raises a non-continuable exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation whose
dynamic environment is that of the call to {\tt raise}, except that
the current exception handler is the one that was in place when the handler being
called was installed.  When the handler returns, a non-continuable
exception with condition type {\tt \&non-continuable} is raised.
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

Raises a continuable exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation that
is equivalent to the continuation of the call to {\tt
  raise-continuable} with these two exceptions: (1) the current
exception handler is the one that was in place 
when the handler being called was installed, and
(2) if the handler being called returns, then it will again become the
current exception handler.  If the handler returns, the values it
returns become the values returned by the call to
{\tt raise-continuable}.
\end{entry}

\begin{scheme}
(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred")
              'error))
         ((violation? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "the program has a bug"))
          'violation))
  (raise
    (condition
      (\&error)
      (\&message (message "I am an error")))))
   {\it prints:} I am an error
   \ev error%

(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred")
              'error)))
  (raise
    (condition
      (\&violation)
      (\&message (message "I am an error")))))
  \ev \exception{\&violation}

(guard (con
         ((error? con)
          (display "error opening file")
          \schfalse))
  (call-with-input-file "foo.scm" read))
   {\it prints:} error opening file
   \ev \schfalse{}

(with-exception-handler
  (lambda (con)
    (cond
      ((not (warning? con))
       (raise con))
      ((message-condition? con)
       (display (condition-message con)))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable
         (condition
           (\&warning)
           (\&message
             (message "should be a number"))))
       23)))
   {\it prints:} should be a number
   \ev 65
\end{scheme}

\section{Conditions}
\label{conditionssection}

The section describes Scheme \deflibrary{r6rs
  conditions} library for creating and inspecting
condition types and values. A condition value encapsulates information
about an exceptional situation\mainindex{exceptional situation}, or
\defining{exception}. Scheme also defines a
number of basic condition types.

\begin{note}
  This specification is similar to, but not identical with
  SRFI~35~\cite{srfi35}.
\end{note}

Scheme conditions provides two mechanisms to enable communication
about exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound
conditions allow an exceptional situation to be described in multiple
ways.

\begin{rationale}
Conditions are values that communicate information about exceptional
situations between parts of a program. Code that detects an exception
may be in a different part of the program than the code that handles
it. In fact, the former may have been written independently from the
latter. Consequently, to facilitate effective handling of exceptions,
conditions should communicate as much information as possible as
accurately as possible, and still allow effective handling by code
that did not precisely anticipate the nature of the exception that
occurred.
\end{rationale}

\subsection{Condition objects}

Conditions are objects with named fields. Each condition belongs to
one or more condition types. Each condition type specifies a set of
field names. A condition belonging to a condition type includes a
value for each of the type's field names. These values can be
extracted from the condition by using the appropriate field name.

The condition system distinguishes between \textit{simple
  conditions}\index{simple condition} and \textit{compound
  conditions}\index{compound condition}.  A compound condition
consists of an ordered set of simple conditions.  Thus, every
condition can be viewed as an ordered set of simple component
conditions: If it is simple, the set consists of the condition itself;
if it is compound, it consists of the simple conditions that compose
it.

There is a tree of condition types with the distinguished {\tt
  \&condition} as its root. All other condition types have a parent
condition type.

\begin{entry}{%
\proto{make-condition-type}{ \var{id} \var{parent} \var{field-names}}{procedure}}

Returns a new condition type. \var{Id} must
be a symbol that serves as a symbolic name for the condition type.
\var{Parent} must itself be a condition type. \var{Field-names} must
be a list of symbols. It identifies the fields of the conditions
associated with the condition type.

\var{Field-names} must be disjoint from the field names of
\var{parent} and its ancestors. 
\end{entry}

\begin{entry}{%
\proto{condition-type?}{ \var{thing}}{procedure}}

Returns \schtrue{} if \var{thing} is a condition type, and \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{make-condition}{ \var{type} \var{alist}}{procedure}}

Returns a simple condition value belonging to condition
type \var{type}. \var{Alist} must be an association list mapping
field names to arbitrary values.  There must be a pair in the
association list for each field of \var{type} and its direct and indirect
supertypes. The {\cf make-condition} procedure returns the condition
value, which fields and values as indicated by \var{alist}.
\end{entry}

\begin{entry}{%
\proto{condition?}{ \var{obj}}{procedure}}

Returns \schtrue{} if \var{obj} is a condition object, and \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{condition-has-type?}{ \var{condition} \var{condition-type}}{procedure}}

The {\cf condition-has-type?} procedure tests if condition condition belongs to
condition type \var{condition-type}. It returns \schtrue{} if any of
condition's types includes \var{condition-type}, either directly or as
an ancestor, and \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{condition->list}{ \var{condition}}{procedure}}

Returns a list of the component conditions of \var{condition}.
\end{entry}

\begin{entry}{%
\proto{condition-ref}{ \var{condition} \var{type} \var{field-name}}{procedure}}

\domain{\var{Condition} must be a condition, \var{type} a condition
  type, and \var{field-name} a symbol naming a field of type or its
  direct or indirect supertypes.  Moreover, condition must be a simple
  condition of type \var{type}, or a compound condition containing a
  simple condition of type \var{type}.}  The {\cf condition-ref}
procedure returns the value of the field named by \var{field-name} in
the first component condition of \var{condition} that has type \var{type}.
\end{entry}

\begin{entry}{%
\proto{make-compound-condition}{ \vari{condition} \dotsfoo}{procedure}}

Returns a compound condition consisting of the component conditions of
\vari{condition}, \dotsfoo, in that order.
\end{entry}

\begin{entry}{%
\pproto{(define-condition-type \hyper{condition-type}}{\exprtype}}
{\tt\obeyspaces\\
    \hyper{supertype}\\
  \hyper{predicate}\\
  \hyperi{field-spec} \dotsfoo)}
\mainschindex{define-condition-type}

\syntax \hyper{Condition-type},
\hyper{supertypes}, and \hyper{predicate} must all be identifiers.
Each \hyper{field-spec} must be of the form
%
\begin{scheme}
(\hyper{field} \hyper{accessor})%
\end{scheme}
%
where both \hyper{field} and \hyper{accessor} must be identifiers.

\semantics
The {\cf define-condition-type} form expands into a set of
definitions:

\begin{itemize}
\item \hyper{Condition-type}, which is bound to some value describing a new condition type.
\hyper{Supertype} must be the name of a previously defined condition
type.

\item \hyper{Predicate} is bound to a
predicate that identifies conditions associated with that type, or
with any of its subtypes.

\item Each \hyper{accessor} is bound to a
procedure which extracts the value of the named field from a condition
associated with this condition type.  An \hyper{accessor} associated
with \hyper{field} behaves as defined via
%
\begin{scheme}
(define \hyper{accessor}
  (lambda (c)
    (condition-ref c \hyper{condition-type} '\hyper{field})))
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{condition}{ \hyperi{type-field-binding} \dotsfoo}{\exprtype}}

Returns a condition value. Each \hyper{type-field-binding} must be of
the form
%
\begin{scheme}
(\hyper{condition-type} \hyperi{field-binding} \dotsfoo)%
\end{scheme}
%
Each \hyper{field-binding}
must be of the form
%
\begin{scheme}
(\hyper{field} \hyper{expression})  %
\end{scheme}
%
where \hyper{field} is a field identifier from the definition of
\hyper{condition-type}.

The condition returned by condition is created by a call of the form
%
\begin{schemenoindent}
(make-compound-condition
  (make-condition \hyper{condition-type}
                  (list (cons '\hyper{field-name} \hyper{expression})
                        \dotsfoo))
  \dotsfoo)
\end{schemenoindent}
%
with the condition types retaining their order from the condition
form.
\end{entry}

\begin{entry}{%
\ctproto{condition}}

This is the root of the entire condition type hierarchy. It has no
fields.
\end{entry}

\begin{scheme}
(define-condition-type \&c \&condition
  c?
  (x c-x))

(define-condition-type \&c1 \&c
  c1?
  (a c1-a))

(define-condition-type \&c2 \&c
  c2?
  (b c2-b))%
\end{scheme}

\begin{scheme}
(define v1
  (make-condition \&c1
    (list (cons 'x "V1")
          (cons 'a "a1"))))

(c? v1)        \ev \schtrue
(c1? v1)       \ev \schtrue
(c2? v1)       \ev \schfalse
(c-x v1)       \ev "V1"
(c1-a v1)      \ev "a1"%
\end{scheme}

\begin{scheme}
(define v2 (condition (\&c2
                        (x "V2")
                        (b "b2"))))

(c? v2)        \ev \schtrue
(c1? v2)       \ev \schfalse
(c2? v2)       \ev \schtrue
(c-x v2)       \ev "V2"
(c2-b v2)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v3 (condition (\&c1
                       (x "V3/1")
                       (a "a3"))
                      (\&c2
                       (x "V3/2")
                       (b "b3"))))

(c? v3)        \ev \schtrue
(c1? v3)       \ev \schtrue
(c2? v3)       \ev \schtrue
(c-x v3)       \ev "V3/1"
(c1-a v3)      \ev "a3"
(c2-b v3)      \ev "b3"%
\end{scheme}

\begin{scheme}
(define v4 (make-compound-condition v1 v2))

(c? v4)        \ev \schtrue
(c1? v4)       \ev \schtrue
(c2? v4)       \ev \schtrue
(c-x v4)       \ev "V1"
(c1-a v4)      \ev "a1"
(c2-b v4)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v5 (make-compound-condition v2 v3))

(c? v5)        \ev \schtrue
(c1? v5)       \ev \schtrue
(c2? v5)       \ev \schtrue
(c-x v5)       \ev "V2"
(c1-a v5)      \ev "a3"
(c2-b v5)      \ev "b2"%
\end{scheme}

\section{Standard condition types}

\begin{entry}{%
\ctproto{message}
\proto{message-condition?}{ obj}{procedure}
\proto{condition-message}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&message \&condition
  message-condition?
  (message condition-message))%
\end{scheme}
%
It carries a message further describing the nature of the condition to
humans.  
\end{entry}

\begin{entry}{%
\ctproto{warning}
\proto{warning?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&warning \&condition
  warning?)%
\end{scheme}
%
This type describes conditions that do not, in
principle, prohibit immediate continued execution of the program, but
may interfere with the program's execution later.
\end{entry}

\begin{entry}{%
\ctproto{serious}
\proto{serious-condition?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&serious \&condition
  serious-condition?)%
\end{scheme}

This type describes conditions serious enough that they cannot safely
be ignored. This condition type is primarily intended as a supertype
of other condition types. 
\end{entry}

\begin{entry}{%
\ctproto{error}
\proto{error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&error \&serious
  error?)%
\end{scheme}
%
This type describes errors, typically caused by something that
has gone wrong in the interaction of the program with the external
world or the user.
\end{entry}

\begin{entry}{%
\ctproto{violation}
\proto{violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&violation \&serious
  violation?)%
\end{scheme}
%
This type describes violations of the language standard or a
library standard, typically caused by a programming error.
\end{entry}  

\begin{entry}{%
\ctproto{non-continuable}
\proto{non-continuable?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&non-continuable \&violation
  non-continuable?)%
\end{scheme}
%
This type denotes that an exception handler invoked via
\texttt{raise} has returned.
\end{entry}

\begin{entry}{%
\ctproto{implementation-restriction}
\proto{implementation-restriction?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&implementation-restriction
    \&violation
  implementation-restriction?)%
\end{scheme}
%
This type describes a violation of an implementation restriction
allowed by the specification, such as the absence of representations
for NaNs and infinities.  (See section~\ref{flonumssection}.)
\end{entry}

\begin{entry}{%
\ctproto{lexical}
\proto{lexical-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&lexical \&violation
  lexical-violation?)%
\end{scheme}
%
This type describes syntax violations at the level of the read syntax.
\end{entry}

\begin{entry}{%
\ctproto{syntax}
\proto{syntax-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&syntax \&violation
  syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))%
\end{scheme}

This type describes syntax violations.
The {\cf form} field contains the erroneous syntax object or a
datum representing the code of the erroneous form.  The {\cf
  subform} field may contain an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be \schfalse{} to indicate the absence of more precise
information.
\end{entry}

\begin{entry}{%
\ctproto{undefined}
\proto{undefined-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&undefined \&violation
  undefined-violation?)%
\end{scheme}
% 
This type describes unbound identifiers in the program.
\end{entry}

\begin{entry}{%
\ctproto{assertion}
\proto{assertion-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&assertion \&violation
  assertion-violation?)%
\end{scheme}
% 
This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
\end{entry}

\begin{entry}{%
\ctproto{irritants}
\proto{irritants-condition?}{ obj}{procedure}
\proto{condition-irritants}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&irritants \&condition
  irritants-condition?
  (irritants condition-irritants))%
\end{scheme}
%
The {\cf irritants} field should contain a list of objects.  This
condition provides additional information about a condition, typically
the argument list of a procedure that detected an exception.
Conditions of this type are created by the {\cf error} and {\cf
  assertion-violation} procedures of report
section~\extref{report:errorviolation}{Errors and violations}.
\end{entry}
 
\begin{entry}{%
\ctproto{who}
\proto{who-condition?}{ obj}{procedure}
\proto{condition-who}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&who \&condition
  who-condition?
  (who condition-who))%
\end{scheme}
%
The {\cf who} field should contain a symbol or string identifying the
entity reporting the exception.
Conditions of this type are created by the {\cf error} and {\cf
  assertion-violation} procedures (report
section~\extref{report:errorviolation}{Errors and violations}), and
the {\cf syntax-violation} procedure
(section~\extref{syntax-violation}{Syntax violations}).
\end{entry}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 

