\chapter{Exceptions and conditions}
\label{exceptionsconditionschapter}

Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

The exception system allows the program, when it detects an
exceptional situation, to pass control to an exception handler, and
for dynamically establishing such exception handlers.  Exception
handlers are always invoked with an object describing the exceptional
situation.  Scheme's condition system provides a standardized taxonomy
of such descriptive objects, as well as a facility for extending the
taxonomy.

\section{Exceptions}
\label{exceptionssection}
\mainindex{exceptions}

This section describes Scheme's exception-handling and
exception-raising constructs provided by the \deflibrary{r6rs
  exceptions} library.

\begin{note}
  This specification follows SRFI~34~\cite{srfi34}.
\end{note}

Exception handlers are one-argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

\mainindex{current exception handler}The program raises an exception
by invoking the current exception handler, passing to it an object
encapsulating information about the exception. Any procedure accepting
one argument may serve as an exception handler and any object may be
used to represent an exception.

The system maintains the current exception handler as part of the
\defining{dynamic environment} of the program, the context for {\tt
  dynamic-wind}. The dynamic environment can be thought of as that
part of a continuation that does not specify the destination of any
returned values. It includes the {\tt dynamic-wind} context and the
current exception handler.

When a safe script begins its execution, the current
exception handler is expected to handle all {\cf\&serious}
conditions by interrupting execution, reporting that an
exception has been raised, and displaying information
about the condition object that was provided.  The handler
may then exit, or may provide a choice of other options.
Moreover, the exception handler is expected to return when
passed any other non-{\cf\&serious} condition.
Interpretation of these expectations necessarily depends
upon the nature of the system in which scripts are executed,
but the intent is that users perceive the raising of an
exception as a controlled escape from the situation that
raised the exception, not as a crash.

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{\var{Handler} must be a
procedure that accepts one argument.}  The {\cf
with-exception-handler} procedure returns the result(s) of invoking
\var{thunk}.  \var{Handler} is installed as the current
exception handler for the dynamic extent (as determined by {\tt
  dynamic-wind}) of the invocation of \var{thunk}.
\end{entry}

\begin{entry}{%
\pproto{(guard (\hyper{variable} \hyperi{clause} \hyperii{clause} \dotsfoo)  \hyper{body})}{\exprtype}}
\mainschindex{guard}

\syntax
Each \hyper{clause} must have the same form as a {\tt cond} clause.
(Section~\ref{cond}.)

\semantics 
Evaluating a {\tt guard} form evaluates \hyper{body} with an exception
handler that binds the raised object to \hyper{variable} and within the scope of
that binding evaluates the clauses as if they were the clauses of a
{\tt cond} expression. That implicit {\tt cond} expression is evaluated with the
continuation and dynamic environment of the {\tt guard} expression. If every
\hyper{clause}'s \hyper{test} evaluates to false and there is no else clause, then
{\cf raise} is re-invoked on the raised object within the dynamic
environment of the original call to raise except that the current
exception handler is that of the {\tt guard} expression.  
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

Raises a non-continuable exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation whose
dynamic environment is that of the call to {\tt raise}, except that
the current exception handler is the one that was in place for the
call to {\tt with-exception-handler} that installed the handler being
called.  The continuation of the handler raises a non-continuable
exception with condition type {\tt \&non-continuable}.
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

Raises a continuable exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation that
is equivalent to the continuation of the call to {\tt
  raise-continuable} with these two exceptions: (1) the current
exception handler is the one that was in place for the call to {\tt
  with-exception-handler} that installed the handler being called, and
(2) if the handler being called returns, then it will again become the
current exception handler.  If the handler returns, the values it
returns become the values returned by the call to
{\tt raise-continuable}.
\end{entry}

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
   (with-exception-handler
     (lambda (x)
       (display "condition: ")
       (write x)
       (newline)
       (k 'exception))
     (lambda ()
       (+ 1 (raise 'an-error))))))
   {\it prints:} condition: an-error
   \ev exception%
 \end{scheme}

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
   (with-exception-handler
     (lambda (x)
       (display "something went wrong")
       (newline)
       'dont-care)
     (lambda ()
       (+ 1 (raise 'an-error))))))
   {\it prints:} something went wrong
   {\it and then interrupts the program, reporting a}
   {\it{\tt \&non-continuable} exception}%
\end{scheme}

\begin{scheme}
(guard (condition
         (else
          (display "condition: ")
          (write condition)
          (newline)
          'exception))
  (+ 1 (raise 'an-error)))
    {\it prints:} condition: an-error
    \ev exception%
\end{scheme}

\begin{scheme}
(guard (condition
         (else
          (display "something went wrong")
          (newline)
          'dont-care))
 (+ 1 (raise 'an-error)))
    {\it prints:} something went wrong
    \ev dont-care%
\end{scheme}

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
   (with-exception-handler
     (lambda (x)
       (display "reraised ") (write x) (newline)
       (k 'zero))
     (lambda ()
       (guard (condition
                ((positive? condition) 'positive)
                ((negative? condition) 'negative))
        (raise 1))))))
    \ev positive%
\end{scheme}

\begin{scheme} 
(call-with-current-continuation
 (lambda (k)
   (with-exception-handler
     (lambda (x)
       (display "reraised ") (write x) (newline)
       (k 'zero))
     (lambda ()
       (guard (condition
                ((positive? condition) 'positive)
                ((negative? condition) 'negative))
        (raise -1))))))
    \ev negative%
\end{scheme}

\begin{scheme}  
(call-with-current-continuation
 (lambda (k)
   (with-exception-handler
     (lambda (x)
       (display "reraised ") (write x) (newline)
       (k 'zero))
     (lambda ()
       (guard (condition
                ((positive? condition) 'positive)
                ((negative? condition) 'negative))
        (raise 0))))))
    {\it prints:} reraised 0
    \ev zero%
\end{scheme}

\begin{scheme}  
(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'a 42))))
    \ev 42%
\end{scheme}

\begin{scheme}  
(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'b 23))))
    \ev (b . 23)%
\end{scheme}

\begin{scheme}
(with-exception-handler
  (lambda (x)
    42)
  (lambda ()
    (+ (raise-continuable \schfalse)
       23))) \ev 65
\end{scheme}

\section{Conditions}
\label{conditionssection}

The section describes Scheme \deflibrary{r6rs
  conditions} library for creating and inspecting
condition types and values. A condition value encapsulates information
about an exceptional situation\mainindex{exceptional situation}, or
\defining{exception}. Scheme also defines a
number of basic condition types.

\begin{note}
  This specification follows SRFI~35~\cite{srfi35}.  
\end{note}

Scheme conditions provides two mechanisms to enable communication
about exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound
conditions allow an exceptional situation to be described in multiple
ways.

\begin{rationale}
Conditions are values that communicate information about exceptional
situations between parts of a program. Code that detects an exception
may be in a different part of the program than the code that handles
it. In fact, the former may have been written independently from the
latter. Consequently, to facilitate effective handling of exceptions,
conditions must communicate as much information as possible as
accurately as possible, and still allow effective handling by code
that did not precisely anticipate the nature of the exception that
occurred.
\end{rationale}

\subsection{Condition objects}

Conditions are objects with named fields. Each condition belongs to
one or more condition types. Each condition type specifies a set of
field names. A condition belonging to a condition type includes a
value for each of the type's field names. These values can be
extracted from the condition by using the appropriate field name.

There is a tree of condition types with the distinguished {\tt
  \&condition} as its root. All other condition types have a parent
condition type.

A condition belonging to several condition types with a common
supertype may have distinct values for the supertype's fields for each
type. The type used to access a field determines which of the values
is returned. The program can extract each of these field values
separately.  

\begin{entry}{%
\proto{make-condition-type}{ \var{id} \var{parent} \var{field-names}}{procedure}}

Returns a new condition type. \var{Id} must
be a symbol that serves as a symbolic name for the condition type.
\var{Parent} must itself be a condition type. \var{Field-names} must
be a list of symbols. It identifies the fields of the conditions
associated with the condition type.

\var{Field-names} must be disjoint from the field names of
\var{parent} and its ancestors. 
\end{entry}

\begin{entry}{%
\proto{condition-type?}{ \var{thing}}{procedure}}

Returns \schtrue{} if \var{thing} is a condition type, and \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{make-condition}{ \var{type} \var{field-name} \var{obj} \dotsfoo}{procedure}}

Returns a condition object belonging to condition
type \var{type}. \var{Field-name} must be a field name. There must be
a pair of a \var{field-name} and an \var{obj} for each field of
\var{type} and its direct and indirect supertypes. The {\cf
  make-condition} procedure returns the condition value, with the argument
values associated with their respective fields.
\end{entry}

\begin{entry}{%
\proto{condition?}{ \var{obj}}{procedure}}

Returns \schtrue{} if \var{obj} is a condition object, and \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{condition-has-type?}{ \var{condition} \var{condition-type}}{procedure}}

The {\cf condition-has-type?} procedure tests if condition condition belongs to
condition type \var{condition-type}. It returns \schtrue{} if any of
condition's types includes \var{condition-type}, either directly or as
an ancestor, and \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{condition-ref}{ \var{condition} \var{field-name}}{procedure}}

\var{Field-name} must be a symbol.
Moreover, \var{condition} must belong to a condition type which has a
field name called \var{field-name}, or one of its (direct or indirect)
supertypes must have the field.  The {\cf condition-ref} procedure returns the value
associated with \var{field-name}.
\end{entry}

\begin{entry}{%
\proto{make-compound-condition}{ \vari{condition} \varii{condition} \dotsfoo}{procedure}}

Returns a compound condition belonging
to all condition types that the \var{condition}s belong to.

The {\cf condition-ref} procedure, when applied to a compound condition, returns
the value from the first of the \var{condition}s that has such a field.
\end{entry}

\begin{entry}{%
\proto{extract-condition}{ \var{condition} \var{condition-type}}{procedure}}

\var{Condition} must be a condition belonging to \var{condition-type}.
The {\cf extract-condition} procedure returns a condition of condition type
\var{condition-type} with the field values specified by
\var{condition}.

If \var{condition} is a compound condition, {\cf extract-condition}
extracts the field values from the subcondition belonging to
\var{condition-type} that appeared first in the call to {\cf
  make-compound-condition} that created the condition. The
returned condition may be newly created; it is possible for

\begin{scheme}
(let* ((\&c (make-condition-type
              'c \&condition '()))
       (c0 (make-condition \&c))
       (c1 (make-compound-condition c0)))
  (eq? c0 (extract-condition c1 \&c)))%
\end{scheme}
%
to return \schfalse. 
\end{entry}

\begin{entry}{%
\pproto{(define-condition-type \hyper{condition-type}  \hyper{supertype}}{\exprtype}}
{\tt\obeyspaces\\
  \hyper{predicate}\\
  \hyperi{field-spec} \dotsfoo)}
\mainschindex{define-condition-type}
\syntax \hyper{Condition-type},
\hyper{supertypes}, and \hyper{predicate} must all be identifiers.
Each \hyper{field-spec} must be of the form
%
\begin{scheme}
(\hyper{field} \hyper{accessor})%
\end{scheme}
%
where both \hyper{field} and \hyper{accessor} must be identifiers.

\semantics
The {\cf define-condition-type} form expands into a set of
definitions:

\begin{itemize}
\item \hyper{Condition-type}, which is bound to some value describing a new condition type.
\hyper{Supertype} must be the name of a previously defined condition
type.

\item \hyper{Predicate} is bound to a
predicate that identifies conditions associated with that type, or
with any of its subtypes.

\item Each \hyper{accessor} is bound to a
procedure which extracts the value of the named field from a condition
associated with this condition type.  
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{condition}{ \hyperi{type-field-binding} \dotsfoo}{\exprtype}}

Returns a condition value. Each \hyper{type-field-binding} must be of
the form
%
\begin{scheme}
(\hyper{condition-type} \hyperi{field-binding} \dotsfoo)%
\end{scheme}
%
Each \hyper{field-binding}
must be of the form
%
\begin{scheme}
(\hyper{field} \hyper{expression})  %
\end{scheme}
%
where \hyper{field} is a field identifier from the definition of
\hyper{condition-type}.

The \hyper{expression}s are evaluated in some unspecified order; their values
can later be extracted from the condition object via the accessors of
the associated condition types or their supertypes.

The condition returned by condition is created by a call of the form
%
\begin{schemenoindent}
(make-compound-condition
  (make-condition \hyper{condition-type} '\hyper{field-name} \hyper{value} \dotsfoo)
  \dotsfoo)%
\end{schemenoindent}
%
with the condition types retaining their order from the {\cf
  condition} form.  The field names and values are duplicated as
necessary as described below.

Each \hyper{type-field-binding} must contain field bindings for all
fields of \hyper{condition-type} without duplicates. There is an exception
to this rule: if a field binding is missing, and the field belongs to
a supertype shared with one of the other \hyper{type-field-binding}
subforms, then the value defaults to that of the first such binding in
the condition form.  
\end{entry}

\begin{entry}{%
\ctproto{condition}}

This is the root of the entire condition type hierarchy. It has no
fields.
\end{entry}

\begin{scheme}
(define-condition-type \&c \&condition
  c?
  (x c-x))

(define-condition-type \&c1 \&c
  c1?
  (a c1-a))

(define-condition-type \&c2 \&c
  c2?
  (b c2-b))%
\end{scheme}

\begin{scheme}
(define v1 (make-condition \&c1 'x "V1" 'a "a1"))

(c? v1)        \ev \schtrue
(c1? v1)       \ev \schtrue
(c2? v1)       \ev \schfalse
(c-x v1)       \ev "V1"
(c1-a v1)      \ev "a1"%
\end{scheme}

\begin{scheme}
(define v2 (condition (\&c2
                        (x "V2")
                        (b "b2"))))

(c? v2)        \ev \schtrue
(c1? v2)       \ev \schfalse
(c2? v2)       \ev \schtrue
(c-x v2)       \ev "V2"
(c2-b v2)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v3 (condition (\&c1
                       (x "V3/1")
                       (a "a3"))
                      (\&c2
                       (b "b3"))))

(c? v3)        \ev \schtrue
(c1? v3)       \ev \schtrue
(c2? v3)       \ev \schtrue
(c-x v3)       \ev "V3/1"
(c1-a v3)      \ev "a3"
(c2-b v3)      \ev "b3"%
\end{scheme}

\begin{scheme}
(define v4 (make-compound-condition v1 v2))

(c? v4)        \ev \schtrue
(c1? v4)       \ev \schtrue
(c2? v4)       \ev \schtrue
(c-x v4)       \ev "V1"
(c1-a v4)      \ev "a1"
(c2-b v4)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v5 (make-compound-condition v2 v3))

(c? v5)        \ev \schtrue
(c1? v5)       \ev \schtrue
(c2? v5)       \ev \schtrue
(c-x v5)       \ev "V2"
(c1-a v5)      \ev "a3"
(c2-b v5)      \ev "b2"%
\end{scheme}

\section{Standard condition types}

\begin{entry}{%
\ctproto{message}
\proto{message-condition?}{ obj}{procedure}
\proto{condition-message}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&message \&condition
  message-condition?
  (message condition-message))%
\end{scheme}
%
It carries a message further describing the nature of the condition to
humans.  
\end{entry}

\begin{entry}{%
\ctproto{warning}
\proto{warning?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&warning \&condition
  warning?)%
\end{scheme}
%
This type describes conditions that can safely be ignored.
\end{entry}

\begin{entry}{%
\ctproto{serious}
\proto{serious-condition?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&serious \&condition
  serious-condition?)%
\end{scheme}

This type describes conditions serious enough that they cannot safely
be ignored. This condition type is primarily intended as a supertype
of other condition types. 
\end{entry}

\begin{entry}{%
\ctproto{error}
\proto{error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&error \&serious
  error?)%
\end{scheme}
%
This type describes errors, typically caused by something that
has gone wrong in the interaction of the program with the external
world or the user.
\end{entry}

\begin{entry}{%
\ctproto{violation}
\proto{violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&violation \&serious
  violation?)%
\end{scheme}
%
This type describes violations of the language standard or a
library standard, typically caused by a programming error.
\end{entry}  

\begin{entry}{%
\ctproto{non-continuable}
\proto{non-continuable?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&non-continuable \&violation
  non-continuable?)%
\end{scheme}
%
This type denotes that an exception handler invoked via
\texttt{raise} has returned.
\end{entry}

\begin{entry}{%
\ctproto{implementation-restriction}
\proto{implementation-restriction?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&implementation-restriction
    \&violation
  implementation-restriction?)%
\end{scheme}
%
This type describes a violation of an implementation restriction
allowed by the specification, such as the absence of representations
for NaNs and infinities.  (See section~\ref{flonumssection}.)
\end{entry}

\begin{entry}{%
\ctproto{defect}
\proto{defect?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&defect \&violation
  defect?)%
\end{scheme}
%
This type describes defects in the program.
\end{entry}

\begin{entry}{%
\ctproto{lexical}
\proto{lexical-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&lexical \&defect
  lexical-violation?)%
\end{scheme}
%
This type describes syntax violations at the level of the read syntax.
\end{entry}

\begin{entry}{%
\ctproto{syntax}
\proto{syntax-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&syntax \&violation
  syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))%
\end{scheme}

This type describes syntax violations.
The {\cf form} field contains the erroneous syntax object or a
datum representing the code of the erroneous form.  The {\cf
  subform} field may contain an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be \schfalse{} to indicate the absence of more precise
information.
\end{entry}

\begin{entry}{%
\ctproto{undefined}
\proto{undefined-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&undefined \&defect
  undefined-violation?)%
\end{scheme}
% 
This type describes unbound identifiers in the program.
\end{entry}

\begin{entry}{%
\ctproto{contract}
\proto{contract-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&contract \&defect
  contract-violation?)%
\end{scheme}
% 
This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
\end{entry}

\begin{entry}{%
\ctproto{irritants}
\proto{irritants-condition?}{ obj}{procedure}
\proto{condition-irritants}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&irritants \&condition
  irritants-condition?
  (irritants condition-irritants))%
\end{scheme}
%
The {\cf irritants} field should contain a list of objects.  This
condition provides additional information about a condition, typically
the argument list of a procedure that detected an exception.
Conditions of this type are created by the {\cf error} and {\cf
  contract-violation} procedures of section~\ref{errorviolation}.
\end{entry}
 
\begin{entry}{%
\ctproto{who}
\proto{who-condition?}{ obj}{procedure}
\proto{condition-who}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&who \&condition
  who-condition?
  (who condition-who))%
\end{scheme}
%
The {\cf who} field should contain a symbol or string identifying the
entity reporting the exception.
Conditions of this type are created by the {\cf error} and {\cf
  contract-violation} procedures (section~\ref{errorviolation}), and
the {\cf syntax-violation} procedure (section~\ref{syntax-violation}).
\end{entry}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

