% Lexical structure

%%\vfill\eject
\chapter{Lexical syntax and read syntax}
\label{readsyntaxchapter}

The syntax of Scheme programs is organized in three levels:
%
\begin{enumerate}
\item the \textit{lexical syntax} that describes how a program text is split
  into a sequence of lexemes,
\item the \textit{read syntax}, formulated in terms of the lexical
  syntax, that structures the lexeme sequence as a sequence of
  \textit{syntactic datums\mainindex{datum}\mainindex{syntactic
      datum}}, where a syntactic datum is
    a recursively structured entity,
\item the \textit{program syntax} formulated in terms of the read
  syntax, imposing further structure and assigning meaning to
  syntactic datums.
\end{enumerate}
%
Syntactic datums (also called \textit{external
  representations\index{external representation}}) double
as a notation for data, and Scheme's \library{r6rs i/o ports} library provides procedures
for reading and writing syntactic datums, converting between their
textual representation and the corresponding values. 
A
syntactic datum can be used in a program to obtain the corresponding
value using {\cf quote} (see section~\ref{quote}).

Moreover, valid Scheme expressions form a subset of the syntactic datums.
Consequently, Scheme's syntax has the property that any sequence of
characters that is an expression is also a syntactic datum representing
some object.  This can lead to confusion, since it may not be obvious
out of context whether a given sequence of characters is intended to
denote data or program. It is also a source of power, since it
facilitates writing programs such as interpreters and compilers that
treat programs as data (or vice versa).
A syntactic datum occurring in program text is often called a \defining{form}.

Note that several syntactic datums may represent the same object, a
so-called \defining{datum value}.
For example, both``{\tt \#e28.000}'' and
``{\tt\#x1c}'' are syntactic datums representing the exact integer 28;
The syntactic datums ``{\tt(8 13)}'', ``{\tt( 08 13 )}'', ``{\tt(8 .\
  (13 .\ ()))}'' (and more)
all represent a list containing the integers 8 and 13. 
Syntactic datums that denote equal objects are always equivalent 
as forms of a program.

Because of the close correspondence between syntactic datums and datum
values, this report sometimes uses the term \defining{datum} to denote
either a syntactic datum or a datum value when it is apparent from the
context.

This chapter gives overviews and formal accounts of the lexical
syntax and the read syntax.

\section{Notation}
\label{BNF}

The formal syntax for Scheme is written in an extended BNF.

All spaces in the grammar are for legibility.  Case is significant
except in hexadecimal numbers; for example, {\cf \#x1A} and {\cf
  \#X1a} are equivalent.  \meta{empty} stands for the empty string.

The following extensions to BNF are used to make the description more
concise:  \arbno{\meta{thing}} means zero or more occurrences of
\meta{thing}; and \atleastone{\meta{thing}} means at least one
\meta{thing}.

\section{Lexical syntax}
\label{lexicalsyntaxsection}

The lexical syntax describes how a character sequence is split into a
sequence of lexemes\index{lexeme}, omitting non-significant portions
such as comments and whitespace.  The character sequence is assumed to
be text according to the Unicode standard~\cite{Unicode}.  Some of
the lexemes, such as numbers, identifiers, strings etc.\ of the lexical
syntax are syntactic datums in the read syntax, and thus represent data.
Besides the formal account of the syntax, this section also describes
what data objects are denoted by these syntactic datums.

Note that the lexical syntax, in the description of comments, contains
a forward reference to \meta{datum}, which is described as part of the
read syntax.  However, being comments, these \meta{datum}s do not play
a significant role in the syntax.

Generally, upper and lower case forms of a letter are distinguished,
except in literals specifying hexadecimal numbers.  For example, {\cf
  Foo} is an identifier different from {\cf FOO}.  However,
{\tt\#x1AB} is the same number as {\tt\#X1ab}.

\subsection{Formal account}
\label{lexicalgrammarsection}

\meta{Interlexeme space} may occur on either side of any lexeme, but not
within a lexeme.

\vest Lexemes that require implicit termination (identifiers, numbers,
and dot) may be terminated by any \meta{delimiter}, but not
necessarily by anything else.  \meta{Character} and \meta{boolean}
shall be terminated by a \meta{delimiter} or by the end of the input.

The following two characters are reserved for future extensions to the
language: {\tt \verb"{" \verb"}"}

\begin{grammar}%
\meta{lexeme} \: \meta{identifier} \| \meta{boolean} \| \meta{number}\index{identifier}
\>  \| \meta{character} \| \meta{string}
\>  \| ( \| ) \| \openbracket{} \| \closedbracket{} \| \sharpsign( \| \singlequote{} \| \backquote{} \| , \| ,@ \| {\bf.}
\meta{delimiter} \: \meta{whitespace} \| ( \| ) \| \openbracket{} \| \closedbracket{} " \| ;
\meta{whitespace} \: \meta{horizontal tab} \| \meta{linefeed}
\> \| \meta{vertical tab} \| \meta{form feed} \meta{carriage return}
\> \| \meta{any character whose category is Zs, Zl, or Zp}
\meta{intra-line whitespace} \: $\langle${\rm any \meta{whitespace}}
\> \quad {\rm that is not \meta{linefeed}}
\meta{comment} \: ; \= $\langle$\rm all subsequent characters up to a
                    \>\ \rm linefeed$\rangle$\index{comment}
\qquad \= \| \meta{nested comment}
\> \| \#; \meta{datum}
\> \| \#!r6rs \| \#!/usr/bin/env
\meta{nested comment} \: \#| \= \meta{comment text}
\> \arbno{\meta{comment cont}} |\#
\meta{comment text} \: \= $\langle$\rm character sequence not containing
\>\ \rm {\tt \#|} or {\tt |\#}$\rangle$
\meta{comment cont} \: \meta{nested comment} \meta{comment text}
\meta{atmosphere} \: \meta{whitespace} \| \meta{comment}
\meta{interlexeme space} \: \arbno{\meta{atmosphere}}%
\end{grammar}

\label{extendedalphas}
\label{identifiersyntax}

% This is a kludge, but \multicolumn doesn't work in tabbing environments.
\setbox0\hbox{\cf\meta{variable} \goesto{} $\langle$}

\begin{grammar}%
\meta{identifier} \: \meta{initial} \arbno{\meta{subsequent}}
 \>  \| \meta{peculiar identifier}
\meta{initial} \: \meta{constituent} \| \meta{special initial}
 \> \| \meta{symbol escape}
\meta{letter} \:  a \| b \| c \| ... \| z
\> \| A \| B \| C \| ... \| Z
\meta{constituent} \: \meta{letter}
 \> \| $\langle${\rm any character whose scalar value is greater than}
 \> \quad {\rm 127, and whose category is Lu, Lt, Lm, Lo, Mn, Mc,}
 \> \quad {\rm Me, Nd, Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}$\rangle$

\meta{special initial} \: ! \| \$ \| \% \| \verb"&" \| * \| / \| : \| < \| =
 \>  \| > \| ? \| \verb"^" \| \verb"_" \| \verb"~"
\meta{subsequent} \: \meta{initial} \| \meta{digit}
 \>  \| \meta{special subsequent}
 \> \| \meta{symbol escape}
\meta{digit} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9
\meta{hex digit} \: \meta{digit}
 \> \| a \| A \| b \| B \| c \| C \| d \| D \| e \| E \| f \| F
\meta{special subsequent} \: + \| - \| .\ \| @
\meta{symbol escape} \: \backwhack{}x\meta{hex scalar value};
\meta{hex scalar value} \: \atleastone{\meta{hex digit}}
 \> {\rm with at most 8 digits}
 \meta{peculiar identifier} \: + \| - \| ... \| -> \arbno{\meta{subsequent}}
%\| 1+ \| -1+
\meta{boolean} \: \schtrue{} \| \schfalse{}
\meta{character} \: \#\backwhack{}\meta{any character}
 \>  \| \#\backwhack{}\meta{character name}
 \>  \| \#\backwhack{}x\meta{hex scalar value}
\meta{character name} \: nul \| alarm \| backspace \| tab
\> \| linefeed \| vtab \| page \| return \| esc
\> \| space \| delete
\todo{Explain what happens in the ambiguous case.}
\meta{string} \: " \arbno{\meta{string element}} "
\meta{string element} \: \meta{any character other than \doublequote{} or \backwhack}
 \> \| \backwhack{}a \| \backwhack{}b \| \backwhack{}t \| \backwhack{}n \| \backwhack{}v \| \backwhack{}f \| \backwhack{}r
 \>  \| \backwhack\doublequote{} \| \backwhack\backwhack 
 \>  \| \meta{linefeed} \meta{intra-line whitespace}
\end{grammar}


\label{numbersyntax}

\begin{grammar}%
\meta{number} \: \meta{num $2$}%
       \| \meta{num $8$}
   \>  \| \meta{num $10$}%
       \| \meta{num $16$}
\end{grammar}

The following rules for \meta{num $R$}, \meta{complex $R$}, \meta{real
$R$}, \meta{ureal $R$}, \meta{uinteger $R$}, and \meta{prefix $R$}
should be replicated for \hbox{$R = 2, 8, 10,$}
and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
$8$}, and \meta{decimal $16$}, which means that numbers containing
decimal points or exponents shall be in decimal radix.
\todo{Mark Meyer and David Bartley want to fix this.  (What? -- Will)}

In the these rules, case is insignificant.

\begin{grammar}%
\meta{num $R$} \: \meta{prefix $R$} \meta{complex $R$}
\meta{complex $R$} \: %
         \meta{real $R$} %
      \| \meta{real $R$} @ \meta{real $R$}
   \> \| \meta{real $R$} + \meta{ureal $R$} i %
      \| \meta{real $R$} - \meta{ureal $R$} i
   \> \| \meta{real $R$} + i %
      \| \meta{real $R$} - i
   \> \| + \meta{ureal $R$} i %
      \| - \meta{ureal $R$} i %
      \| + i %
      \| - i
\meta{real $R$} \: \meta{sign} \meta{ureal $R$}
\meta{ureal $R$} \: %
         \meta{uinteger $R$}
   \> \| \meta{uinteger $R$} / \meta{uinteger $R$}
   \> \| \meta{decimal $R$} \meta{mantissa width}
   \> \| inf.0 \| nan.0
\meta{decimal $10$} \: %
         \meta{uinteger $10$} \meta{suffix}
   \> \| . \atleastone{\meta{digit $10$}} \arbno{\#} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \arbno{\meta{digit $10$}} \arbno{\#} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} \atleastone{\#} . \arbno{\#} \meta{suffix}
\meta{uinteger $R$} \: \atleastone{\meta{digit $R$}} \arbno{\#}
\meta{prefix $R$} \: %
         \meta{radix $R$} \meta{exactness}
   \> \| \meta{exactness} \meta{radix $R$}
\end{grammar}

\begin{grammar}%
\meta{suffix} \: \meta{empty} 
   \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
\meta{exponent marker} \: e \| s \| f \| d \| l
\meta{mantissa width} \: \meta{empty}
   \> \| | \atleastone{\meta{digit 10}}
\meta{sign} \: \meta{empty}  \| + \|  -
\meta{exactness} \: \meta{empty} \| \#i\sharpindex{i} \| \#e\sharpindex{e}
\meta{radix 2} \: \#b\sharpindex{b}
\meta{radix 8} \: \#o\sharpindex{o}
\meta{radix 10} \: \meta{empty} \| \#d
\meta{radix 16} \: \#x\sharpindex{x}
\meta{digit 2} \: 0 \| 1
\meta{digit 8} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7
\meta{digit 10} \: \meta{digit}
\meta{digit 16} \: \meta{hex digit}
\end{grammar}

\todo{Mark Meyer of TI sez, shouldn't we allow {\tt 1e3/2}?}

\subsection{Whitespace and comments}

\defining{Whitespace} characters are spaces, linefeeds,
carriage returns, horizontal tabs, form feeds, vertical tabs,
and any other character whose category is Zs, Zl, or Zp.
Whitespace is used for improved readability and
as necessary to separate lexemes from each other.  Whitespace may
occur between any two lexemes,
but not within a lexeme.  Whitespace may also occur inside a string,
where it is significant.

The lexical syntax includes several comment forms. In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so a comment cannot appear in the middle of an identifier or number.

A semicolon ({\tt;}) indicates the start of a line
comment.\mainindex{comment}\mainschindex{;} The comment continues to
the end of the line on which the semicolon appears (i.e., it is
terminated by a linefeed character).

Another way to indicate a comment is to prefix a \hyper{datum}
(cf.\ Section~\ref{datumsyntax}) with {\tt \#;}, possibly with
whitespace before the \hyper{datum}.  The comment consists of
the comment prefix {\tt \#;} and the \hyper{datum} together.  (This
notation is useful for ``commenting out'' sections of code.)

Block comments may be indicated with properly nested {\tt
  \#|} and {\tt |\#} pairs.

\begin{scheme}
\#|
   The FACT procedure computes the factorial
   of a non-negative integer.
|\#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        \#;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))%
\end{scheme}

The lexemes {\cf \sharpsign{}!r6rs} and {\cf \sharpsign{}!/usr/bin/env}
are also comments.  The {\cf \sharpsign{}!r6rs} lexeme occurring in
program text identifies that program text to be written purely in the
language described by this report (see
section~\ref{librarysyntaxsection}).  The {\cf
  \sharpsign{}!/usr/bin/env} lexeme occurs at the beginning of scripts
and enables their direct execution on Unix-like systems (see
chapter~\ref{scriptchapter}).

\subsection{Identifiers}
\label{identifiersection}

Most identifiers\mainindex{identifier} allowed by other programming
languages are also acceptable to Scheme.  In particular,
a sequence of letters, digits, and ``extended alphabetic
characters'' that begins with a character that cannot begin a number is
an identifier.  In addition, \ide{+}, \ide{-}, and \ide{...} are identifiers. 
Here are some examples of identifiers:

\begin{scheme}
lambda                   q
list->vector             soup
{+}                        V17a
<=?                      a34kTMNs
the-word-recursion-has-many-meanings%
\end{scheme}

Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

\begin{scheme}
!\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}

Moreover, all characters whose scalar values are greater than 127 and
whose Unicode category is Lu, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd,
Pc, Po, Sc, Sm, Sk, So, or Co can be used within identifiers.
Moreover, any character can appear as the constituent of an identifier
when denoted via a hexadecimal escape sequence.  For example, the
identifier \verb|H\x65;llo| is the same as the identifier
\verb|Hello|, and the identifier \verb|\x3BB;| is the same as the
identifier $\lambda$.

Any identifier may be used as a variable\index{variable} or as a
syntactic keyword\index{syntactic keyword} (see
sections~\ref{variablesection} and~\ref{macrosection}) in a Scheme
program.

Moreover, when viewed as data, an identifier denotes a {\em symbol\index{symbol}}
(see section~\ref{symbolsection}).

\subsection{Booleans}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}  The character
after a boolean literal shall be a delimiter character, such as a
space or parenthesis.

\subsection{Characters}

Characters are written using the notation
\sharpsign\backwhack\hyper{character} or
\sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}, where the last
specifies the scalar value of a character with a hexadecimal number of
no more than eight digits.

For example:

\begin{schemenoindent}
\#\backwhack{}a          \ev \textrm{lower case letter a}
\#\backwhack{}A          \ev \textrm{upper case letter A}
\#\backwhack{}(          \ev \textrm{left parenthesis}
\#\backwhack{}           \ev \textrm{space character}
\#\backwhack{}nul        \ev \textrm{U+0000}
\#\backwhack{}alarm      \ev \textrm{U+0007}
\#\backwhack{}backspace  \ev \textrm{U+0008}
\#\backwhack{}tab        \ev \textrm{U+0009}
\#\backwhack{}linefeed   \ev \textrm{U+000A}
\#\backwhack{}vtab       \ev \textrm{U+000B}
\#\backwhack{}page       \ev \textrm{U+000C}
\#\backwhack{}return     \ev \textrm{U+000D}
\#\backwhack{}esc        \ev \textrm{U+001B}
\#\backwhack{}space      \ev \textrm{U+0020}
\>\>; \textrm{preferred way to write a space}
\#\backwhack{}delete     \ev \textrm{U+007F}

\#\backwhack{}xFF        \ev \textrm{U+00FF}
\#\backwhack{}x03BB      \ev \textrm{U+03BB}
\#\backwhack{}x00006587  \ev \textrm{U+6587}
\#\backwhack{}\(\lambda\) \ev \textrm{U+03BB}

\#\backwhack{}x0001z     \ev \exception{\&lexical}
\#\backwhack{}\(\lambda\)x         \ev \exception{\&lexical}
\#\backwhack{}alarmx     \ev \exception{\&lexical}
\#\backwhack{}alarm x    \ev \textrm{U+0007}
\>\>; \textrm{followed by {\cf x}}
\#\backwhack{}Alarm      \ev \exception{\&lexical}
\#\backwhack{}alert      \ev \exception{\&lexical}
\#\backwhack{}xA         \ev \textrm{U+000A}
\#\backwhack{}xFF        \ev \textrm{U+00FF}
\#\backwhack{}xff        \ev \textrm{U+00FF}
\#\backwhack{}x ff       \ev \textrm{U+0078}
\>\>; \textrm{followed by another datum, {\cf ff}}
\#\backwhack{}x(ff)      \ev \textrm{U+0078}
\>\>; \textrm{followed by another datum,}
\>\>; \textrm{a parenthesized {\cf ff}}
\#\backwhack{}(x)        \ev \exception{\&lexical}
\#\backwhack{}(x         \ev \exception{\&lexical}
\#\backwhack{}((x)       \ev \textrm{U+0028}
\>\>; \textrm{followed by another datum,}
\>\>; \texttt{parenthesized {\cf x}}
\#\backwhack{}x00110000  \ev \exception{\&lexical}
\>\>; \textrm{out of range}
\#\backwhack{}x000000001 \ev \exception{\&lexical}
\>\>; \textrm{too many digits}  
\#\backwhack{}xD800      \ev \exception{\&lexical}
\>\>; \textrm{in excluded range}
\end{schemenoindent}

Case is significant in \sharpsign\backwhack\hyper{character}, and in in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
but not in \sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}.  
The character after a \meta{character}
shall be a delimiter character such as a
space or parenthesis.  This rule resolves various ambiguous cases, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
could be taken to be either a representation of the space character or a
representation of the character ``{\tt\sharpsign\backwhack s}'' followed
by a representation of the symbol ``{\tt pace}.''

\subsection{Strings}

\vest String are written as sequences of characters enclosed within doublequotes
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} denote characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\tt \backwhack{}a} : alarm, U+0007
\item{\tt \backwhack{}b} : backspace, U+0008 
\item{\tt \backwhack{}t} : tab, U+0009 
\item{\tt \backwhack{}n} : linefeed, U+000A 
\item{\tt \backwhack{}v} : vertical tab, U+000B 
\item{\tt \backwhack{}f} : formfeed, U+000C 
\item{\tt \backwhack{}r} : return, U+000D 
\item{\tt \backwhack{}}\verb|"| : doublequote, U+0022 
\item{\tt \backwhack{}\backwhack{}} : backslash, U+005C 
\item{\tt \backwhack{}\hyper{linefeed}\hyper{intraline whitespace}} : nothing
\item{\tt \backwhack{}\ } : space, U+0020 (useful for terminating the
  previous escape sequence before continuing with whitespace)
\item{\tt \backwhack{}x\atleastone{\hyper{digit 16}};} : (note the
  terminating semi-colon) where no more than eight \hyper{digit 16}s
  are provided, and the sequence of \hyper{digit 16}s forms a
  hexadecimal number between 0 and \sharpsign{}x10FFFF excluding the
  range $\left[\sharpsign{}x\textrm{D800},
    \sharpsign{}x\textrm{DFFF}\right]$.
\end{itemize}

These escape sequences are case-sensitive, except that \hyper{digit
  16} can be an uppercase or lowercase hexadecimal digit.

Any other character in a string after a backslash is an error. Any
character outside of an escape sequence and not a doublequote stands
for itself in the string literal. For example the single-character
string {\tt "$\lambda$"} (double quote, a lower case lambda, double
quote) denotes the same string literal as {\tt "\backwhack{}x03bb;"}.

Examples:

\begin{schemenoindent}
"abc" \ev  \textrm{U+0061, U+0062, U+0063}
"\backwhack{}x41;bc" \ev  \textrm{``Abc'', U+0041, U+0062, U+0063}
"\backwhack{}x41; bc" \ev  \textrm{``A bc''}
\>\>\textrm{U+0041, U+0020, U+0062, U+0063}
"\backwhack{}x41bc;" \ev  \textrm{U+41BC}
"\backwhack{}x41" \ev \exception{\&lexical}
"\backwhack{}x;" \ev \exception{\&lexical}
"\backwhack{}x41bx;" \ev \exception{\&lexical}
"\backwhack{}x00000041;" \ev  \textrm{``A'', U+0041}
"\backwhack{}x0010FFFF;" \ev \textrm{U+10FFFF}
"\backwhack{}x00110000;" \ev  \exception{\&lexical}
\>\>; \textrm{out of range}
"\backwhack{}x000000001;" \ev \exception{\&lexical}
\>\>; \textrm{too many digits}
"\backwhack{}xD800;" \ev \exception{\&lexical}
\>\>; \textrm{in excluded range}
\end{schemenoindent}
  
\subsection{Numbers}
\label{numbernotations}

The syntax of written representations for numbers is described
formally by the \meta{number} rule in the formal grammar.  Note that
case is not significant in numerical constants.

A number may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
no radix prefix, a number is assumed to be expressed in decimal.

A
numerical constant may be specified to be either exact or
inexact by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
for exact, and {\cf \#i}\sharpindex{i} for inexact.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the written representation of a number has no exactness prefix, the
constant may be either inexact or exact.  It is
inexact if it contains a decimal point, an
exponent, or a ``\sharpsign'' character in the place of a digit;
otherwise it is exact.

In systems with inexact numbers
of varying precisions, it may be useful to specify
the precision of a constant.  For this purpose, numerical constants
may be written with an exponent marker that indicates the
desired precision of the inexact
representation.  The letters {\cf s}, {\cf f},
{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
\var{double}, and \var{long} precision, respectively.  (When fewer
than four internal
inexact
representations exist, the four size
specifications are mapped onto those available.  For example, an
implementation with two internal representations may map short and
single together and long and double together.)  In addition, the
exponent marker {\cf e} specifies the default precision for the
implementation.  The default precision has at least as much precision
as \var{double}, but
implementations may wish to allow this default to be set by the user.

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}

If \var{x} is an external representation of an inexact real number
that contains no vertical bar,
and \var{p} is a sequence of 1 or more decimal
digits, then {\cf \var{x}|\var{p}} is an external representation that
denotes the best binary floating point approximation to \var{x} using
a \var{p}-bit significand.  For example, {\cf 1.1|53} is an external
representation for the best approximation to 1.1 in IEEE double
precision.

If \var{x} is an external representation of an inexact real number
that contains no vertical bar,
then \var{x} by itself should be regarded as
equivalent to {\cf \var{x}|53}.

Implementations that use binary floating point representations
of real numbers should represent {\cf \var{x}|\var{p}}
using a \var{p}-bit significand if practical, or by a greater
precision if a \var{p}-bit significand is not practical, or
by the largest available precision if \var{p} or more bits
of significand are not practical within the implementation.

\begin{note}
The precision of a significand should not be confused with the
number of bits used to represent the significand.  In the IEEE
floating point standards, for example, the significand's most
significant bit is implicit in single and double precision but
is explicit in extended precision.  Whether that bit is implicit
or explicit does not affect the mathematical precision.
In implementations that use binary floating point, the default
precision can be calculated by calling the following procedure:

\begin{scheme}
(define (precision)
  (do ((n 0 (+ n 1))
       (x 1.0 (/ x 2.0)))
    ((= 1.0 (+ 1.0 x)) n)))
\end{scheme}
\end{note}      

\begin{note}
When the underlying floating-point representation is IEEE double
precision, the {\cf |\var{p}} suffix should not always be omitted:
Denormalized numbers have diminished precision, and therefore should
carry a {\cf |\var{p}} suffix with the actual width of the
significand.
\end{note}

The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
negative infinity, respectively.  The {\cf +nan.0}
literal represents the NaN that is the result of {\cf (/ 0.0 0.0)},
and may represent other NaNs as well.

If a \meta{decimal 10} contains no vertical bar
and does not contain one of the exponent markers {\cf s},
{\cf f}, {\cf d}, or {\cf l}, but does contain a decimal point or the
exponent marker {\cf e}, then it is an external representation for a
flonum.  Furthermore {\cf inf.0}, {\cf +inf.0}, {\cf -inf.0}, {\cf
  nan.0}, {\cf +nan.0}, and {\cf -nan.0} are external representations
for flonums.  Some or all of the other external representations for
inexact reals may also represent flonums, but that is not required by
this report.

If a \meta{decimal 10} contains a non-empty \meta{mantissa width} or
one of the exponent markers {\cf s}, {\cf f}, {\cf d}, or {\cf l},
then it represents an inexact number, but does not necessarily
represent a flonum.

\section{Read syntax}
\label{readsyntaxsection}

The read syntax describes the syntax of
syntactic datums\mainindex{syntactic datum} in terms of a sequence of
\meta{lexeme}s, as defined in the lexical syntax.

Syntactic datums include the lexeme datums described in the
previous section as well as the following constructs for forming
compound structure:
%
\begin{itemize}
\item pairs and lists, enclosed by \verb|( )| or \verb|[ ]| (see
  section~\ref{pairlistsyntax})
\item  vectors (see section~\ref{vectorsection})
\end{itemize}

Note that the sequence of characters ``{\tt(+ 2 6)}'' is {\em not} a
syntactic datum representing the integer 8, even though it {\em is} a
base-library expression evaluating to the integer 8; rather, it is a
datum representing a three-element list, the elements of which
are the symbol {\tt +} and the integers 2 and 6.

\subsection{Formal account}
\label{datumsyntax}

The following grammar describes the syntax of syntactic datums in terms
of various kinds of lexemes defined in the grammar in
section~\ref{lexicalsyntaxsection}:

\begin{grammar}%
\meta{datum} \: \meta{simple datum}
\>  \| \meta{compound datum}
\meta{simple datum} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string} \|  \meta{symbol}
\meta{symbol} \: \meta{identifier}
\meta{compound datum} \: \meta{list} \| \meta{vector}
\meta{list} \: (\arbno{\meta{datum}})
\>    \| [\arbno{\meta{datum}}]
\>    \| (\atleastone{\meta{datum}} .\ \meta{datum})
\>    \| [\atleastone{\meta{datum}} .\ \meta{datum}]
\>    \| \meta{abbreviation}
\meta{abbreviation} \: \meta{abbrev prefix} \meta{datum}
\meta{abbrev prefix} \: ' \| ` \| , \| ,@ \| \#' | \#` | \#,
\meta{vector} \: \#(\arbno{\meta{datum}})
\meta{bytes} \: \#vu8(\arbno{\meta{u8}})
\meta{u8} \: $\langle${\rm any \meta{number} denoting an exact}
 \>\>\quad\quad {\rm integer in $\{0, \ldots, 255\}$}$\rangle$%
\end{grammar}

\subsection{Vectors}
\label{vectorsyntax}

Vector datums, denoting vectors of values (see
section~\ref{vectorsection}, are written using the notation
{\tt\#(\hyper{datum} \dotsfoo)}.  For example, a vector of length 3
containing the number zero in element 0, the list {\cf(2 2 2 2)} in
element 1, and the string {\cf "Anna"} in element 2 can be written as
following:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

Note that this is the external representation of a vector,
and is not a
base-library expression that evaluates to a vector.

\subsection{Pairs and lists}
\label{pairlistsyntax}

List and pair datums, denoting pairs and lists of values
(see section~\ref{listsection}) are written using parentheses or brackets.
Matching pairs of parentheses that occur in the rules of \meta{list} are
equivalent to matching pairs of brackets.

The most general notation for Scheme pairs as syntactic datums is
the ``dotted'' notation \hbox{\cf (\hyperi{datum} .\ \hyperii{datum})} where
\hyperi{datum} is representation of the value of the car field and
\hyperii{datum} is the representation of the value of the
cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
cdr is 5.  Note that {\cf (4 .\ 5)} is the external representation of a
pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list\index{empty list} is written {\tt()} .  For example,

\begin{scheme}
(a b c d e)%
\end{scheme}

and

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

are equivalent notations for a list of symbols.

\subsection{Bytes objects}

Bytes datums, denoting bytes objects (see
section~\ref{bytessection}), are written using the notation
{\tt\#vu8(\hyper{u8} \dotsfoo)}, where the \hyper{u8}s repersent the octets of
the bytes object.  For example, a bytes object of length 3 containing the
octets 2, 24, and 123 can be written as following:

\begin{scheme}
\#vu8(2 24 123)%
\end{scheme}

Note that this is the external representation of a bytes object,
and is not a
base-library expression that evaluates to a bytes object.

\subsection{Abbreviations}\unsection
\label{quotesection}

\begin{entry}{%
\pproto{\singlequote\hyper{datum}}{}
\pproto{\backquote\hyper{datum}}{}
\pproto{,\hyper{datum}}{}
\pproto{,\atsign\hyper{datum}}{}
\pproto{\#'\hyper{datum}}{}
\pproto{\#\backquote\hyper{datum}}{}
\pproto{\#,\hyper{datum}}{}
}

\mainschindex{'}\singlequote\hyper{datum} is an abbreviation
for {\cf (quote \hyper{datum})}.
\mainschindex{`}\backquote\hyper{datum} is an abbreviation
for {\cf (quasiquote \hyper{datum})}.
\mainschindex{,}{\cf,}\hyper{datum} is an abbreviation
for {\cf (unquote \hyper{datum})}.
\mainschindex{,@}{\cf,}\atsign\hyper{datum} is an abbreviation
for {\cf (unquote-splicing \hyper{datum})}.
\sharpindex{'}{\cf\#'}\hyper{datum} is an abbreviation
for {\cf (syntax \hyper{datum})}.
\sharpindex{`}{\cf\#`}\hyper{datum} is an abbreviation
for {\cf (quasisyntax \hyper{datum})}.
\sharpindex{,}{\cf\#,}\hyper{datum} is an abbreviation
for {\cf (unsyntax \hyper{datum})}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
