% Lexical structure

%%\vfill\eject
\chapter{Lexical syntax and read syntax}
\label{readsyntaxchapter}

The syntax of Scheme programs is organized in three levels:
%
\begin{enumerate}
\item the \textit{lexical syntax} that describes how a program text is split
  into a sequence of lexemes,
\item the \textit{read syntax}, formulated in terms of the lexical
  syntax, that structures the lexeme sequence as a sequence of
  \textit{S-expressions\index{S-expression}}, where an S-expression is
    a recursively structured entity,
\item the \textit{program syntax} formulated in terms of the read
  syntax, imposing further structure and assigning meaning to
  S-expressions.
\end{enumerate}
%
S-expressions (also called \textit{external
  representations\index{external representation}}) double
as a notation for data, and Scheme's FIXME library provides procedures
for reading and writing S-expressions, converting between their
textual representation and the corresponding objects.  Also, an
S-expression can be used in a program to obtain the corresponding
object using a {\cf quote} form (see section~\ref{quote}).

Moreover, valid Scheme expressions form a subset of the S-expressions.
Consequently, Scheme's syntax has the property that any sequence of
characters that is an expression is also an S-expression representing
some object.  This can lead to confusion, since it may not be obvious
out of context whether a given sequence of characters is intended to
denote data or program, but it is also a source of power, since it
facilitates writing programs such as interpreters and compilers that
treat programs as data (or vice versa).

Note that an object that corresponds to an S-expression (a so-called
\defining{datum}) may also correspond to other S-expressions.  The
integer 28 also has representations ``{\tt \#e28.000}'' and
``{\tt\#x1c}'', and the list in the previous paragraph also has the
representations ``{\tt( 08 13 )}'' and ``{\tt(8 .\ (13 .\ ()))}'' (see
section~\ref{listsection}).  S-expressions that denote equal
objects are also equivalent as forms of a program.

This chapter gives overviews and formal accounts of the lexical
syntax and the read syntax.

\section{Notation}
\label{BNF}

The formal syntax for Scheme is written in an extended BNF.

All spaces in the grammar are for legibility.  Case is significant
except in hexadecimal numbers; for example, {\cf \#x1A} and {\cf
  \#X1a} are equivalent.  \meta{empty} stands for the empty string.

The following extensions to BNF are used to make the description more
concise:  \arbno{\meta{thing}} means zero or more occurrences of
\meta{thing}; and \atleastone{\meta{thing}} means at least one
\meta{thing}.

\section{Lexical syntax}
\label{lexicalsyntaxsection}

The lexical syntax describes how a character sequence is split into a
sequence of lexemes\index{lexeme}, omitting non-significant portions
such as comments and whitespace.  The character sequence is assumed to
be text according to the Unicode standard~\cite{Unicode41}.  Some of
the lexemes, such as numbers, identifiers, strings etc. of the lexical
syntax are S-expressions in the read syntax, and thus represent data.
Besides the formal account of the syntax, this section also describes
what data objects are denoted by these S-expressions.

Note that the lexical syntax, in the description of comments, contains
a forward reference to \meta{S-expression}, which is described as part of the
read syntax.  However, being comments, these \meta{S-expression}s do not play
a significant role in the syntax.

Generally, upper and lower case forms of a letter are distinguished,
except in literals specifying hexadecimal numbers.  For example, {\cf
  Foo} is an identifier different from {\cf FOO}.  However,
{\tt\#x1AB} is the same number as {\tt\#X1ab}.

\subsection{Formal account}
\label{lexicalgrammarsection}

\meta{Interlexeme space} may occur on either side of any lexeme, but not
within a lexeme.

\vest Lexemes which require implicit termination (identifiers, numbers,
and dot) may be terminated by any \meta{delimiter}, but not
necessarily by anything else.  \meta{Character} and \meta{boolean}
must be terminated by a \meta{delimiter} or by the end of the input.

The following three characters are reserved for future extensions to the
language: {\tt \verb"{" \verb"}"}

\begin{grammar}%
\meta{lexeme} \: \meta{identifier} \| \meta{boolean} \| \meta{number}\index{identifier}
\>  \| \meta{character} \| \meta{string}
\>  \| ( \| ) \| \openbracket{} \| \closedbracket{} \| \sharpsign( \| \singlequote{} \| \backquote{} \| , \| ,@ \| {\bf.}
\meta{delimiter} \: \meta{whitespace} \| ( \| ) \| \openbracket{} \| \closedbracket{} " \| ;
\meta{whitespace} \: \meta{horizontal tab} \| \meta{linefeed}
\> \| \meta{vertical tab} \| \meta{form feed} \meta{carriage return}
\> \| \meta{any character whose category is Zs, Zl, or Zp}
\meta{intra-line whitespace} \: $\langle${\rm any \meta{whitespace}}
\> \quad {\rm that is not \meta{linefeed}}
\meta{comment} \: ; \= $\langle$\rm all subsequent characters up to a
		    \>\ \rm linefeed$\rangle$\index{comment}
\qquad \= \| \meta{nested comment}
\> \| \#; \meta{S-expression}
\> \| \#!r6rs \| \#!/usr/bin/env
\meta{nested comment} \: \#| \= \meta{comment text}
\> \arbno{\meta{comment cont}} |\#
\meta{comment text} \: \= $\langle$\rm character sequence not containing
\>\ \rm {\tt \#|} or {\tt |\#}$\rangle$
\meta{comment cont} \: \meta{nested comment} \meta{comment text}
\meta{atmosphere} \: \meta{whitespace} \| \meta{comment}
\meta{interlexeme space} \: \arbno{\meta{atmosphere}}%
\end{grammar}

\label{extendedalphas}
\label{identifiersyntax}

% This is a kludge, but \multicolumn doesn't work in tabbing environments.
\setbox0\hbox{\cf\meta{variable} \goesto{} $\langle$}

\begin{grammar}%
\meta{identifier} \: \meta{initial} \arbno{\meta{subsequent}}
 \>  \| \meta{peculiar identifier}
\meta{initial} \: \meta{constituent} \| \meta{special initial}
 \> \| \meta{symbol escape}
\meta{letter} \:  a \| b \| c \| ... \| z
\> \| A \| B \| C \| ... \| Z
\meta{constituent} \: \meta{letter}
 \> \| $\langle${\rm any character whose scalar value is greater than}
 \> \quad {\rm 127, and whose category is Lu, Lt, Lm, Lo, Mn, Mc,}
 \> \quad {\rm Me, Nd, Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}$\rangle$

\meta{special initial} \: ! \| \$ \| \% \| \verb"&" \| * \| / \| : \| < \| =
 \>  \| > \| ? \| \verb"^" \| \verb"_" \| \verb"~"
\meta{subsequent} \: \meta{initial} \| \meta{digit}
 \>  \| \meta{special subsequent}
 \> \| \meta{symbol escape}
\meta{digit} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9
\meta{hex digit} \: \meta{digit}
 \> \| a \| A \| b \| B \| c \| C \| d \| D \| e \| E \| f \| F
\meta{special subsequent} \: + \| - \| .\ \| @
\meta{symbol escape} \: \backwhack{}x\meta{hex scalar value};
\meta{hex scalar value} \: \atleastone{\meta{hex digit}}
 \> {\rm with at most 8 digits}
 \meta{peculiar identifier} \: + \| - \| ... \| -> \arbno{\meta{subsequent}}
%\| 1+ \| -1+
\meta{boolean} \: \schtrue{} \| \schfalse{}
\meta{character} \: \#\backwhack{}\meta{any character}
 \>  \| \#\backwhack{}\meta{character name}
 \>  \| \#\backwhack{}x\meta{hex scalar value}
\meta{character name} \: nul \| alarm \| backspace \| tab
\> \| linefeed \| vtab \| page \| return \| esc
\> \| space \| delete
\todo{Explain what happens in the ambiguous case.}
\meta{string} \: " \arbno{\meta{string element}} "
\meta{string element} \: \meta{any character other than \doublequote{} or \backwhack}
 \> \| \backwhack{}a \| \backwhack{}b \| \backwhack{}t \| \backwhack{}n \| \backwhack{}v \| \backwhack{}f \| \backwhack{}r
 \>  \| \backwhack\doublequote{} \| \backwhack\backwhack 
 \>  \| \meta{linefeed} \meta{intra-line whitespace}
\end{grammar}


\label{numbersyntax}

\begin{grammar}%
\meta{number} \: \meta{num $2$}%
       \| \meta{num $8$}
   \>  \| \meta{num $10$}%
       \| \meta{num $16$}
\end{grammar}

The following rules for \meta{num $R$}, \meta{complex $R$}, \meta{real
$R$}, \meta{ureal $R$}, \meta{uinteger $R$}, and \meta{prefix $R$}
should be replicated for \hbox{$R = 2, 8, 10,$}
and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
$8$}, and \meta{decimal $16$}, which means that numbers containing
decimal points or exponents must be in decimal radix.
\todo{Mark Meyer and David Bartley want to fix this.  (What? -- Will)}

In the these rules, case is insignificant.

\begin{grammar}%
\meta{num $R$} \: \meta{prefix $R$} \meta{complex $R$}
\meta{complex $R$} \: %
         \meta{real $R$} %
      \| \meta{real $R$} @ \meta{real $R$}
   \> \| \meta{real $R$} + \meta{ureal $R$} i %
      \| \meta{real $R$} - \meta{ureal $R$} i
   \> \| \meta{real $R$} + i %
      \| \meta{real $R$} - i
   \> \| + \meta{ureal $R$} i %
      \| - \meta{ureal $R$} i %
      \| + i %
      \| - i
\meta{real $R$} \: \meta{sign} \meta{ureal $R$}
\meta{ureal $R$} \: %
         \meta{uinteger $R$}
   \> \| \meta{uinteger $R$} / \meta{uinteger $R$}
   \> \| \meta{decimal $R$} \meta{mantissa width}
   \> \| inf.0 \| nan.0
\meta{decimal $10$} \: %
         \meta{uinteger $10$} \meta{suffix}
   \> \| . \atleastone{\meta{digit $10$}} \arbno{\#} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \arbno{\meta{digit $10$}} \arbno{\#} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} \atleastone{\#} . \arbno{\#} \meta{suffix}
\meta{uinteger $R$} \: \atleastone{\meta{digit $R$}} \arbno{\#}
\meta{prefix $R$} \: %
         \meta{radix $R$} \meta{exactness}
   \> \| \meta{exactness} \meta{radix $R$}
\end{grammar}

\begin{grammar}%
\meta{suffix} \: \meta{empty} 
   \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
\meta{exponent marker} \: e \| s \| f \| d \| l
\meta{mantissa width} \: \meta{empty}
   \> \| | \atleastone{\meta{digit 10}}
\meta{sign} \: \meta{empty}  \| + \|  -
\meta{exactness} \: \meta{empty} \| \#i\sharpindex{i} \| \#e\sharpindex{e}
\meta{radix 2} \: \#b\sharpindex{b}
\meta{radix 8} \: \#o\sharpindex{o}
\meta{radix 10} \: \meta{empty} \| \#d
\meta{radix 16} \: \#x\sharpindex{x}
\meta{digit 2} \: 0 \| 1
\meta{digit 8} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7
\meta{digit 10} \: \meta{digit}
\meta{digit 16} \: \meta{hex digit}
\end{grammar}

\todo{Mark Meyer of TI sez, shouldn't we allow {\tt 1e3/2}?}

\subsection{Whitespace and comments}

\defining{Whitespace} characters are spaces and newlines.
(Implementations typically provide additional whitespace characters such
as tab or page break.)  Whitespace is used for improved readability and
as necessary to separate lexemes from each other, a lexeme being an
indivisible lexical unit such as an identifier or number, but is
otherwise insignificant.  Whitespace may occur between any two lexemes,
but not within a lexeme.  Whitespace may also occur inside a string,
where it is significant.

A semicolon ({\tt;}) indicates the start of a
comment.\mainindex{comment}\mainschindex{;}  The comment continues to the
end of the line on which the semicolon appears.  Comments are invisible
to Scheme, but the end of the line is visible as whitespace.  This
prevents a comment from appearing in the middle of an identifier or
number.

Another way to indicate a comment is to prefix a \hyper{S-expression} (cf.\
Section~\ref{datumsyntax}) with {\tt \#;}, possibly with whitespace in
between.  The comment consists of the comment prefix {\tt \#;} and the
\hyper{S-expression}.  (This notation is useful for ``commenting out''
sections of code.)

Moreover, block comments may be indicated with properly nested {\tt
  \#|} and {\tt |\#} pairs.

\begin{scheme}
\#|
   The FACT procedure computes the factorial
   of a non-negative integer.
|\#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        \#;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))%
\end{scheme}

The lexemes {\cf \sharpsign{}!r6rs} and {\cf \sharpsign{}!/usr/bin/env}
are also comments.  The {\cf \sharpsign{}!r6rs} lexeme occurring in
program text identifies that program text to be written purely in the
language described by this report (see
section~\ref{librarysyntaxsection}).  The {\cf
  \sharpsign{}!/usr/bin/env} lexeme occurs at the beginning of scripts
and enables their direct execution on Unix-like systems (see
section~\ref{scriptsyntaxsection}).

\subsection{Identifiers}
\label{identifiersection}

Most identifiers\mainindex{identifier} allowed by other programming
languages are also acceptable to Scheme.  In particular,
a sequence of letters, digits, and ``extended alphabetic
characters'' that begins with a character that cannot begin a number is
an identifier.  In addition, \ide{+}, \ide{-}, and \ide{...} are identifiers. 
Here are some examples of identifiers:

\begin{scheme}
lambda                   q
list->vector             soup
{+}                        V17a
<=?                      a34kTMNs
the-word-recursion-has-many-meanings%
\end{scheme}

Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

\begin{scheme}
!\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}

Moreover, all characters whose scalar values are greater than 127 and
whose Unicode category is Lu, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd,
Pc, Po, Sc, Sm, Sk, So, or Co, can be used within identifiers.
Moreover, any character can appear as the constituent of an identifier
when denoted via a hexadecimal escape sequence.  For example, the
identifier \verb|H\x65;llo| is the same as the identifier
\verb|Hello|, and the identifier \verb|\x3BB;| is the same as the
identifier $\lambda$.

Any identifier may be used as a variable\index{variable} or as a
syntactic keyword\index{syntactic keyword} (see
sections~\ref{variablesection} and~\ref{macrosection}) in a Scheme
program.

Moreover, when viewed as data, an identifier denotes a {\em symbol\index{symbol}}
(see section~\ref{symbolsection}).

\subsection{Booleans}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}  The character
after a boolean literal must be a delimiter character such as a
space or parenthesis.

\subsection{Characters}

Characters are written using the notation
\sharpsign\backwhack\hyper{character} or
\sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}, where the latter
specifies the scalar value of a character with a hexadecimal number of
no more than eight digits.

For example:

\begin{scheme}
\#\backwhack{}a          ; lower case letter
\#\backwhack{}A          ; upper case letter
\#\backwhack{}(          ; left parenthesis
\#\backwhack{}           ; the space character
\#\backwhack{}nul        ; Unicode 0
\#\backwhack{}alarm      ; Unicode 7
\#\backwhack{}backspace  ; Unicode 8
\#\backwhack{}tab        ; Unicode 9
\#\backwhack{}linefeed   ; Unicode 10
\#\backwhack{}vtab       ; Unicode 11
\#\backwhack{}page       ; Unicode 12
\#\backwhack{}return     ; Unicode 13
\#\backwhack{}esc        ; Unicode 27
\#\backwhack{}space      ; Unicode 32;
             ; the preferred way to write a space
\#\backwhack{}delete     ; Unicode 127

\#\backwhack{}xFF        ; Unicode 255
\#\backwhack{}x03BB      ; Unicode 955
\#\backwhack{}x00006587  ; Unicode 25991
\#\backwhack{}\(\lambda\)          ; Unicode 955

\#\backwhack{}x0001z     ; parse error
\#\backwhack{}\(\lambda\)x         ; parse error
\#\backwhack{}alarmx     ; parse error
\#\backwhack{}alarm x    ; Unicode 7 followed by x
\#\backwhack{}Alarm      ; parse error
\#\backwhack{}alert      ; parse error
\#\backwhack{}xA         ; Unicode 10
\#\backwhack{}xFF        ; Unicode 255
\#\backwhack{}xff        ; Unicode 255
\#\backwhack{}x ff       ; Unicode 120
             ; followed by another S-expression, ff
\#\backwhack{}x(ff)      ; Unicode 120 
             ; followed by another S-expression,
             ; a parenthesized ff
\#\backwhack{}(x)        ; parse error
\#\backwhack{}(x         ; parse error
\#\backwhack{}((x)       ; Unicode 40
             ; followed by another S-expression,
             ; parenthesized x
\#\backwhack{}x00110000  ; parse error (out of range)
\#\backwhack{}x000000001 ; parse error (too many digits)
\#\backwhack{}xD800      ; parse error (in excluded range)
\end{scheme}

Case is significant in \sharpsign\backwhack\hyper{character}, and in in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
but not in \sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}.  
The character after a \meta{character}
must be a delimiter character such as a
space or parenthesis.  This rule resolves various ambiguous cases, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
could be taken to be either a representation of the space character or a
representation of the character ``{\tt\sharpsign\backwhack s}'' followed
by a representation of the symbol ``{\tt pace}.''

\subsection{Strings}

\vest String are written as sequences of characters enclosed within doublequotes
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} denote characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\tt \backwhack{}a} : alarm, Unicode 7
\item{\tt \backwhack{}b} : backspace, Unicode 8 
\item{\tt \backwhack{}t} : tab, Unicode 9 
\item{\tt \backwhack{}n} : linefeed, Unicode 10 
\item{\tt \backwhack{}v} : vertical tab, Unicode 11 
\item{\tt \backwhack{}f} : formfeed, Unicode 12 
\item{\tt \backwhack{}r} : return, Unicode 13 
\item{\tt \backwhack{}}\verb|"| : doublequote, Unicode 34 
\item{\tt \backwhack{}\backwhack{}} : backslash, Unicode 92 
\item{\tt \backwhack{}\hyper{linefeed}\hyper{intraline whitespace}} : nothing
\item{\tt \backwhack{}\ } : space, Unicode 32 (useful for terminating the
  previous escape sequence before continuing with whitespace)
\item{\tt \backwhack{}x\atleastone{\hyper{digit 16}};} : (note the
  terminating semi-colon) where no more than eight \hyper{digit 16}s
  are provided, and the sequence of \hyper{digit 16}s forms a
  hexadecimal number between 0 and \sharpsign{}xFFFF excluding the
  range $\left[\sharpsign{}x\textrm{D800},
    \sharpsign{}x\textrm{DFFF}\right]$.
\end{itemize}

These escape sequences are case-sensitive, except that \hyper{digit
  16} can be an uppercase or lowercase hexadecimal digit.

Any other character in a string after a backslash is an error. Any
character outside of an escape sequence and not a doublequote stands
for itself in the string literal. For example the single-character
string {\tt "$\lambda$"} (double quote, a lower case lambda, double
quote) denotes the same string literal as {\tt "\backwhack{}x03bb;"}.

Examples:

\begin{center}
  \begin{tabular}{ll}
    {\tt "abc"}    & ; Unicode sequence 97, 98, 99\\
    {\tt "\backwhack{}x41;bc"} & ; ``Abc'', Unicode sequence 65, 98, 99\\
    {\tt "\backwhack{}x41; bc"} & ; ``A bc'', Unicode sequence 65, 32, 98, 99\\
    {\tt "\backwhack{}x41bc;"} & ; Unicode sequence 16828\\
    {\tt "\backwhack{}x41"} & ; parse error\\
    {\tt "\backwhack{}x;"} & ; parse error\\
    {\tt "\backwhack{}x41bx;"} & ; parse error\\
    {\tt "\backwhack{}x00000041;"} & ; ``A'', Unicode sequence 65\\
    {\tt "\backwhack{}x0010FFFF;"} &  ; Unicode sequence \#x10FFFF\\
    {\tt "\backwhack{}x00110000;"}&  ; parse error (out of range)\\
    {\tt "\backwhack{}x000000001;"}& ; parse error (too many digits)\\
    {\tt "\backwhack{}xD800;"}&      ; parse error (in excluded range)
  \end{tabular}
\end{center}

\subsection{Numbers}
\label{numbernotations}

The syntax of the written representations for numbers is described
formally by the \meta{number} rule in the formal grammar.  Note that
case is not significant in numerical constants.

A number may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
no radix prefix, a number is assumed to be expressed in decimal.

A
numerical constant may be specified to be either exact or
inexact by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
for exact, and {\cf \#i}\sharpindex{i} for inexact.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the written representation of a number has no exactness prefix, the
constant may be either inexact or exact.  It is
inexact if it contains a decimal point, an
exponent, or a ``\sharpsign'' character in the place of a digit,
otherwise it is exact.

In systems with inexact numbers
of varying precisions it may be useful to specify
the precision of a constant.  For this purpose, numerical constants
may be written with an exponent marker that indicates the
desired precision of the inexact
representation.  The letters {\cf s}, {\cf f},
{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
\var{double}, and \var{long} precision, respectively.  (When fewer
than four internal
inexact
representations exist, the four size
specifications are mapped onto those available.  For example, an
implementation with two internal representations may map short and
single together and long and double together.)  In addition, the
exponent marker {\cf e} specifies the default precision for the
implementation.  The default precision has at least as much precision
as \var{double}, but
implementations may wish to allow this default to be set by the user.

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}

If \var{x} is an external representation of an inexact real number
according to R5RS, and \var{p} is a sequence of 1 or more decimal
digits, then {\cf \var{x}|\var{p}} is an external representation that
denotes the best binary floating point approximation to \var{x} using
a \var{p}-bit significand.  For example, {\cf 1.1|53} is an external
representation for the best approximation to 1.1 in IEEE double
precision.

If \var{x} is an external representation of an inexact real number
according to R5RS, then \var{x} by itself should be regarded as
equivalent to {\cf \var{x}|53}

The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
negative infinity, respectively.  The {\cf +nan.0} and {\cf -nan.0}
literals represent the NaN that is the result of {\cf (/ 0.0 0.0)}
and may represent other NaNs as well.

Implementations that use binary floating point representations
of real numbers should represent {\cf \var{x}|\var{p}}
using a \var{p}-bit significand if practical, or by a greater
precision if a \var{p}-bit significand is not practical, or
by the largest available precision if \var{p} or more bits
of significand is not practical within the implementation.

\begin{note}
The precision of a significand should not be confused with the
number of bits used to represent the significand.  In the IEEE
floating point standards, for example, the significand's most
significant bit is implicit in single and double precision but
is explicit in extended precision.  Whether that bit is implicit
or explicit does not affect the mathematical precision.
In implementations that use binary floating point, the default
precision can be calculated by calling the following procedure:

\begin{scheme}
(define (precision)
  (do ((n 0 (+ n 1))
       (x 1.0 (/ x 2.0)))
    ((= 1.0 (+ 1.0 x)) n)))
\end{scheme}
\end{note}      

\begin{note}
When the underlying floating-point representation is IEEE double
precision, the {\cf |\var{p}} suffix should not be
omitted for all cases:
Denormalized numbers have diminished precision, and therefore should
carry a {\cf |\var{p}} suffix with the actual width of the
significand.
\end{note}

If a \meta{decimal 10} does not contain a non-empty \meta{mantissa
  width} and does not contain one of the exponent markers {\cf s},
{\cf f}, {\cf d}, or {\cf l}, but does contain a decimal point or the
exponent marker {\cf e}, then it is an external representation for a
flonum.  Furthermore {\cf inf.0}, {\cf +inf.0}, {\cf -inf.0}, {\cf
  nan.0}, {\cf +nan.0}, and {\cf -nan.0} are external representations
for flonums.  Some or all of the other external representations for
inexact reals may also represent flonums, but that is not required by
this SRFI.

If a \meta{decimal 10} contains a non-empty \meta{mantissa width} or
one of the exponent markers {\cf s}, {\cf f}, {\cf d}, or {\cf l},
then it represents an inexact number, but does not necessarily
represent a flonum.

\section{Read syntax}
\label{readsyntaxsection}

The read syntax describes the syntax of
S-expressions\index{S-expression} in terms of a sequence of
\meta{lexeme}s, as defined in the lexical syntax.

S-expressions include the lexeme S-expressions described in the
previous section as well as the following constructs for forming
compound structure:
%
\begin{itemize}
\item pairs and lists, enclosed by \verb|( )| or \verb|[ ]| (see
  section~\ref{pairlistsyntax})
\item  vectors (see~\ref{vectorsection})
\end{itemize}

Note that the sequence of characters ``{\tt(+ 2 6)}'' is {\em not} an
S-expression representing the integer 8, even though it {\em is} a
core-languae expression evaluating to the integer 8; rather, it is an
S-expression representing a three-element list, the elements of which
are the symbol {\tt +} and the integers 2 and 6.

\subsection{Formal account}
\label{datumsyntax}

The following grammar describes the syntax of S-expressions in terms
of various kinds of lexemes defined in the grammar in
section~\ref{lexicalsyntaxsection}:

\begin{grammar}%
\meta{S-expression} \: \meta{simple S-expression}
\>  \| \meta{compound S-expression}
\meta{simple S-expression} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string} \|  \meta{symbol}
\meta{symbol} \: \meta{identifier}
\meta{compound S-expression} \: \meta{list} \| \meta{vector}
\meta{list} \: (\arbno{\meta{S-expression}})
\>    \| [\arbno{\meta{S-expression}}]
\>    \| (\atleastone{\meta{S-expression}} .\ \meta{S-expression})
\>    \| [\atleastone{\meta{S-expression}} .\ \meta{S-expression}]
\>    \| \meta{abbreviation}
\meta{abbreviation} \: \meta{abbrev prefix} \meta{S-expression}
\meta{abbrev prefix} \: ' \| ` \| , \| ,@ \| \#'
\meta{vector} \: \#(\arbno{\meta{S-expression}})
\meta{bytes} \: \#vu8(\arbno{\meta{u8}})
\meta{u8} \: $\langle${\rm any \meta{number} denoting an exact}
 \>\>\quad\quad {\rm integer in $\{0, \ldots, 255\}$}$\rangle$%
\end{grammar}

\subsection{Vectors}
\label{vectorsyntax}

Vector S-expressions, denoting vectors of values (see
section~\ref{vectorsection}, are written using the notation
{\tt\#(\var{obj} \dotsfoo)}.  For example, a vector of length 3
containing the number zero in element 0, the list {\cf(2 2 2 2)} in
element 1, and the string {\cf "Anna"} in element 2 can be written as
following:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

Note that this is the external representation of a vector, not a
core-language expression evaluating to a vector.

\subsection{Pairs and lists}
\label{pairlistsyntax}

List and pair S-expressions, denoting pairs and lists of values
(see~\ref{listsection}) are written using parentheses or brackets.
Matching pairs of parentheses that occur in the rules of \meta{list} are
equivalent to matching pairs of brackets.

The most general notation (external representation) for Scheme pairs is
the ``dotted'' notation \hbox{\cf (\vari{c} .\ \varii{c})} where
\vari{c} is the value of the car field and \varii{c} is the value of the
cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
cdr is 5.  Note that {\cf (4 .\ 5)} is the external representation of a
pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list\index{empty list} is written {\tt()} .  For example,

\begin{scheme}
(a b c d e)%
\end{scheme}

and

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

are equivalent notations for a list of symbols.

\subsection{Bytes objects}

Bytes S-expressions, denoting bytes objects (see
section~\ref{bytessection}, are written using the notation
{\tt\#vu8(\var{u8} \dotsfoo)}, where the \var{u8}s are the octets of
the bytes object.  For example, a bytes object of length 3 containing the
octets 2, 24, and 123 can be written as following:

\begin{scheme}
\#vu8(2 24 123)%
\end{scheme}

Note that this is the external representation of a bytes object, not a
core-language expression evaluating to a bytes object.

\subsection{Abbreviations}\unsection
\label{quotesection}

\begin{entry}{%
\pproto{\singlequote\hyper{S-expression}}{}
\pproto{\backquote\hyper{S-expression}}{}
\pproto{,\hyper{S-expression}}{}
\pproto{,\atsign\hyper{S-expression}}{}
\pproto{\#,\hyper{S-expression}}{}
}

\mainschindex{'}\singlequote\hyper{S-expression} is an abbreviation
for {\cf (quote \hyper{S-expression})}.
\mainschindex{`}\backquote\hyper{S-expression} is an abbreviation
for {\cf (quasiquote \hyper{S-expression})}.
\mainschindex{,}{\cf,}\hyper{S-expression} is an abbreviation
for {\cf (unquote \hyper{S-expression})}.
\mainschindex{,@}{\cf,}\atsign\hyper{S-expression} is an abbreviation
for {\cf (unquote-splicing \hyper{S-expression})}.
\sharpindex{'}{\cf\#'}\hyper{S-expression} is an abbreviation
for {\cf (syntax \hyper{S-expression})}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
