\section{Enumerations}
\label{enumerationssection}

This section describes the \deflibrary{r6rs enum} library for dealing with enumerated values
\mainschindex{enumeration}and sets of enumerated values.  Enumerated
values are represented by ordinary symbols, while finite sets of
enumerated values form a separate type, known as the
\defining{enumeration sets}.
The enumeration sets are further partitioned into sets that
share the same \defining{universe} and \defining{enumeration type}.
These universes and enumeration types are created by the
{\cf make-enumeration} procedure.  Each call to that procedure
creates a new enumeration type.

This library interprets each enumeration set with respect to
its specific universe of symbols and enumeration type.
This facilitates efficient implementation of enumeration sets
and enables the complement operation.

In the definition of the following procedures, let \var{enum-set}
range over the enumeration sets, which are defined as the subsets
of the universes that can be defined using {\cf make-enumeration}.

\begin{entry}{%
\proto{make-enumeration}{ list}{procedure}}

{\cf make-enumeration} takes an arbitrary list of symbols,
creates a new enumeration type whose universe consists of
those symbols (in canonical order of their first appearance
in the list) and returns that universe as an enumeration
set whose universe is itself and whose enumeration type is
the newly created enumeration type.
\end{entry}

\begin{entry}{%
\proto{enum-set-universe}{ enum-set}{procedure}}

{\cf enum-set-universe} returns the set of all symbols that comprise
the universe of its argument.
\end{entry}

\begin{entry}{%
\proto{enum-set-indexer}{ enum-set}{procedure}}

{\cf enum-set-indexer} returns a unary procedure that, given a symbol
that is in the universe of \var{enum-set}, returns its 0-origin index
within the canonical ordering of the symbols in the universe; given a
value not in the universe, the unary procedure returns \schfalse.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (i (enum-set-indexer e)))
  (list (i 'red) (i 'green) (i 'blue) (i 'yellow))) \lev (0 1 2 \schfalse)
\end{scheme}

{\cf enum-set-indexer} could be defined as follows (using the
{\cf memq} procedure from the \library{r6rs lists} library):

\begin{scheme}
(define (enum-set-indexer set)
  (let* ((symbols (enum-set->list
                    (enum-set-universe set)))
         (cardinality (length symbols)))
    (lambda (x)
      (let ((probe (memq x symbols)))
        (if probe
            (- cardinality (length probe))
            \schfalse)))))
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-constructor}{ enum-set}{procedure}}

{\cf enum-set-constructor} returns a unary procedure that, given a
list of symbols that belong to the universe of \var{enum-set}, returns
a subset of that universe that contains exactly the symbols in the
list.  If any value in the list is not a symbol that belongs to the
universe, then the unary procedure must raise a {\cf \&domain} exception.
\end{entry}

\begin{entry}{%
\proto{enum-set->list}{ enum-set}{procedure}}

{\cf enum-set->list} returns a list of the symbols that belong to its
argument, in the canonical order of the universe of \var{enum-set}.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list (c '(blue red)))) \lev (red blue)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-member?}{ symbol enum-set}{procedure}
\proto{enum-set-subset?}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set=?}{ \vari{enum-set} \varii{enum-set}}{procedure}}

{\cf enum-set-member?} returns \schtrue{} if its first argument is an
element of its second argument, \schfalse{} otherwise.

{\cf enum-set-subset?} returns \schtrue{} if the universe of
\vari{enum-set} is a subset of the universe of \varii{enum-set}
(considered as sets of symbols) and every element of \vari{enum-set}
is a member of its second.  It returns \schfalse{} otherwise.

{\cf enum-set=?} returns \schtrue{} if \vari{enum-set}  is a
subset of \varii{enum-set} and vice versa, as determined by the
{\cf enum-set-subset?} procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply
that they are equal as enumeration types.  Otherwise, \schfalse{} is
returned.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list
   (enum-set-member? 'blue (c '(red blue)))
   (enum-set-member? 'green (c '(red blue)))
   (enum-set-subset? (c '(red blue)) e)
   (enum-set-subset? (c '(red blue)) (c '(blue red)))
   (enum-set-subset? (c '(red blue)) (c '(red)))
   (enum-set=? (c '(red blue)) (c '(blue red)))))
\ev (\schtrue{} \schfalse{} \schtrue{} \schtrue{} \schfalse{} \schtrue{})
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-union}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set-intersection}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set-difference}{ \vari{enum-set} \varii{enum-set}}{procedure}}


\domain{\vari{enum-set} and \varii{enum-set} must be enumeration sets 
  that have the same enumeration type.  If their enumeration types
  differ, a {\cf\&contract} violation is raised.}

{\cf enum-set-union} returns the union of \vari{enum-set} and \varii{enum-set}.
{\cf enum-set-intersection} returns the intersection of \vari{enum-set} and \varii{enum-set}.
{\cf enum-set-difference} returns the difference of \vari{enum-set}
and \varii{enum-set}.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list (enum-set->list
         (enum-set-union (c '(blue)) (c '(red))))
        (enum-set->list
         (enum-set-intersection (c '(red green))
                                (c '(red blue))))
        (enum-set->list
         (enum-set-difference (c '(red green))
                              (c '(red blue))))))
\lev ((red blue) (red) (green))
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-complement}{ enum-set}{procedure}}

{\cf enum-set-complement} takes an enumeration set and returns its
complement with respect to its universe.


\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list
   (enum-set-complement (c '(red)))))
\ev (green blue)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-projection}{ \vari{enum-set} \varii{enum-set}}{procedure}}

{\cf enum-set-projection} projects \vari{enum-set} into the universe
of \varii{enum-set}, dropping any elements of \vari{enum-set} that do
not belong to the universe of \varii{enum-set}.  (If \vari{enum-set}
is a subset of the universe of its second, then no elements are
dropped, and the injection is returned.)

\begin{scheme}
(let ((e1 (make-enumeration
           '(red green blue black)))
      (e2 (make-enumeration
           '(red black white))))
  (enum-set->list
   (enum-set-projection e1 e2))))
\ev (red black)
\end{scheme}
\end{entry}

\begin{entry}{}
\pproto{(define-enumeration \hyper{type-name}}{\exprtype}
\mainschindex{define-enumeration}{\tt\obeyspaces%
  (\hyper{symbol} \dotsfoo)\\
  \hyper{constructor-syntax})}

The {\cf define-enumeration} form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.

A {\cf define-enumeration} form is a definition and can appear
anywhere any other \hyper{definition} can appear.

\hyper{type-name} is an identifier that will be bound to a macro;
\hyper{symbol}~\dotsfoo{} are the symbols that will comprise the
universe of the enumeration (in order).

{\cf (\hyper{type-name} \hyper{symbol})} checks at macro-expansion
time whether \hyper{symbol} is in the universe associated with
\hyper{type-name}.  If it is, then {\cf (\hyper{type-name}
  \hyper{symbol})} is equivalent to {\cf \hyper{symbol}}.  If it is
not, then an exception must be raised at macro expansion
time. FIXME: clarify

\hyper{constructor-syntax} is an identifier that will be bound to a
macro that, given any finite sequence of the symbols in the universe,
possibly with duplicates, expands into an expression that evaluates
to the enumeration set of those symbols.

{\cf (\hyper{constructor-syntax} \hyper{symbol}~\dotsfoo{})} checks at
macro-expansion time whether every \hyper{symbol}~\dotsfoo{} is in the
universe associated with \hyper{type-name}.  If one or more is not,
then an exception must be raised at macro expansion time. FIXME:
clarify. Otherwise
\begin{scheme}
(\hyper{constructor-syntax} \hyper{symbol}~\dotsfoo{})
\end{scheme}
%
is equivalent to
%
\begin{scheme}
((enum-set-constructor (\hyper{constructor-syntax}))
 (list '\hyper{symbol}~\dotsfoo{}))\rm.
\end{scheme}

\begin{scheme}
(define-enumeration color
  (black white purple maroon)
  color-set)

(color black)                      \ev black
(color purpel)                     \ev \exception{\&syntax}
(enum-set->list (color-set))       \ev ()
(enum-set->list
 (color-set maroon white))         \ev (white maroon)
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

