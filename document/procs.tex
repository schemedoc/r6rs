% Initial environment

%\vfill\eject
\chapter{Standard procedures}
\label{initialenv}
\label{builtinchapter}

\mainindex{initial environment}
\mainindex{top level environment}
\mainindex{library procedure}

This chapter describes Scheme's built-in procedures.  The initial (or
``top level'') Scheme environment starts out with a number of variables
bound to locations containing useful values, most of which are primitive
procedures that manipulate data.  For example, the variable {\cf abs} is
bound to (a location initially containing) a procedure of one argument
that computes the absolute value of a number, and the variable {\cf +}
is bound to a procedure that computes sums.  Built-in procedures that
can easily be written in terms of other built-in procedures are identified as
``library procedures''.

A program may use a top-level definition to bind any variable.  It may
subsequently alter any such binding by an assignment (see \ref{assignment}).
These operations do not modify the behavior of Scheme's built-in
procedures.  Altering any top-level binding that has not been introduced by a
definition has an unspecified effect on the behavior of the built-in procedures.

\section{Equivalence predicates}
\label{equivalencesection}

A \defining{predicate} is a procedure that always returns a boolean
value (\schtrue{} or \schfalse).  An \defining{equivalence predicate} is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, {\cf eq?}\ is the finest or most
discriminating, and {\cf equal?}\ is the coarsest.  {\cf Eqv?}\ is
slightly less discriminating than {\cf eq?}.  \todo{Pitman doesn't like
this paragraph.  Lift the discussion from the Maclisp manual.  Explain
why there's more than one predicate.}


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns \schtrue{} if \vari{obj} and \varii{obj} should
normally be regarded as the same object.  This relation is left slightly
open to interpretation, but the following partial specification of
{\cf eqv?} holds for all implementations of Scheme.

The {\cf eqv?} procedure returns \schtrue{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are both \schtrue{} or both \schfalse.

\item \vari{obj} and \varii{obj} are both symbols and

\begin{scheme}
(string=? (symbol->string obj1)
          (symbol->string obj2))
    \ev  \schtrue%
\end{scheme}

\begin{note} 
This assumes that neither \vari{obj} nor \varii{obj} is an ``uninterned
symbol'' as alluded to in section~\ref{symbolsection}.  This report does
not presume to specify the behavior of {\cf eqv?} on implementation-dependent
extensions.
\end{note}

\item \vari{obj} and \varii{obj} are both numbers, are numerically
equal (see {\cf =}, section~\ref{numbersection}), and are either both
exact\index{exact} or both inexact\index{inexact}.

\item \vari{obj} and \varii{obj} are both characters and are the same
character according to the {\cf char=?} procedure
(section~\ref{charactersection}).

\item both \vari{obj} and \varii{obj} are the empty list.

\item \vari{obj} and \varii{obj} are pairs, vectors, or strings that denote the
same locations in the store (section~\ref{storagemodel}).

\item \vari{obj} and \varii{obj} are procedures whose location tags are
equal (section~\ref{lambda}).
\end{itemize}

The {\cf eqv?} procedure returns \schfalse{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are of different types
(section~\ref{disjointness}).

\item one of \vari{obj} and \varii{obj} is \schtrue{} but the other is
\schfalse{}.

\item \vari{obj} and \varii{obj} are symbols but

\begin{scheme}
(string=? (symbol->string \vari{obj})
          (symbol->string \varii{obj}))
    \ev  \schfalse%
\end{scheme}

\item one of \vari{obj} and \varii{obj} is an exact number but the other
is an inexact number.

\item \vari{obj} and \varii{obj} are numbers for which the {\cf =}
procedure returns \schfalse{}.

\item \vari{obj} and \varii{obj} are characters for which the {\cf char=?}
procedure returns \schfalse{}.

\item one of \vari{obj} and \varii{obj} is the empty list but the other
is not.

\item \vari{obj} and \varii{obj} are pairs, vectors, or strings that denote
distinct locations.

\item \vari{obj} and \varii{obj} are procedures that would behave differently
(return different value(s) or have different side effects) for some arguments.

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(eqv? \#f 'nil)                  \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))		         \ev  \schtrue%
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified%
\end{scheme}

The next set of examples shows the use of {\cf eqv?}\ with procedures
that have local state.  {\cf Gen-counter} must return a distinct
procedure every time, since each procedure has its own internal counter.
{\cf Gen-loser}, however, returns equivalent procedures each time, since
the local state does not affect the value or side effects of the
procedures.

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

% Objects of distinct types must never be regarded as the same object,
% except that \schfalse{} and the empty list\index{empty list} are permitted to
% be identical.
%
% \begin{scheme}
% (eqv? '() \schfalse)    \ev  \unspecified%
% \end{scheme}

Since it is an error to modify constant objects (those returned by
literal expressions), implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of {\cf eqv?} on constants is sometimes
implementation-dependent.

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

\begin{rationale} 
The above definition of {\cf eqv?} allows implementations latitude in
their treatment of procedures and literals:  implementations are free
either to detect or to fail to detect that two procedures or two literals
are equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf Eq?}\ is similar to {\cf eqv?}\ except that in some cases it is
capable of discerning distinctions finer than those detectable by
{\cf eqv?}.

\vest {\cf Eq?}\ and {\cf eqv?}\ are guaranteed to have the same
behavior on symbols, booleans, the empty list, pairs, procedures,
and non-empty
strings and vectors.  {\cf Eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when {\cf eqv?}\ would also return
true.  {\cf Eq?} may also behave differently from {\cf eqv?} on empty
vectors and empty strings.

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}

\todo{Needs to be explained better above.  How can this be made to be
not confusing?  A table maybe?}

\begin{rationale} It will usually be possible to implement {\cf eq?}\ much
more efficiently than {\cf eqv?}, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute {\cf eqv?}\ of two numbers in
constant time, whereas {\cf eq?}\ implemented as pointer comparison will
always finish in constant time.  {\cf Eq?}\ may be used like {\cf eqv?}\
in applications using procedures to implement objects with state since
it obeys the same constraints as {\cf eqv?}.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{library procedure}}

{\cf Equal?} recursively compares the contents of pairs, vectors, and
strings, applying {\cf eqv?} on other objects such as numbers and symbols.
A rule of thumb is that objects are generally {\cf equal?} if they print
the same.  {\cf Equal?}\ may fail to terminate if its arguments are
circular data structures.

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}

\end{entry}

\section{Control features}
\label{proceduresection}
 
% Intro flushed; not very a propos any more.
% Procedures should be discussed somewhere, however.

This chapter describes various primitive procedures which control the
flow of program execution in special ways.
The {\cf procedure?}\ predicate is also described here.

\todo{{\tt Procedure?} doesn't belong in a section with the name
``control features.''  What to do?}

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

\domain{\var{Proc} must be a procedure and \var{args} must be a list.}
Calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{args})} as the actual
arguments.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{library procedure}}

\domain{The \var{list}s must be lists, and \var{proc} must be a
procedure taking as many arguments as there are {\it list}s
and returning a single value.  If more
than one \var{list} is given, then they must all be the same length.}
{\cf Map} applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.
The dynamic order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{library procedure}}

The arguments to {\cf for-each} are like the arguments to {\cf map}, but
{\cf for-each} calls \var{proc} for its side effects rather than for its
values.  Unlike {\cf map}, {\cf for-each} is guaranteed to call \var{proc} on
the elements of the \var{list}s in order from the first element(s) to the
last, and the value returned by {\cf for-each} is unspecified.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{force}{ promise}{library procedure}}

Forces the value of \var{promise} (see \ide{delay},
section~\ref{delay}).\index{promise}  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned.
% without any recomputation.
% [As pointed out by Marc Feeley, the "without any recomputation"
% isn't necessarily true. --Will]

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                               \ev  2%
\end{scheme}

{\cf Force} and {\cf delay} are mainly intended for programs written in
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.
% the value of a promise is computed at most once.
% [As pointed out by Marc Feeley, it may be computed more than once,
% but as I observed we can at least insist that only one value be
% used! -- Will]

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Here is a possible implementation of {\cf delay} and {\cf force}.
Promises are implemented here as procedures of no arguments,
and {\cf force} simply calls its argument:

\begin{scheme}
(define force
  (lambda (object)
    (object)))%
\end{scheme}

We define the expression

\begin{scheme}
(delay \hyper{expression})%
\end{scheme}

to have the same meaning as the procedure call

\begin{scheme}
(make-promise (lambda () \hyper{expression}))\rm
\end{scheme}

as follows

\begin{scheme}
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression))))),%
\end{scheme}

where {\cf make-promise} is defined as follows:

% \begin{scheme}
% (define make-promise
%   (lambda (proc)
%     (let ((already-run? \schfalse) (result \schfalse))
%       (lambda ()
%         (cond ((not already-run?)
%                (set! result (proc))
%                (set! already-run? \schtrue)))
%         result))))%
% \end{scheme}

\begin{scheme}
(define make-promise
  (lambda (proc)
    (let ((result-ready? \schfalse)
          (result \schfalse))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? \schtrue)
                         (set! result x)
                         result))))))))%
\end{scheme}

\begin{rationale}
A promise may refer to its own value, as in the last example above.
Forcing such a promise may cause the promise to be forced a second time
before the value of the first force has been computed.
This complicates the definition of {\cf make-promise}.
\end{rationale}

Various extensions to this semantics of {\cf delay} and {\cf force}
are supported in some implementations:

\begin{itemize}
\item Calling {\cf force} on an object that is not a promise may simply
return the object.

\item It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either \schtrue{} or to \schfalse{},
depending on the implementation:

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Some implementations may implement ``implicit forcing,'' where
the value of a promise is forced by primitive procedures like \cf{cdr}
and \cf{+}:

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  34%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}}

\label{continuations} \domain{\var{Proc} must be a procedure of one
argument.} The procedure {\cf call-with-current-continuation} packages
up the current continuation (see the rationale below) as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead use the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of \var{before} and \var{after} thunks installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation to the original call to \callcc.

\vest The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

\vest The following examples show only the most common ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-with-current-continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is extremely useful for implementing a
wide variety of advanced control structures.

\vest Whenever a Scheme expression is evaluated there is a
\defining{continuation} wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.  If the expression is
evaluated at top level, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers do not
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
{\cf Call-with-current-continuation} allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.

\vest Most programming languages incorporate one or more special-purpose
escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
invented a general purpose escape operator called the J-operator.  John
Reynolds~\cite{Reynolds72} described a simpler but equally powerful
construct in 1972.  The {\cf catch} special form described by Sussman
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
\ide{catch} construct could be provided by a procedure instead of by a
special syntactic construct, and the name
{\cf call-with-current-continuation} was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name \ide{call/cc} instead.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

Delivers all of its arguments to its continuation.
{\tt Values} might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))
\end{scheme}

The continuations of all commands (represented by \meta{command} in
the formal syntax) within a sequence of expressions (represented by
\meta{sequence} in the formal syntax) in {\cf lambda}, {\cf
  begin}, {\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf
  case}, {\cf cond}, and {\cf do} forms take an arbitrary number of
values.

Except for these and the continuations created by the {\cf
  call-with-values} procedure, all other continuations take exactly
one value.  The effect of passing an inappropriate number of values to
a continuation is unspecified.
\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

Calls its \var{producer} argument with no values and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

Calls \var{thunk} without arguments, returning the result(s) of this call.
\var{Before} and \var{after} are called, also without arguments, as required
by the following rules (note that in the absence of calls to continuations
captured using \ide{call-with-current-continuation} the three arguments are
called once each, in order).  \var{Before} is called whenever execution
enters the dynamic extent of the call to \var{thunk} and \var{after} is called
whenever it exits that dynamic extent.  The dynamic extent of a procedure
call is the period between when the call is initiated and when it
returns.  In Scheme, because of {\cf call-with-current-continuation}, the
dynamic extent of a call may not be a single, connected time period.
It is defined as follows:
\begin{itemize}
\item The dynamic extent is entered when execution of the body of the
called procedure begins.

\item The dynamic extent is also entered when execution is not within
the dynamic extent and a continuation is invoked that was captured
(using {\cf call-with-current-continuation}) during the dynamic extent.

\item It is exited when the called procedure returns.

\item It is also exited when execution is within the dynamic extent and
a continuation is invoked that was captured while not within the
dynamic extent.
\end{itemize}

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{after}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{after} associated with the second (inner) call to
{\cf dynamic-wind} is called first.

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{before}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{before} associated with the first (outer) call to
{\cf dynamic-wind} is called first.

If invoking a continuation requires calling the \var{before} from one call
to {\cf dynamic-wind} and the \var{after} from another, then the \var{after}
is called first.

The effect of using a captured continuation to enter or exit the dynamic
extent of a call to \var{before} or \var{after} is undefined.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)
\end{scheme}
\end{entry}

\section{\tt{Eval}}

\begin{entry}{%
\proto{eval}{ expression environment-specifier}{procedure}}

Evaluates \var{expression} in the specified environment and returns its value.
\var{Expression} must be a valid Scheme expression represented as data,
and \var{environment-specifier} must be a value returned by one of the
three procedures described below.
Implementations may extend {\cf eval} to allow non-expression programs
(definitions) as the first argument and to allow other
values as environments, with the restriction that {\cf eval} is not
allowed to create new bindings in the environments associated with
{\cf null-environment} or {\cf scheme-report-environment}.

\begin{scheme}
(eval '(* 7 3) (scheme-report-environment 5))
                                                   \ev  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                                   \ev  20
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ version}{procedure}
\proto{null-environment}{ version}{procedure}}

\var{Version} must be the exact integer {\cf \integerversion},
corresponding to this revision of the Scheme report (the
Revised$^\integerversion$ Report on Scheme).
{\cf Scheme-report-environment} returns a specifier for an
environment that is empty except for all bindings defined in
this report that are either required or both optional and
supported by the implementation. {\cf Null-environment} returns
a specifier for an environment that is empty except for the
(syntactic) bindings for all syntactic keywords defined in
this report that are either required or both optional and
supported by the implementation.

Other values of \var{version} can be used to specify environments
matching past revisions of this report, but their support is not
required.  An implementation will signal an error if \var{version}
is neither {\cf \integerversion} nor another value supported by
the implementation.

The effect of assigning (through the use of {\cf eval}) a variable
bound in a {\cf scheme-report-environment}
(for example {\cf car}) is unspecified.  Thus the environments specified
by {\cf scheme-report-environment} may be immutable.

\end{entry}

\begin{entry}{%
\proto{interaction-environment}{}{optional procedure}}

This procedure returns a specifier for the environment that
contains imple\-men\-ta\-tion-defined bindings, typically a superset of
those listed in the report.  The intent is that this procedure
will return the environment in which the implementation would evaluate
expressions dynamically typed by the user.

\end{entry}

\section{Input and output}

\subsection{Ports}
\label{portsection}

Ports represent input and output devices.  To Scheme, an input port is a
Scheme object that can deliver characters upon command, while an output port
is a Scheme object that can accept characters. \mainindex{port}

\todo{Haase: Mention that there are alternatives to files?}

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{library procedure}
\proto{call-with-output-file}{ string proc}{library procedure}}

\var{String} should be a string naming a file, and
\var{proc} should be a procedure that accepts one argument.
For {\cf call-with-input-file},
the file should already exist; for
{\cf call-with-output-file},
the effect is unspecified if the file
already exists. These procedures call \var{proc} with one argument: the
port obtained by opening the named file for input or output.  If the
file cannot be opened, an error is signalled.  If \var{proc} returns,
then the port is closed automatically and the value(s) yielded by the
\var{proc} is(are) returned.  If \var{proc} does not return, then 
the port will not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.
%Scheme
%will not close the port unless it can prove that the port will never
%again be used for a read or write operation.

\begin{rationale}
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to escape back in. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both {\cf call-with-current-continuation} and {\cf call-with-input-file} or
{\cf call-with-output-file}.
\todo{Pitman wants more said here; maybe encourage users to call
\var{close-foo-port}; maybe talk about process switches (?).}
\end{rationale} 
\end{entry}


\begin{entry}{%
\proto{input-port?}{ obj}{procedure}
\proto{output-port?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an input port or output port
respectively, otherwise returns \schfalse.

\todo{Won't necessarily return true after port is closed.}

\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{procedure}
\proto{current-output-port}{}{procedure}}
 
Returns the current default input or output port.

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{optional procedure}
\proto{with-output-to-file}{ string thunk}{optional procedure}}

\var{String} should be a string naming a file, and
\var{proc} should be a procedure of no arguments.
For {\cf with-input-from-file},
the file should already exist; for
{\cf with-output-to-file},
the effect is unspecified if the file
already exists.
The file is opened for input or output, an input or output port
connected to it is made the default value returned by
{\cf current-input-port} or {\cf current-output-port}
(and is used by {\tt (read)}, {\tt (write \var{obj})}, and so forth),
and the
\var{thunk} is called with no arguments.  When the \var{thunk} returns,
the port is closed and the previous default is restored.
{\cf With-input-from-file} and {\cf with-output-to-file} return(s) the
value(s) yielded by \var{thunk}.
If an escape procedure
is used to escape from the continuation of these procedures, their
behavior is implementation dependent.

\todo{OK this with authors??}
%current continuation changes in such a way
%as to make it doubtful that the \var{thunk} will ever return.

\todo{Freeman:
Throughout this section I wanted to see ``the value of {\tt(current-input-port)}''
instead of ``the value returned by \var{current-input-port}''.  (Same for
\var{current-output-port}.)}


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ filename}{procedure}}
 
Takes a string naming an existing file and returns an input port capable of
delivering characters from the file.  If the file cannot be opened, an error is
signalled.

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ filename}{procedure}}

Takes a string naming an output file to be created and returns an output
port capable of writing characters to a new file by that name.  If the file
cannot be opened, an error is signalled.  If a file with the given name
already exists, the effect is unspecified.

\end{entry}


\begin{entry}{%
\proto{close-input-port}{ port}{procedure}
\proto{close-output-port}{ port}{procedure}}

Closes the file associated with \var{port}, rendering the \var{port}
incapable of delivering or accepting characters.  \todo{But maybe a no-op
on some ports, e.g. terminals or editor buffers.}
These routines have no effect if the file has already been closed.
The value returned is unspecified.

\todo{Ramsdell:  Some note is needed explaining why there are two
different close procedures.}

\todo{A port isn't necessarily still a port after it has been closed?}

\end{entry}


\subsection{Input}
\label{inputsection}

\noindent \hbox{ }  %???
\vspace{-5ex}
\todo{The input routines have some things in common, maybe explain here.}

\begin{entry}{%
\proto{read}{}{library procedure}
\rproto{read}{ port}{library procedure}}

{\cf Read} converts external representations of Scheme objects into the
objects themselves.  That is, it is a parser for the nonterminal
\meta{datum} (see sections~\ref{datum} and
\ref{listsection}).  {\cf Read} returns the next
object parsable from the given input \var{port}, updating \var{port} to point to
the first character past the end of the external representation of the object.

\vest If an end of file is encountered in the input before any
characters are found that can begin an object, then an end of file
object is returned.  \todo{} The port remains open, and further attempts
to read will also return an end of file object.  If an end of file is
encountered after the beginning of an object's external representation,
but the external representation is incomplete and therefore not parsable,
an error is signalled.

The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-input-port}.  It is an error to read from
a closed port.
\end{entry}

\begin{entry}{%
\proto{read-char}{}{procedure}
\rproto{read-char}{ port}{procedure}}

Returns the next character available from the input \var{port}, updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{procedure}
\rproto{peek-char}{ port}{procedure}}

Returns the next character available from the input \var{port},
{\em without} updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\begin{note}
The value returned by a call to {\cf peek-char} is the same as the
value that would have been returned by a call to {\cf read-char} with the
same \var{port}.  The only difference is that the very next call to
{\cf read-char} or {\cf peek-char} on that \var{port} will return the
value returned by the preceding call to {\cf peek-char}.  In particular, a call
to {\cf peek-char} on an interactive port will hang waiting for input
whenever a call to {\cf read-char} would have hung.
\end{note}

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an end of file object, otherwise returns
\schfalse.  The precise set of end of file objects will vary among
implementations, but in any case no end of file object will ever be an object
that can be read in using {\cf read}.

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{procedure}
\rproto{char-ready?}{ port}{procedure}}

Returns \schtrue{} if a character is ready on the input \var{port} and
returns \schfalse{} otherwise.  If {\cf char-ready} returns \schtrue{} then
the next {\cf read-char} operation on the given \var{port} is guaranteed
not to hang.  If the \var{port} is at end of file then {\cf char-ready?}\
returns \schtrue.  \var{Port} may be omitted, in which case it defaults to
the value returned by {\cf current-input-port}.

\begin{rationale}
{\cf Char-ready?}\ exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by {\cf char-ready?}\ cannot
be rubbed out.  If {\cf char-ready?}\ were to return \schfalse{} at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
\end{rationale}
\end{entry}


\subsection{Output}
\label{outputsection}

% We've got to put something here to fix the indentation!!
\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{library procedure}
\rproto{write}{ obj port}{library procedure}}

Writes a written representation of \var{obj} to the given \var{port}.  Strings
that appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are
escaped by backslashes.
Character objects are written using the {\cf \#\backwhack} notation.
{\cf Write} returns an unspecified value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{library procedure}
\rproto{display}{ obj port}{library procedure}}

Writes a representation of \var{obj} to the given \var{port}.  Strings
that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.  Character
objects appear in the representation as if written by {\cf write-char}
instead of by {\cf write}.  {\cf Display} returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\begin{rationale}
{\cf Write} is intended
for producing mach\-ine-readable output and {\cf display} is for producing
human-readable output.  Implementations that allow ``slashification''
within symbols will probably want {\cf write} but not {\cf display} to
slashify funny characters in symbols.
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{library procedure}
\rproto{newline}{ port}{library procedure}}

Writes an end of line to \var{port}.  Exactly how this is done differs
from one operating system to another.  Returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{procedure}
\rproto{write-char}{ char port}{procedure}}

Writes the character \var{char} (not an external representation of the
character) to the given \var{port} and returns an unspecified value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}


\subsection{System interface}

Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


\begin{entry}{%
\proto{load}{ filename}{optional procedure}}

\todo{Fix}

%\domain{\var{Filename} should be a string naming an existing file
%containing Scheme source code.} The {\cf load} procedure reads
\var{Filename} should be a string naming an existing file
containing Scheme source code.  The {\cf load} procedure reads
expressions and definitions from the file and evaluates them
sequentially.  It is unspecified whether the results of the expressions
are printed.  The {\cf load} procedure does not affect the values
returned by {\cf current-input-port} and {\cf current-output-port}.
{\cf Load} returns an unspecified value.

\begin{rationale}
For portability, {\cf load} must operate on source files.
Its operation on other kinds of files necessarily varies among
implementations.
\end{rationale}
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
