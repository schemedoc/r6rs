% Initial environment

%\vfill\eject


\section{Input and output}

\subsection{Ports}
\label{portsection}

Ports represent input and output devices.  To Scheme, an input port is a
Scheme object that can deliver characters upon command, while an output port
is a Scheme object that can accept characters. \mainindex{port}

\todo{Haase: Mention that there are alternatives to files?}

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{library procedure}
\proto{call-with-output-file}{ string proc}{library procedure}}

\var{String} should be a string naming a file, and
\var{proc} should be a procedure that accepts one argument.
For {\cf call-with-input-file},
the file should already exist; for
{\cf call-with-output-file},
the effect is unspecified if the file
already exists. These procedures call \var{proc} with one argument: the
port obtained by opening the named file for input or output.  If the
file cannot be opened, an error is signalled.  If \var{proc} returns,
then the port is closed automatically and the value(s) yielded by the
\var{proc} is(are) returned.  If \var{proc} does not return, then 
the port will not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.
%Scheme
%will not close the port unless it can prove that the port will never
%again be used for a read or write operation.

\begin{rationale}
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to escape back in. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both {\cf call-with-current-continuation} and {\cf call-with-input-file} or
{\cf call-with-output-file}.
\todo{Pitman wants more said here; maybe encourage users to call
\var{close-foo-port}; maybe talk about process switches (?).}
\end{rationale} 
\end{entry}


\begin{entry}{%
\proto{input-port?}{ obj}{procedure}
\proto{output-port?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an input port or output port
respectively, otherwise returns \schfalse.

\todo{Won't necessarily return true after port is closed.}

\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{procedure}
\proto{current-output-port}{}{procedure}}
 
Returns the current default input or output port.

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{optional procedure}
\proto{with-output-to-file}{ string thunk}{optional procedure}}

\var{String} should be a string naming a file, and
\var{proc} should be a procedure of no arguments.
For {\cf with-input-from-file},
the file should already exist; for
{\cf with-output-to-file},
the effect is unspecified if the file
already exists.
The file is opened for input or output, an input or output port
connected to it is made the default value returned by
{\cf current-input-port} or {\cf current-output-port}
(and is used by {\tt (read)}, {\tt (write \var{obj})}, and so forth),
and the
\var{thunk} is called with no arguments.  When the \var{thunk} returns,
the port is closed and the previous default is restored.
{\cf With-input-from-file} and {\cf with-output-to-file} return(s) the
value(s) yielded by \var{thunk}.
If an escape procedure
is used to escape from the continuation of these procedures, their
behavior is implementation dependent.

\todo{OK this with authors??}
%current continuation changes in such a way
%as to make it doubtful that the \var{thunk} will ever return.

\todo{Freeman:
Throughout this section I wanted to see ``the value of {\tt(current-input-port)}''
instead of ``the value returned by \var{current-input-port}''.  (Same for
\var{current-output-port}.)}


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ filename}{procedure}}
 
Takes a string naming an existing file and returns an input port capable of
delivering characters from the file.  If the file cannot be opened, an error is
signalled.

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ filename}{procedure}}

Takes a string naming an output file to be created and returns an output
port capable of writing characters to a new file by that name.  If the file
cannot be opened, an error is signalled.  If a file with the given name
already exists, the effect is unspecified.

\end{entry}


\begin{entry}{%
\proto{close-input-port}{ port}{procedure}
\proto{close-output-port}{ port}{procedure}}

Closes the file associated with \var{port}, rendering the \var{port}
incapable of delivering or accepting characters.  \todo{But maybe a no-op
on some ports, e.g. terminals or editor buffers.}
These routines have no effect if the file has already been closed.
The value returned is unspecified.

\todo{Ramsdell:  Some note is needed explaining why there are two
different close procedures.}

\todo{A port isn't necessarily still a port after it has been closed?}

\end{entry}


\subsection{Input}
\label{inputsection}

\noindent \hbox{ }  %???
\vspace{-5ex}
\todo{The input routines have some things in common, maybe explain here.}

\begin{entry}{%
\proto{read}{}{library procedure}
\rproto{read}{ port}{library procedure}}

{\cf Read} converts external representations of Scheme objects into the
objects themselves.  That is, it is a parser for the nonterminal
\meta{datum} (see sections~\ref{datum} and
\ref{listsection}).  {\cf Read} returns the next
object parsable from the given input \var{port}, updating \var{port} to point to
the first character past the end of the external representation of the object.

\vest If an end of file is encountered in the input before any
characters are found that can begin an object, then an end of file
object is returned.  \todo{} The port remains open, and further attempts
to read will also return an end of file object.  If an end of file is
encountered after the beginning of an object's external representation,
but the external representation is incomplete and therefore not parsable,
an error is signalled.

The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-input-port}.  It is an error to read from
a closed port.
\end{entry}

\begin{entry}{%
\proto{read-char}{}{procedure}
\rproto{read-char}{ port}{procedure}}

Returns the next character available from the input \var{port}, updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{procedure}
\rproto{peek-char}{ port}{procedure}}

Returns the next character available from the input \var{port},
{\em without} updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\begin{note}
The value returned by a call to {\cf peek-char} is the same as the
value that would have been returned by a call to {\cf read-char} with the
same \var{port}.  The only difference is that the very next call to
{\cf read-char} or {\cf peek-char} on that \var{port} will return the
value returned by the preceding call to {\cf peek-char}.  In particular, a call
to {\cf peek-char} on an interactive port will hang waiting for input
whenever a call to {\cf read-char} would have hung.
\end{note}

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an end of file object, otherwise returns
\schfalse.  The precise set of end of file objects will vary among
implementations, but in any case no end of file object will ever be an object
that can be read in using {\cf read}.

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{procedure}
\rproto{char-ready?}{ port}{procedure}}

Returns \schtrue{} if a character is ready on the input \var{port} and
returns \schfalse{} otherwise.  If {\cf char-ready} returns \schtrue{} then
the next {\cf read-char} operation on the given \var{port} is guaranteed
not to hang.  If the \var{port} is at end of file then {\cf char-ready?}\
returns \schtrue.  \var{Port} may be omitted, in which case it defaults to
the value returned by {\cf current-input-port}.

\begin{rationale}
{\cf Char-ready?}\ exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by {\cf char-ready?}\ cannot
be rubbed out.  If {\cf char-ready?}\ were to return \schfalse{} at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
\end{rationale}
\end{entry}


\subsection{Output}
\label{outputsection}

% We've got to put something here to fix the indentation!!
\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{library procedure}
\rproto{write}{ obj port}{library procedure}}

Writes a written representation of \var{obj} to the given \var{port}.  Strings
that appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are
escaped by backslashes.
Character objects are written using the {\cf \#\backwhack} notation.
{\cf Write} returns an unspecified value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{library procedure}
\rproto{display}{ obj port}{library procedure}}

Writes a representation of \var{obj} to the given \var{port}.  Strings
that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.  Character
objects appear in the representation as if written by {\cf write-char}
instead of by {\cf write}.  {\cf Display} returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\begin{rationale}
{\cf Write} is intended
for producing mach\-ine-readable output and {\cf display} is for producing
human-readable output.  Implementations that allow ``slashification''
within symbols will probably want {\cf write} but not {\cf display} to
slashify funny characters in symbols.
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{library procedure}
\rproto{newline}{ port}{library procedure}}

Writes an end of line to \var{port}.  Exactly how this is done differs
from one operating system to another.  Returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{procedure}
\rproto{write-char}{ char port}{procedure}}

Writes the character \var{char} (not an external representation of the
character) to the given \var{port} and returns an unspecified value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}


\subsection{System interface}

Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


\begin{entry}{%
\proto{load}{ filename}{optional procedure}}

\todo{Fix}

%\domain{\var{Filename} should be a string naming an existing file
%containing Scheme source code.} The {\cf load} procedure reads
\var{Filename} should be a string naming an existing file
containing Scheme source code.  The {\cf load} procedure reads
expressions and definitions from the file and evaluates them
sequentially.  It is unspecified whether the results of the expressions
are printed.  The {\cf load} procedure does not affect the values
returned by {\cf current-input-port} and {\cf current-output-port}.
{\cf Load} returns an unspecified value.

\begin{rationale}
For portability, {\cf load} must operate on source files.
Its operation on other kinds of files necessarily varies among
implementations.
\end{rationale}
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
