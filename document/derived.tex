\chapter{Sample definitions for derived forms}
\label{derivedformsappendix}

This appendix contains sample definitions for some of the keywords
described in this report in terms of simpler forms:

\subsubsection*{{\tt cond}}
The {\cf cond} keyword (section~\ref{cond}) 
could be defined in terms of {\cf if}, {\cf let} and {\cf
  begin} using {\cf syntax-rules} (see
section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{cond}
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))
\end{scheme}
\subsubsection*{{\tt case}}
The {\cf case} keyword (section~\ref{case}) could be defined in terms of {\cf let}, {\cf cond}, and
{\cf memv} (see section~\ref{listutilities}) using {\cf syntax-rules}
(see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{case}
  (syntax-rules (else)
    ((case expr0
       ((key ...) res1 res2 ...)
       ...
       (else else-res1 else-res2 ...))
     (let ((tmp expr0))
       (cond
         ((memv tmp '(key ...)) res1 res2 ...)
         ...
         (else else-res1 else-res2 ...))))
    ((case expr0
       ((keya ...) res1a res2a ...)
       ((keyb ...) res1b res2b ...)
       ...)
     (let ((tmp expr0))
       (cond
         ((memv tmp '(keya ...)) res1a res2a ...)
         ((memv tmp '(keyb ...)) res1b res2b ...)
         ...)))))
\end{scheme}

\subsubsection*{{\tt letrec}}
The {\cf letrec} keyword (section~\ref{letrec})
could be defined approximately in terms of {\cf let}
and {\cf set!} using {\cf syntax-rules} (see
section~\ref{syntaxrulessection}), using a helper
to generate the temporary variables
needed to hold the values before the assignments are made,
as follows:

\begin{scheme}
(define-syntax \ide{letrec}
  (syntax-rules ()
    ((letrec () body1 body2 ...)
     (let () body1 body2 ...))
    ((letrec ((var init) ...) body1 body2 ...)
     (letrec-helper
       (var ...)
       ()
       ((var init) ...)
       body1 body2 ...))))

(define-syntax letrec-helper
  (syntax-rules ()
    ((letrec-helper
       ()
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (let ((var <undefined>) ...)
       (let ((temp init) ...)
         (set! var temp)
         ...)
       (let () body1 body2 ...)))
    ((letrec-helper
       (x y ...)
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (letrec-helper
       (y ...)
       (newtemp temp ...)
       ((var init) ...)
       body1 body2 ...))))
\end{scheme}

The syntax {\cf <undefined>} represents an expression that
returns something that, when stored in a location, causes an exception
with condition type {\cf\&contract} to
be raised if an attempt to read to or write from the location occurs before the
assignments generated by the {\cf letrec} transformation take place.
(No such expression is defined in Scheme.)

\subsubsection*{{\tt let-values}}
The following definition of {\cf let-values} (section~\ref{let-values})
using {\cf syntax-rules} (see section~\ref{syntaxrulessection})
employs a pair of helpers to
create temporary names for the formals.

\begin{scheme}
(define-syntax let-values
  (syntax-rules ()
    ((let-values (binding ...) body1 body2 ...)
     (let-values-helper1
       ()
       (binding ...)
       body1 body2 ...))))

(define-syntax let-values-helper1
  ;; map over the bindings
  (syntax-rules ()
    ((let-values
       ((id temp) ...)
       ()
       body1 body2 ...)
     (let ((id temp) ...) body1 body2 ...))
    ((let-values
       assocs
       ((formals1 expr1) (formals2 expr2) ...)
       body1 body2 ...)
     (let-values-helper2
       formals1
       ()
       expr1
       assocs
       ((formals2 expr2) ...)
       body1 body2 ...))))

(define-syntax let-values-helper2
  ;; create temporaries for the formals
  (syntax-rules ()
    ((let-values-helper2
       ()
       temp-formals
       expr1
       assocs
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda temp-formals
         (let-values-helper1
           assocs
           bindings
           body1 body2 ...))))
    ((let-values-helper2
       (first . rest)
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (let-values-helper2
       rest
       (temp ... newtemp)
       expr1
       (assoc ... (first newtemp))
       bindings
       body1 body2 ...))
    ((let-values-helper2
       rest-formal
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda (temp ... . newtemp)
         (let-values-helper1
           (assoc ... (rest-formal newtemp))
           bindings
           body1 body2 ...))))))
\end{scheme}

\subsubsection*{{\tt case-lambda}}

The {\cf case-lambda} keyword (see section~\ref{case-lambda})
could be defined in terms of base library by the following macros:
%
\begin{scheme}
(define-syntax \ide{case-lambda}
  (syntax-rules ()
    ((case-lambda
      (formals-0 body0-0 body1-0 ...)
      (formals-1 body0-1 body1-1 ...)
      ...)
     (lambda args
       (let ((l (length args)))
         (case-lambda-helper
          l args
          (formals-0 body0-0 body1-0 ...)
          (formals-1 body0-1 body1-1 ...) ...))))))

(define-syntax \ide{case-lambda-helper}
  (syntax-rules ()
    ((case-lambda-helper
      l args)
     (violation 'case-lambda
                "wrong number of arguments" l args))
    ((case-lambda-helper
      l args
      ((formal ...) body ...)
      clause ...)
     (if (= l (length '(formal ...)))
         (apply (lambda (formal ...) body ...)
                args)
         (case-lambda-helper l args clause ...)))
    ((case-lambda-helper
      l args
      ((formal . formals-rest) body ...)
      clause ...)
     (case-lambda-helper-dotted l args
                                (body ...)
                                (formal . formals-rest)
                                formals-rest 1
                                clause ...))
    ((case-lambda-helper
      l args
      (formal body ...))
     (let ((formal args))
       body ...))))

(define-syntax \ide{case-lambda-helper-dotted}
  (syntax-rules ()
    ((case-lambda-helper-dotted
      l args
      (body ...)
      formals
      (formal . formals-rest) k
      clause ...)
     (case-lambda-helper-dotted
      l args
      (body ...)
      formals
      formals-rest (+ 1 k)
      clause ...))
    ((case-lambda-helper-dotted
      l args
      (body ...)
      formals
      rest-formal k
      clause ...)
     (if (>= l k)
         (apply (lambda formals body ...) args)
         (case-lambda-helper
          l args clause ...)))))
\end{scheme}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
