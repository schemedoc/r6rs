\chapter{Miscellaneous libraries}
\label{misclibchapter}

\section{{\tt when} and {\tt unless}}

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\semantics A {\cf when} expression is evaluated by evaluating the
\hyper{test} expression.  If \hyper{test} evaluates to a true value,
the remaining \hyper{expression}s are evaluated in order, and the
result(s) of the last \hyper{expression} is(are) returned as the
result(s) of the entire {\cf when} expression.  Otherwise, the {\cf
  when} expression evaluates to the unspecified value.  An {\cf unless}
expression is evaluated by evaluating the \hyper{test} expression.
If \hyper{test} evaluates to false, the remaining
\hyper{expression}s are evaluated in order, and the result(s) of the
last \hyper{expression} is(are) returned as the result(s) of the
entire {\cf unless} expression.  Otherwise, the {\cf unless} expression
evaluates to the unspecified value.

\begin{scheme}
(when (> 3 2) 'greater) \ev greater
(when (< 3 2) 'greater) \ev \theunspecified
(unless (> 3 2) 'less) \ev \theunspecified
(unless (< 3 2) 'less) \ev less
\end{scheme}

The {\cf when} and {\cf unless} expressions are derived forms.  They
could be defined in terms of core language by the following macros:

\begin{scheme}
(define-syntax \ide{when}
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test
         (begin result1 result2 ...)))))

(define-syntax \ide{unless}
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))
\end{scheme}

\end{entry}

\section{{\tt case-lambda}}

\begin{entry}{%
\proto{case-lambda}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}
    
\syntax
Each \hyper{clause} should be of the form
%
\begin{scheme}
(\hyper{formals} \hyperi{body})%
\end{scheme}

\semantics A {\cf case-lambda} expression evaluates to a procedure.
This procedure, when applied, tries to match its arguments to the
\hyper{clause}s in order.  The arguments match a clause if one the
following conditions is fulfilled:
%
\begin{itemize}
\item \hyper{Formals} has the form {\tt (\hyper{variable} \dotsfoo)}
and the number of arguments is the same as the number of formal
parameters in \hyper{formals}.
\item \hyper{Formals} has the form\\ {\tt
(\hyperi{variable} \dotsfoo \hypern{variable} . \hyper{variable$_{n+1}$)}
}\\
and the number of arguments is at least $n$.
\item \hyper{Formals} has the form {\tt \hyper{variable}}.
\end{itemize}
%
For the first clause matched by the arguments, the variables of the
\hyper{formals} are bound to fresh locations containing the
argument values in the same arrangement as with {\cf lambda}.

If the arguments match none of the clauses, a violation is raised.
FIXME

\begin{scheme}
(define foo
  (case-lambda 
   (() 'zero)
   ((x) (list 'one x))
   ((x y) (list 'two x y))
   ((a b c d . e) (list 'four a b c d e))
   (rest (list 'rest rest))))

(foo) \ev zero
(foo 1) \ev (one 1)
(foo 1 2) \ev (two 1 2)
(foo 1 2 3) \ev (rest (1 2 3))
(foo 1 2 3 4) \ev (four 1 2 3 4 ())
\end{scheme}

The {\cf case-lambda} expression is a derived form.  It
could be defined in terms of core language by the following macros:
%
\begin{scheme}
(define-syntax \ide{case-lambda}
  (syntax-rules ()
    ((case-lambda
      (formals-0 body0-0 body1-0 ...)
      (formals-1 body0-1 body1-1 ...)
      ...)
     (lambda args
       (let ((l (length args)))
         (case-lambda-helper
          l args
          (formals-0 body0-0 body1-0 ...)
          (formals-1 body0-1 body1-1 ...) ...))))))

(define-syntax \ide{case-lambda-helper}
  (syntax-rules ()
    ((case-lambda-helper
      l args)
     (violation 'case-lambda
                "wrong number of arguments" l args))
    ((case-lambda-helper
      l args
      ((formal ...) body ...)
      clause ...)
     (if (= l (length '(formal ...)))
         (apply (lambda (formal ...) body ...)
                args)
         (case-lambda-helper l args clause ...)))
    ((case-lambda-helper
      l args
      ((formal . formals-rest) body ...)
      clause ...)
     (case-lambda-helper-dotted l args
                                (body ...)
                                (formal . formals-rest)
                                formals-rest 1
                                clause ...))
    ((case-lambda-helper
      l args
      (formal body ...))
     (let ((formal args))
       body ...))))

(define-syntax \ide{case-lambda-helper-dotted}
  (syntax-rules ()
    ((case-lambda-helper-dotted
      l args
      (body ...)
      formals
      (formal . formals-rest) k
      clause ...)
     (case-lambda-helper-dotted
      l args
      (body ...)
      formals
      formals-rest (+ 1 k)
      clause ...))
    ((case-lambda-helper-dotted
      l args
      (body ...)
      formals
      rest-formal k
      clause ...)
     (if (>= l k)
         (apply (lambda formals body ...) args)
         (case-lambda-helper
          l args clause ...)))))
\end{scheme}
\end{entry}

\section{Delayed evaluation}

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{\exprtype}}

\todo{Fix.}

The {\cf delay} construct is used together with the procedure \ide{force} to
implement \defining{lazy evaluation} or \defining{call by need}.
{\tt(delay~\hyper{expression})} returns an object called a
\defining{promise} which at some point in the future may be asked (by
the {\cf force} procedure) \todo{Bartley's white lie; OK?} to evaluate
\hyper{expression}, and deliver the resulting value.
The effect of \hyper{expression} returning multiple values
is unspecified.

See the description of {\cf force} (section~\ref{force}) for a
more complete description of {\cf delay}.

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{procedure}}

Forces the value of \var{promise} (see \ide{delay},
section~\ref{delay}).\index{promise}  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned.
% without any recomputation.
% [As pointed out by Marc Feeley, the "without any recomputation"
% isn't necessarily true. --Will]

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                               \ev  2%
\end{scheme}

{\cf Force} and {\cf delay} are mainly intended for programs written in
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.
% the value of a promise is computed at most once.
% [As pointed out by Marc Feeley, it may be computed more than once,
% but as I observed we can at least insist that only one value be
% used! -- Will]

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Here is a possible implementation of {\cf delay} and {\cf force}.
Promises are implemented here as procedures of no arguments,
and {\cf force} simply calls its argument:

\begin{scheme}
(define force
  (lambda (object)
    (object)))%
\end{scheme}

We define the expression

\begin{scheme}
(delay \hyper{expression})%
\end{scheme}

to have the same meaning as the procedure call

\begin{scheme}
(make-promise (lambda () \hyper{expression}))\rm
\end{scheme}

as follows

\begin{scheme}
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression))))),%
\end{scheme}

where {\cf make-promise} is defined as follows:

% \begin{scheme}
% (define make-promise
%   (lambda (proc)
%     (let ((already-run? \schfalse) (result \schfalse))
%       (lambda ()
%         (cond ((not already-run?)
%                (set! result (proc))
%                (set! already-run? \schtrue)))
%         result))))%
% \end{scheme}

\begin{scheme}
(define make-promise
  (lambda (proc)
    (let ((result-ready? \schfalse)
          (result \schfalse))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? \schtrue)
                         (set! result x)
                         result))))))))%
\end{scheme}

\begin{rationale}
A promise may refer to its own value, as in the last example above.
Forcing such a promise may cause the promise to be forced a second time
before the value of the first force has been computed.
This complicates the definition of {\cf make-promise}.
\end{rationale}

Various extensions to this semantics of {\cf delay} and {\cf force}
are supported in some implementations:

\begin{itemize}
\item Calling {\cf force} on an object that is not a promise may simply
return the object.

\item It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either \schtrue{} or to \schfalse{},
depending on the implementation:

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Some implementations may implement ``implicit forcing,'' where
the value of a promise is forced by primitive procedures like \cf{cdr}
and \cf{+}:

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  34%
\end{scheme}
\end{itemize}
\end{entry}

\input{list}

\input{hashtable}

\input{enum}

\input{bytes}

\input{eval}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 



