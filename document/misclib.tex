\chapter{Miscellaneous libraries}
\label{misclibchapter}

\section{{\tt when} and {\tt unless}}

This section describes the \deflibrary{r6rs when-unless} library.

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax \hyper{Test} must be an expression.
\semantics A {\cf when} expression is evaluated by evaluating the
\hyper{test} expression.  If \hyper{test} evaluates to a true value,
the remaining \hyper{expression}s are evaluated in order, and the
results of the last \hyper{expression} are returned as the
results of the entire {\cf when} expression.  Otherwise, the {\cf
	  when} expression evaluates to the unspecified value.  An {\cf unless}
expression is evaluated by evaluating the \hyper{test} expression.
If \hyper{test} evaluates to false, the remaining
\hyper{expression}s are evaluated in order, and the results of the
last \hyper{expression} are returned as the results of the
entire {\cf unless} expression.  Otherwise, the {\cf unless} expression
evaluates to the unspecified value.

\begin{scheme}
(when (> 3 2) 'greater) \ev greater
(when (< 3 2) 'greater) \ev \theunspecified
(unless (> 3 2) 'less) \ev \theunspecified
(unless (< 3 2) 'less) \ev less
\end{scheme}

The {\cf when} and {\cf unless} expressions are derived forms.  They
could be defined in terms of base library forms by the following macros:

\begin{scheme}
(define-syntax \ide{when}
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test
         (begin result1 result2 ...)))))

(define-syntax \ide{unless}
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))
\end{scheme}

\end{entry}

\section{{\tt case-lambda}}

This section describes the \deflibrary{r6rs case-lambda} library.

\begin{entry}{%
\proto{case-lambda}{ \hyper{clause} \dotsfoo}{\exprtype}}
    
\syntax
Each \hyper{clause} should be of the form
%
\begin{scheme}
(\hyper{formals} \hyper{body})%
\end{scheme}

\hyper{Formals} must be as in a {\cf lambda} form
(report section~\extref{report:lambda}{Procedures}), \hyper{body} must be a body according to
report section~\extref{report:bodiessection}{Bodies and sequences}.

\semantics A {\cf case-lambda} expression evaluates to a procedure.
This procedure, when applied, tries to match its arguments to the
\hyper{clause}s in order.  The arguments match a clause if one of the
following conditions is fulfilled:
%
\begin{itemize}
\item \hyper{Formals} has the form {\tt (\hyper{variable} \dotsfoo)}
and the number of arguments is the same as the number of formal
parameters in \hyper{formals}.
\item \hyper{Formals} has the form\\ {\tt
(\hyperi{variable} \dotsfoo \hypern{variable} . \hyper{variable$_{n+1}$)}
}\\
and the number of arguments is at least $n$.
\item \hyper{Formals} has the form {\tt \hyper{variable}}.
\end{itemize}
%
For the first clause matched by the arguments, the variables of the
\hyper{formals} are bound to fresh locations containing the
argument values in the same arrangement as with {\cf lambda}.

If the arguments match none of the clauses, an exception with condition 
type {\cf\&assertion} is raised.

\begin{scheme}
(define foo
  (case-lambda 
   (() 'zero)
   ((x) (list 'one x))
   ((x y) (list 'two x y))
   ((a b c d . e) (list 'four a b c d e))
   (rest (list 'rest rest))))

(foo) \ev zero
(foo 1) \ev (one 1)
(foo 1 2) \ev (two 1 2)
(foo 1 2 3) \ev (rest (1 2 3))
(foo 1 2 3 4) \ev (four 1 2 3 4 ())
\end{scheme}

The {\cf case-lambda} keyword
can be defined in terms of {\cf lambda} by the following macros:
%
\begin{scheme}
(define-syntax \ide{case-lambda}
  (syntax-rules ()
    ((\_ (fmls b1 b2 ...))
     (lambda fmls b1 b2 ...))
    ((\_ (fmls b1 b2 ...) ...)
     (lambda args
       (let ((n (length args)))
         (case-lambda-help args n
           (fmls b1 b2 ...) ...))))))

(define-syntax \ide{case-lambda-help}
  (syntax-rules ()
    ((\_ args n)
     (assertion-violation \schfalse{}
       "unexpected number of arguments"))
    ((\_ args n ((x ...) b1 b2 ...) more ...)
     (if (= n (length '(x ...)))
         (apply (lambda (x ...) b1 b2 ...) args)
         (case-lambda-help args n more ...)))
    ((\_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
     (if (>= n (length '(x1 x2 ...)))
         (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                   args)
         (case-lambda-help args n more ...)))
    ((\_ args n (r b1 b2 ...) more ...)
     (apply (lambda r b1 b2 ...) args))))
\end{scheme}
\end{entry}


\input{programlib}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
