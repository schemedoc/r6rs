\section{Port I/O}
\label{portsiosection}

\begin{note}
{\bf FIXME:} File names, {\cf file-options}, and the replacements for
readers and writers have not yet been folded in.
Furthermore, this section still refers to bytes objects,
not bytevectors.
\end{note}

The \deflibrary{r6rs i/o ports} library defines an I/O layer for
conventional, imperative buffered input and output.
A \defining{port} represents a buffered access object
for a data sink or source or both simultaneously.
The library allows ports to be created from arbitrary input sources
and sinks.

The \library{r6rs i/o ports} library distinguishes between \textit{input
  ports\mainindex{input port}} and \textit{output
  ports\mainindex{output ports}}.  An input port is a source for data,
whereas an output port is a sink for data.  A port may be both an
input port and an output port; such a port typically provides
simultaneous read and write access to a file or other data.

The \library{r6rs i/o ports} library also distinguishes between
\textit{binary ports\mainindex{binary port}}, which are sources
or sinks for uninterpreted bytes, and
\textit{textual ports\mainindex{textual ports}}, which are sources
or sinks for characters and strings.

This section uses \var{input-port}, \var{output-port},
\var{binary-port}, \var{textual-port},
\var{binary-input-port}, \var{textual-input-port},
\var{binary-output-port}, \var{textual-output-port},
and \var{port} as
parameter names for arguments that must be input ports (or combined
input/output ports), output ports (or combined input/output ports),
binary ports, textual ports, binary input ports, textual input ports,
binary output ports, textual output ports, or any kind of port,
respectively.

\subsection{Condition type}

This library introduces the following condition type:

\begin{entry}{%
\ctproto{i/o-port}
\proto{i/o-port-error?}{ obj}{procedure}
\proto{i/o-error-port}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-port \&i/o
  i/o-port-error?
  (port i/o-error-port))
\end{scheme}

This condition type allows specifying with what particular port an I/O
error is associated. Except for condition objects provided for
encoding and decoding errors, conditions raised by procedures may
include an {\cf\&i/o-port-error} condition, but are not required to do
so.
\end{entry}

\subsection{Buffer modes}

Each output port has an associated buffer mode that defines when an
output operation flushes the buffer associated with the output
port. The possible buffer modes are the symbols {\cf none} for no buffering,
{\cf line} for flushing upon line feeds and line separators (U+2028), and
{\cf block} for arbitrary buffering.  This section uses the parameter name
\var{buffer-mode} for arguments that must be buffer-mode symbols.

\begin{entry}{%
\proto{buffer-mode}{ \hyper{name}}{\exprtype}}
   
\hyper{Name} must be one of the \meta{identifier}s {\cf none}, {\cf line}, or
{\cf block}. The result is the corresponding symbol, denoting the
associated buffer mode.

It is a syntax violation if \hyper{name} is not one of the valid
identifiers.
\end{entry}

\begin{entry}{%
\proto{buffer-mode?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a valid buffer-mode symbol,
\schfalse{} otherwise.
\end{entry}

\subsection{Transcoders}

Several different Unicode encoding schemes describe standard ways to
encode characters and strings as byte sequences and to decode those
sequences~\cite{Unicode}.
Within this document, a \defining{codec} is an immutable Scheme
object that represents a Unicode or similar encoding scheme.

A \defining{transcoder} is an immutable Scheme object that combines
a codec with an end-of-line convention and a method for handling
decoding errors.
Each transcoder represents some specific bidirectional (but not
necessarily lossless), possibly stateful translation between byte
sequences and Unicode characters and strings.
Every transcoder can operate in the input direction (bytes to characters)
or in the output direction (characters to bytes),
but the composition of those directions need not be identity (and
often isn't).  The composition of two transcoders is not defined.
A \var{transcoder} parameter name means that the corresponding
argument must be a transcoder.

Every port has a single transcoder associated with it.

A binary port is defined as a port whose associated transcoder
is the \defining{binary transcoder}, which is a special
pseudo-transcoder whose input and output directions translate
no byte sequences to characters, and no character sequences to
bytes.

A textual port is defined as a port whose associated transcoder
is not the binary transcoder.

\begin{entry}{%
\proto{latin-1-codec}{}{procedure}
\proto{utf-8-codec}{}{procedure}
\proto{utf-16-codec}{}{procedure}
\proto{utf-32-codec}{}{procedure}}

These are predefined codecs for the ISO 8859-1, UTF-8,
UTF-16, and UTF-32 encoding schemes \cite{Unicode}.

A call to any of these procedures returns a value that is equal in the
sense of {\cf eqv?} to the result of any other call to the same
procedure.
\end{entry}

\begin{entry}{%
\proto{eol-style}{ name}{\exprtype}}

If \var{name} is one of the \meta{identifier}s {\cf lf}, {\cf cr},
{\cf crlf}, or {\cf ls}, then the form evaluates to the corresponding
symbol.  If \var{name} is not one of these identifiers, effect and
result are implementation-dependent: The result may be an
eol-style symbol acceptable as an \var{eol-mode}
argument to {\cf make-transcoder}.  Otherwise, an exception is raised.

\begin{rationale}
  End-of-line styles other than those listed might become commonplace
  in the future.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{native-eol-style}{}{procedure}}

Returns the default end-of-line style of the underlying platform, e.g.
{\cf lf} on Unix and {\cf crlf} on Windows.
\end{entry}

\begin{entry}{%
\ctproto{i/o-decoding}
\proto{i/o-decoding-error?}{ obj}{procedure}}

\begin{scheme}
(define-condition-type \&i/o-decoding \&i/o-port
  i/o-decoding-error?
  (transcoder i/o-decoding-error-transcoder))
\end{scheme}

An exception with this type is raised when one of the operations for
textual input from a port encounters a sequence of bytes that cannot
be translated into a character or string by the input direction of the
port's transcoder.  The {\cf transcoder} field contains the port's
transcoder.

Exceptions of this type raised by the operations described in this
section are continuable.
When such an exception is raised, the port's position is at
the beginning of the invalid encoding.
If the exception handler returns, it must
return a character or string representing the decoded text starting at
the port's current position, and the exception handler must update the 
port's position to point past the error.
\end{entry}

\begin{entry}{% 
\ctproto{i/o-encoding}
\proto{i/o-encoding-error?}{ obj}{procedure}
\proto{i/o-encoding-error-char}{ condition}{procedure}
\proto{i/o-encoding-error-transcoder}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-encoding \&i/o-port
  i/o-encoding-error?
  (char i/o-encoding-error-char)
  (transcoder i/o-encoding-error-transcoder))
\end{scheme}

An exception with this type is raised when one of the operations for
textual output to a port encounters a character that cannot be
translated into bytes by the output direction of the port's transcoder.
The {\cf char} field of the
condition object contains the character that could not be encoded,
and the {\cf transcoder} field contains the transcoder associated
with the port.

Exceptions of this type raised by the operations described in this
section are continuable.  The handler, if it returns, is expected to
output to the port an appropriate encoding for the character that
caused the error.  The operation that raised the exception 
continues after that character.
\end{entry}

\begin{entry}{%
\proto{error-handling-mode}{ name}{\exprtype}}

If \var{name} is one of the \meta{identifier}s {\cf ignore}, {\cf
  raise}, or {\cf replace}, then the result is the corresponding
symbol.  If \var{name} is not one of these identifiers, effect and
result are implementation-dependent: The result may be an
error-handling-mode symbol acceptable as a \var{handling-mode}
argument to {\cf make-transcoder}.  Otherwise, an exception is raised.

\begin{rationale}
  Implementations may support error-handling modes other than those
  listed.
\end{rationale}

The error-handling mode of a transcoder specifies the behavior
of textual I/O operations in the presence of encoding or decoding
errors.

If a textual input operation encounters an invalid or incomplete
character encoding, and the error-handling mode is {\cf ignore},
then the first byte of the
invalid encoding is ignored and decoding continues with the next
byte.
If the error-handling mode is {\cf replace}, then the replacement
character U+FFFD is injected into the data stream and decoding
continues with the next byte.
If the error-handling mode is {\cf raise}, then a continuable
exception with condition type {\cf\&i/o-decoding} is raised;
see the description of
{\cf\&i/o-decoding} for details
on how to handle such an exception.

If a textual output operation encounters a character it cannot encode,
and the error-handling mode is {\cf ignore}, then the character is
ignored and encoding continues with the next character.
If the error-handling mode is {\cf replace}, a codec-specific
replacement character is emitted by the transcoder, and encoding
continues with the next character.
The replacement character is U+FFFD for transcoders whose codec
is one of the Unicode encodings, but is the {\cf ?}
character for the Latin-1 encoding.
If the error-handling mode is {\cf raise}, an
exception with condition type {\cf\&i/o-encoding} is raised;
see the description of
{\cf\&i/o-decoding} for details
on how to handle such an exception.
\end{entry}

\begin{entry}{%
\proto{make-transcoder}{ codec eol-style handling-mode}{procedure}
\rproto{make-transcoder}{ codec eol-style}{procedure}
\rproto{make-transcoder}{ codec}{procedure}}

\domain{\var{Codec} must be a codec; \var{eol-style}, if present, an
  eol-style symbol; and \var{handling-mode}, if present, an
  error-handling-mode symbol.}  \var{eol-style} may be omitted, in
which case it defaults to the native end-of-line style of the
underlying platform.  \var{handling-mode} may be omitted, in which
case it defaults to {\cf raise}.  The result is a transcoder with the
behavior specified by its arguments.

A transcoder returned by {\cf make-transcoder} is equal in the sense
of {\cf eqv?} to any other transcoder returned by {\cf
  make-transcoder}, if and only if the \var{code}, \var{eol-style},
and \var{handling-mode} arguments are equal in the sense of {\cf
  eqv?}.
\end{entry}

\begin{entry}{%
\proto{binary-transcoder}{}{procedure}}

Returns the binary transcoder, which is equal in the sense of
{\cf eqv?} (but not necessarily in the sense of {\cf eq?}) to
the result of any other call to {\cf binary-transcoder}, and
is not equal to the result of any call to {\cf make-transcoder}.
\end{entry}

\begin{entry}{%
\proto{transcoder-codec}{ transcoder}{procedure}
\proto{transcoder-eol-style}{ transcoder}{procedure}
\proto{transcoder-error-handling-mode}{ transcoder}{procedure}}

These are accessors for transcoder objects; when applied to a
transcoder returned by {\cf make-transcoder}, they return the
\var{codec}, \var{eol-style}, \var{handling-mode} arguments.
When applied to the binary transcoder, they return \schfalse{}.
\end{entry}

\subsection{Input and output ports}

The operations described in this section are common to input and
output ports, both binary and textual.
Every port is associated with a transcoder;
the transcoder of a binary port is the binary transcoder, and
the transcoder of a textual port is not the binary transcoder.
A port may also have an associated \defining{position} that
specifies a particular place within its data sink or source as a byte
count from the beginning of the sink or source, and operations for
inspecting and setting that place.
(Ends of file do not count as bytes.)

\begin{entry}{%
\proto{port?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a port, and returns \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{port-transcoder}{ port}{procedure}}

Returns the transcoder associated with \var{port}.
\end{entry}

\begin{entry}{%
\proto{binary-port?}{ port}{procedure}}

Returns \schtrue{} if the transcoder associated with the \var{port}
is the binary transducer, and returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{port-has-port-position?}{ port}{procedure}
\proto{port-position}{ port}{procedure}}

The {\cf port-has-port-position?} procedure returns \schtrue{} if the
port supports the {\cf port-position} operation, and \schfalse{}
otherwise.

The {\cf port-position} procedure
returns the exact non-negative integer index of the position at which the
next byte would be read from or written to the port.
This procedure raises an exception with condition type {\cf\&assertion}
if the port does not support the operation.
\end{entry}   

\begin{entry}{%
\proto{port-has-set-port-position!?}{ port}{procedure}
\proto{set-port-position!}{ port pos}{procedure}}

\domain{\var{Pos} must be a non-negative exact integer.}
   
The {\cf port-has-set-port-position?} procedure returns \schtrue{} if the port
supports the {\cf set-port-position!} operation, and \schfalse{}
otherwise.
   
The {\cf set-port-position!} procedure sets the current byte position
of the port to \var{pos}.  If \var{port} is an output or combined
input and output port, this first flushes \var{port}.  (See {\cf
  flush-output-port}, section~\ref{flush-output-port}.)
This procedure raises an exception with condition type {\cf\&assertion}
if the port does not support the operation.
\end{entry}

\begin{entry}{%
\proto{close-port}{ port}{procedure}}
   
Closes the port, rendering the port incapable of delivering or
accepting data. If \var{port} is an output port, it is flushed before
being closed.  This has no effect if the port has already been closed.
A closed port is still a port. The unspecified value is returned.
\end{entry}

\begin{entry}{%
\proto{call-with-port}{ port proc}{procedure}}
   
\domain{\var{Proc} must be a procedure that accepts a single
  argument.}  The {\cf call-with-port} procedure
calls \var{proc} with \var{port} as an argument. If
\var{proc} returns, then the \var{port} is closed automatically and
the values returned by \var{proc} are returned. If \var{proc} does not
return, then the port is not closed automatically, except perhaps when it is
possible to prove that the port will never again be used for a
{\cf lookahead}, {\cf get}, or {\cf put} operation.
\end{entry}

\subsection{Input ports}

An input port allows reading an infinite sequence of bytes
or characters punctuated
by end of file objects. An input port connected to a finite data
source ends in an infinite sequence of end of file objects.

It is unspecified whether a character encoding consisting of several
bytes may have an end of file between the bytes.  If, for example,
{\cf get-char} raises an {\cf\&i/o-decoding} exception because the
character encoding at the port's position is incomplete up to the next
end of file, a subsequent call to {\cf get-char} may successfully
decode a character if bytes completing the encoding are available
after the end of file.

\begin{entry}{%
\proto{input-port?}{ obj}{procedure}}

Returns \schtrue{} if the argument is an input port (or a combined input
and output port), and returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{port-eof?}{ input-port}{procedure}}
   
Returns \schtrue{}
if the {\cf lookahead-u8} procedure (if \var{input-port} is a binary port)
or the {\cf lookahead-char} procedure (if \var{input-port} is a textual port)
would return
the end-of-file object, and returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{open-file-input-port}{ filename}{procedure}
\rproto{open-file-input-port}{ filename file-options}{procedure}
\rproto{open-file-input-port}{ filename file-options transcoder}{procedure}}
   
Returns an input port for the named file. The \var{file-options} and
\var{transcoder} arguments are optional.

The \var{file-options} argument, which may determine
various aspects of the returned port (see section~\ref{fileoptionssection}),
defaults to {\cf (file-options)}.

If \var{transcoder} is specified, it becomes the transcoder associated
with the returned port.
If no \var{transcoder} is specified, then an implementation-dependent
(and possibly locale-dependent) transcoder is associated with the port.

If the binary transcoder is passed as an explicit argument,
then the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
will be implementation-dependent (and possibly transcoder-dependent).
\begin{rationale}
  The byte position of a complexly transcoded port may not be
  well-defined, and may be hard to calculate even when defined,
  especially when transcoding is buffered.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{open-bytes-input-port}{ bytes}{procedure}
\rproto{open-bytes-input-port}{ bytes transcoder}{procedure}}
   
Returns an input port whose bytes are drawn from the
bytes object \var{bytes}.
If \var{transcoder} is specified, it becomes the transcoder associated
with the returned port.

If no \var{transcoder} argument is given, or
if the binary transcoder is passed as an explicit argument,
then the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
will be implementation-dependent (and possibly transcoder-dependent).

If \var{bytes} is modified after {\cf open-bytes-input-port}
has been called, the effect on the returned
port is unspecified.
\end{entry}

\begin{entry}{%
\proto{open-string-input-port}{ string}{procedure}}

Returns a textual input port whose characters are drawn from
\var{string}.  The port's transcoder is implementation-dependent,
but is not the binary transcoder.
Whether the port supports
the {\cf port-position} and {\cf set-port-position!} operations
is implementation-dependent.

If \var{string} is modified after {\cf open-string-input-port}
has been called, the effect on the returned port is unspecified.
\end{entry}

\begin{entry}{%
\proto{standard-input-port}{}{procedure}}
   
Returns an input port connected to standard input, possibly a fresh
one on each call.
Whether the port is binary or textual is implementation-dependent,
as is whether the port supports
the {\cf port-position} and {\cf set-port-position!} operations.

\begin{note}
  Implementations are encouraged to return a textual port when
  appropriate, and
  to associate an appropriate transcoder with the port.
\end{note}
\end{entry}

\subsection{Binary input}

\begin{entry}{%
\proto{get-u8}{ binary-input-port}{procedure}}
   
Reads from \var{binary-input-port}, blocking as necessary, until data is
available from \var{binary-input-port} or until an end of file is reached.
If a byte becomes available, {\cf get-u8} returns the byte as an octet, and
updates \var{binary-input-port} to point just past that byte. If no input
byte is seen before an end of file is reached, then the end-of-file
object is returned.
\end{entry}

\begin{entry}{%
\proto{lookahead-u8}{ binary-input-port}{procedure}}
   
The {\cf lookahead-u8} procedure is like {\cf get-u8}, but it does not 
update \var{binary-input-port} to point past the byte.
\end{entry}

\begin{entry}{%
\proto{get-bytes-n}{ binary-input-port k}{procedure}}
   
Reads from \var{binary-input-port}, blocking as necessary, until \var{k}
bytes are available from \var{binary-input-port} or until an end of file is
reached. If \var{k} or more bytes are available before an end
of file, {\cf get-bytes-n} returns a bytes object of size \var{k}.
If fewer bytes are available before an end of file, {\cf get-bytes-n}
returns a bytes object
containing those bytes. In either case, the input port is updated to
point just past the bytes read.  If an end of file is reached before
any bytes are available, {\cf get-bytes-n} returns the end-of-file object.
\end{entry}

\begin{entry}{%
\proto{get-bytes-n!}{ binary-input-port bytes start count}{procedure}}
   
\domain{\var{Count} must be an exact, non-negative integer, specifying
  the number of bytes to be read. \var{bytes} must be a bytes object with at
  least $\var{start} + \var{count}$ elements.}
   
The {\cf get-bytes-n!} procedure reads from \var{binary-input-port},
blocking as necessary, until
\var{count} bytes are available from \var{binary-input-port} or until
an end of file is
reached. If \var{count} or more bytes are available before an end of file,
they are written into \var{bytes} starting at index \var{start}, and
the result is \var{count}. If fewer bytes are available before
the next end of file, the available bytes are written into \var{bytes}
starting at index \var{start}, and the result is the number of bytes actually
read. In either case, the input port is updated to point just past the
data read. If an end of file is reached before any bytes
are available, {\cf get-bytes-n!} returns the end-of-file object.
\end{entry}

\begin{entry}{%
\proto{get-bytes-some}{ binary-input-port}{procedure}}
   
Reads from \var{binary-input-port}, blocking as necessary, until data is
available from \var{binary-input-port} or until an end of file is reached.
If data becomes available, {\cf get-bytes-some} returns a freshly allocated
bytes object of non-zero size containing the available data, and it updates
\var{binary-input-port} to point just past that data.
If no input bytes are seen before an end
of file is reached, then the end-of-file object is returned.
\end{entry}

\begin{entry}{%
\proto{get-bytes-all}{ binary-input-port}{procedure}}
   
Attempts to read all data until the next end of file, blocking as
necessary. If one or more bytes are read, {\cf get-bytes-all} returns
a bytes object
containing all bytes up to the next end of file.  Otherwise, {\cf
  get-bytes-all} returns the end-of-file object. Note that  {\cf get-bytes-all}
may block indefinitely, waiting to see an end of
file, even though some bytes are available.
\end{entry}

\subsection{Textual input}

\begin{entry}{%
\proto{get-char}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port}, blocking as necessary, until the
complete encoding for a character is available from \var{textual-input-port},
or until the available input data cannot be the prefix of any valid encoding,
or until an end of file is reached.

If a complete character is available before the next end of file, {\cf
  get-char} returns that character, and updates the input port to
point past the data that encoded that character. If an end of file is
reached before any data are read, then {\cf get-char} returns the
end-of-file object.
\end{entry}

\begin{entry}{%
\proto{lookahead-char}{ textual-input-port}{procedure}}
  
The {\cf lookahead-char} procedure is like {\cf get-char}, but it does not 
update \var{textual-input-port} to point past the data
that encode the character.

\begin{note}
  With some of the standard transcoders
  described in this document, up to four bytes of lookahead are
  required. Nonstandard transcoders may require even more lookahead.
\end{note}
\end{entry}

\begin{entry}{%
\proto{get-string-n}{ textual-input-port k}{procedure}}
   
Reads from \var{textual-input-port}, blocking as necessary, until the
encodings of \var{k} characters (including invalid encodings, if they
don't raise an exception) are available, or until an end of
file is reached.
   
If \var{k} or more characters are read before end of file, {\cf
  get-string-n} returns a string consisting of those \var{k}
characters. If fewer characters are available before an end of file,
but one or more characters can be read,
{\cf get-string-n} returns a string containing
those characters. In either case, the input port is updated to point
just past the data read. If no data can be read before an 
end of file, then the end-of-file object is returned.
\end{entry}

\begin{entry}{%
\proto{get-string-n!}{ textual-input-port string start count}{procedure}}

\domain{\var{Start} and \var{count} must be an exact, non-negative
  integer, specifying the number of characters to be read.
  \var{string} must be a string with at least $\var{start} +
  \var{count}$ characters.}

Reads from \var{textual-input-port} in the same manner as {\cf
  get-string-n}.  If \var{count} or more characters are available
before an end of file, they are written into string
starting at index \var{start}, and \var{count} is returned. If fewer
characters are available before an end of file, but one
or more can be read, then those characters are written into string
starting at index \var{start}, and the number of characters actually read is
returned. If no characters can be read before an end of file,
then the end-of-file object is returned.
\end{entry}   

\begin{entry}{%
\proto{get-string-all}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port} until an end of file, decoding
characters in the same manner as {\cf get-string-n} and {\cf get-string-n!}.
   
If data are available before the end of file, a string
containing all the text decoded from that data is returned. If no data
precede the end of file, the end-of-file object file object is
returned.
\end{entry}

\begin{entry}{%
\proto{get-line}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port} up to and including the next
end-of-line encoding or line separator character (U+2028) or 
end of file, decoding characters in the same manner as {\cf
  get-string-n} and {\cf get-string-n!}.
   
If an end-of-line encoding or line separator is read, then a string
containing all of the text up to (but not including) the end-of-line
encoding is returned, and the port is updated to point just past the
end-of-line encoding or line separator. If an end of file is
encountered before any end-of-line encoding is read, but some data
have been read and decoded as characters, then a string containing
those characters is returned. If an end of file is encountered before
any data are read, then the end-of-file object is
returned.
\end{entry}

\begin{entry}{%
\proto{get-datum}{ textual-input-port}{procedure}}
 
Reads an external representation from \var{textual-input-port} and returns the
datum it represents.  The {\cf get-datum} procedure returns the next
datum parsable from the given \var{textual-input-port}, updating
\var{textual-input-port} to point exactly past the end of the external
representation of the object.

Any \meta{interlexeme space}
(see report section~\ref{report:lexicalsyntaxsection}) in
the input is first skipped.  If an end of file occurs after the
\meta{interlexeme space}, the end of file object (see
report section~\ref{report:eofsection}) is returned.

If a character inconsistent with an external representation is
encountered in the input, an exception with condition types
{\cf\&lexical} and {\cf\&i/o-read} is raised.
Also, if the end of file is encountered
after the beginning of an external representation, but the external
representation is incomplete and therefore not parsable, an exception
with condition types {\cf\&lexical} and {\cf\&i/o-read} is raised.
\end{entry}

\subsection{Output ports}

An output port is a sink to which bytes or characters are written.
These data may control
external devices, or may produce files and other objects that may
subsequently be opened for input.

\begin{entry}{%
\proto{output-port?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is an output port (or a
combined input and output port), and returns \schfalse{} otherwise.
\end{entry}   

\begin{entry}{%
\proto{flush-output-port}{ output-port}{procedure}}
   
Flushes any output from the buffer of \var{output-port} to the
underlying file, device, or object. The unspecified value is returned.
\end{entry}

\begin{entry}{%
\proto{output-port-buffer-mode}{ output-port}{procedure}}
   
Returns the symbol that represents the buffer-mode of
\var{output-port}.
\end{entry}

\begin{entry}{%
\proto{open-file-output-port}{ filename}{procedure}
\rproto{open-file-output-port}{ filename file-options}{procedure}
\rproto{open-file-output-port}{ filename file-options transcoder}{procedure}}

Returns an output port for the named file.

The \var{file-options} argument, which may determine
various aspects of the returned port (see section~\ref{fileoptionssection}),
defaults to {\cf (file-options)}.

If \var{transcoder} is specified, it becomes the transcoder associated
with the returned port.
If no \var{transcoder} is specified, then an implementation-dependent
(and possibly locale-dependent) transcoder is associated with the port.

If the binary transcoder is passed as an explicit argument,
then the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
will be implementation-dependent (and possibly transcoder-dependent).
\begin{rationale}
  The byte position of a complexly transcoded port may not be
  well-defined, and may be hard to calculate even when defined,
  especially when transcoding is buffered.
\end{rationale}
\end{entry}   

\begin{entry}{%
\proto{open-bytes-output-port}{}{procedure}
\rproto{open-bytes-output-port}{ transcoder}{procedure}}

Returns an output port that accumulates a bytes object from the
output written to it.  If \var{transcoder} is specified, it becomes
the transcoder associated with the returned port.

If no \var{transcoder} argument is given, or
if the binary transcoder is passed as an explicit argument,
then the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
will be implementation-dependent (and possibly transcoder-dependent).
\end{entry}

\begin{entry}{%
\proto{call-with-bytes-output-port}{ proc}{procedure}
\rproto{call-with-bytes-output-port}{ proc transcoder}{procedure}}

\domain{\var{Proc} must be a procedure accepting one argument.}
Creates an output port that accumulates a bytes object from the output
written to it, and calls \var{proc} with that output port as an
argument. When \var{proc} returns for the first time, the port is
closed and the bytes object associated with the port is returned.  If
\var{transcoder} is specified, it becomes the transcoder associated
with the port.

The transcoder associated with the output port is determined
as for a call to {\cf open-bytes-output-port}.
\end{entry}

\begin{entry}{%
\proto{get-output-bytes}{ output-port}{procedure}}

\domain{\var{Output-port} must be a port that accumulates a bytes
  object from the output written to it, such as the ports created by
  {\cf open-bytes-output-port} and {\cf call-with-bytes-output-port}.}
Returns a newly created bytes object containing the output that has
been accumulated by \var{output-port} so far.
If the returned bytes object is modified, the
the effect on \var{output-port} is unspecified.
\end{entry}

\begin{entry}{%
\proto{clear-bytes-output-port!}{ output-port}{procedure}}

\domain{\var{Output-port} must be a port that accumulates a bytes
  object from the output written to it, such as the ports created by
{\cf open-bytes-output-port} and {\cf call-with-bytes-output-port}.}
The {\cf clear-bytes-output-port!} procedure removes all bytes that
have been accumulated by \var{output-port} so far.
\end{entry}

\begin{entry}{%
\proto{open-string-output-port}{ proc}{procedure}}

Returns an output port that accumulates a string from the
characters written to it.
The port's transcoder is implementation-dependent,
but is not the binary transcoder.
Whether the port supports
the {\cf port-position} and {\cf set-port-position!} operations
is implementation-dependent.
\end{entry}

\begin{entry}{%
\proto{call-with-string-output-port}{ proc}{procedure}
\rproto{call-with-string-output-port}{ proc transcoder}{procedure}}

\domain{\var{Proc} must be a procedure accepting one argument.}
Creates a textual output port that accumulates a string from the
characters written to it, and calls \var{proc} with that output port
as an argument. When \var{proc} returns for the first time, the port is
closed and a newly created string consisting of the accumulated
characters is returned.  If
\var{transcoder} is specified, it becomes the transcoder associated
with the port.

The transcoder associated with the output port is determined
as for a call to {\cf open-string-output-port}.
\end{entry}

\begin{entry}{%
\proto{get-output-string}{ output-port}{procedure}
\rproto{get-output-string}{ output-port transcoder}{procedure}}

\domain{\var{Output-port} must be a textual port that accumulates
characters, such as the ports created by
  {\cf open-string-output-port} and {\cf call-with-string-output-port}.}
Returns a newly created string consisting of the characters that
have been accumulated by the \var{output-port} so far.

If the returned string is modified, 
the effect on \var{output-port} is unspecified.
\end{entry}

\begin{entry}{%
\proto{clear-string-output-port!}{ output-port}{procedure}}

\domain{\var{Output-port} must be a port that accumulates a string
 from the characters written to it, such as the ports created by
{\cf open-string-output-port} and {\cf call-with-string-output-port}.}
The {\cf clear-string-output-port!} procedure removes all characters
that have been accumulated by \var{output-port} so far.
\end{entry}

\begin{entry}{%
\proto{standard-output-port}{}{procedure}
\proto{standard-error-port}{}{procedure}}
   
Returns an output port connected to the standard output or standard error,
respectively, possibly a fresh one on each call.
Whether the port is binary or textual is implementation-dependent,
as is whether the port supports
the {\cf port-position} and {\cf set-port-position!} operations.

\begin{note}
  Implementations are encouraged to return a textual port when
  appropriate, and
  to associate an appropriate transcoder with the port.
\end{note}
\end{entry}

\subsection{Binary output}

\begin{entry}{%
\proto{put-u8}{ binary-output-port octet}{procedure}}

Writes \var{octet} to the output port and returns the unspecified value.
\end{entry}

\begin{entry}{%
\proto{put-bytes}{ binary-output-port bytes}{procedure}
\rproto{put-bytes}{ binary-output-port bytes start}{procedure}
\rproto{put-bytes}{ binary-output-port bytes start count}{procedure}}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integers that default to 0 and $\texttt{(bytes-length \var{bytes})}
  - \var{start}$, respectively. \var{bytes} must have a size of at
  least $\var{start} + \var{count}$.}  The {\cf put-bytes} procedure writes
\var{count} bytes of the bytes object \var{bytes}, starting at index
\var{start}, to the output port. The unspecified value is returned.
\end{entry}

\subsection{Textual output}

\begin{entry}{%
\proto{put-char}{ textual-output-port char}{procedure}}
   
Writes \var{char} to the port. The
unspecified value is returned.
\end{entry}

\begin{entry}{%
\proto{put-string}{ textual-output-port string}{procedure}}
   
Writes the characters of \var{string} to the port.
The unspecified value is returned.
\end{entry}   

\begin{entry}{%
\proto{put-string-n}{ textual-output-port string}{procedure}
\rproto{put-string-n}{ textual-output-port string start}{procedure}
\rproto{put-string-n}{ textual-output-port string start count}{procedure}}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integers.  \var{string} must have a length of at least $\var{start} +
  \var{count}$.}  \var{start} defaults to 0.  \var{count} defaults to
$\texttt{(string-length \var{bytes})} - \var{start}$. Writes the
\var{count} characters of \var{string}, starting at
index \var{start}, to the port. The unspecified value is returned.
\end{entry}


\begin{entry}{%
\proto{put-datum}{ textual-output-port datum}{procedure}}

\domain{\var{Datum} should be a datum value.}
The {\cf put-datum} procedure writes an external representation of
\var{datum} to \var{textual-output-port}.
The specific external representation is implementation-dependent.

\begin{note}
  The {\cf put-datum} procedure merely writes the external
  representation, but no trailing delimiter.  If {\cf put-datum} is
  used to write several subsequent external representations to an
  output port, care must be taken to delimit them properly so they can
  be read back in by subsequent calls to {\cf get-datum}.
\end{note}
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
