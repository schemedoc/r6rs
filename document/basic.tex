%\vfill\eject
\chapter{Semantic concepts}
\label{basicchapter}

\section{Programs and libraries}

A Scheme program consists of a \textit{top-level program\index{top-level program}}
together with a set of \textit{libraries\index{library}}, each
of which defines a part of the program connected to the others through
explicitly specified exports and imports.  A library consists of a set
of export and import specifications and a body, which consists of
definitions, and expressions;
a top-level program is similar to a library, but
has no export specifications.
Chapters~\ref{librarychapter} and \ref{programchapter}
describe the syntax and semantics of libraries and top-level programs,
respectively.  Subsequent chapters
describe various standard libraries provided by a Scheme system.  In
particular, chapter~\ref{baselibrarychapter} describes a base
library that defines many of the constructs traditionally associated with
Scheme.

The division between the base library and other standard libraries is
based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or
run-time libraries rather than in terms of other standard procedures
 or syntactic forms are not part of the base library, but are defined in
separate libraries.  Examples include the fixnums and flonums libraries,
the exceptions and conditions libraries, and the libraries for
records.

\section{Variables, syntactic keywords, and regions}
\label{specialformsection}
\label{variablesection}

In a library body,
an identifier\index{identifier} may name a type of syntax, or it may name
a location where a value can be stored.  An identifier that names a type
of syntax is called a {\em syntactic keyword}\mainindex{syntactic keyword}
and is said to be {\em bound} to that syntax.  An identifier that names a
location is called a {\em variable}\mainindex{variable} and is said to be
{\em bound} to that location.  The set of all visible
bindings\mainindex{binding} in effect at some point in a top-level program or
library body is
known as the {\em environment} in effect at that point.  The value
stored in the location to which a variable is bound is called the
variable's value.  By abuse of terminology, the variable is sometimes
said to name the value or to be bound to the value.  This is not quite
accurate, but confusion rarely results from this practice.

\todo{Define ``assigned'' and ``unassigned'' perhaps?}

\todo{In programs without side effects, one can safely pretend that the
variables are bound directly to the arguments.  Or:
In programs without \ide{set!}, one can safely pretend that the
variable is bound directly to the value. }

\vest Certain expression types are used to create new kinds of syntax
and to bind syntactic keywords to those new syntaxes, while other
expression types create new locations and bind variables to those
locations.  These expression types are called {\em binding
  constructs}.\mainindex{binding construct} Scheme has two kinds of
binding constructs: A \textit{definition}\index{definition} binds a
variable in a top-level program or library body.  All other binding
constructs create bindings that are only locally visible in the form
that creates them.  Variable definitions are created by {\cf define}
forms (see section~\ref{defines}), and definitions for syntactic
keywords are created by {\cf define-syntax} forms (see
section~\ref{syntaxdefinitionsection}).

The most fundamental of the local variable binding constructs is the
{\cf lambda} expression, because all other local variable binding
constructs can be explained in terms of {\cf lambda} expressions.  The
other variable binding constructs are {\cf let}, {\cf let*}, {\cf
  letrec*}, {\cf letrec}, {\cf let-values}, {\cf let*-values}, {\cf
  do}, and {\cf case-lambda} expressions (see sections~\ref{lambda},
\ref{letrec}, \ref{do}, and library section \ref{lib:case-lambda}).
The constructs in the base library that bind syntactic keywords are
listed in section~\ref{bindsyntax}.  Local bindings can
also be created in the form of internal {\cf define} and {\cf
  define-syntax} forms that appear inside another form rather than at
the top level of a program or a library body.

\vest Scheme is a statically scoped language with
block structure.  To each place in a top-level program or library body where an identifier is bound 
there corresponds a \defining{region} of code within which
the binding is visible.  The region is determined by the particular
binding construct that establishes the binding; if the binding is
established by a {\cf lambda} expression, for example, then its region
is the entire {\cf lambda} expression.  Every mention of an identifier
refers to the binding of the identifier that established the
innermost of the regions containing the use.  If there is no binding of
the identifier whose region contains the use, then the use refers to the
binding for the variable in the top level environment of the library
body or a binding imported from another library.  (See
chapter~\ref{librarychapter}.)
If there is no binding for the identifier,
it is said to be \defining{unbound}.\mainindex{bound}

\section{Exceptional situations}
\label{exceptionalsituationsection}

\mainindex{exceptional situation}A variety of exceptional situations
are distinguished in this report, among them violations of 
syntax, violations of a procedure's specification, violations of
implementation restrictions, and exceptional situations in the
environment.  When an exception is raised, an object is provided that
describes the nature of the exceptional situation.  The report uses
the condition system described in library section~\ref{lib:conditionssection} to
describe exceptional situations, classifying them by condition types.

For most of the exceptional situations described in this report,
portable programs cannot rely upon the exception being continuable
at the place where the situation was detected.
For those exceptions, the exception handler that is invoked by the
exception should not return.
In some cases, however, continuing is permissible; the
handler may return.  See library section~\ref{lib:exceptionssection}.

An \defining{implementation restriction} is a limitation imposed
by an implementation.  Implementations are required to raise an
exception when they are unable to continue correct execution of
a correct program due to some implementation restriction.

Some possible implementation restrictions
such as the lack of representations for NaNs and infinities (see
section~\ref{infinitiesnanssection}) are anticipated by this report,
and implementations must raise an exception of the appropriate
condition type if they encounter such a situation.

Implementation restrictions not explicitly covered in this report are
of course discouraged, but implementations are required to report
violations of implementation restrictions.
For example, an implementation may raise an exception
with condition type {\cf\&implementation-restriction} if it does not
have enough storage to run a program.

\section{Argument checking}
\label{argumentcheckingsection}

Many procedures and forms specified in this report or as part of a
standard library only accept arguments of specific types or adhering
to other restrictions.  These restrictions imply responsibilities for
both the programmer and the implementation of the specified forms and
procedures.  Specifically, the programmer is responsible for ensuring
that the arguments passed indeed adhere to the restrictions described
in the specification.  The implementation is responsible for checking
that the restrictions in the specification are indeed met, to the
extent that it is reasonable, possible and necessary to allow the
specified operation to complete successfully.

It is not always possible for an implementation to completely check
the restrictions set forth in the specifications.  Specifically, if an
operation is specified to accept a procedure with specific properties,
checking of these properties is undecidable in general.  Moreover,
some operations accept both list arguments and procedures that are
called by these operations.  As lists are mutable in programs that
make use of the \library{r6rs mutable-pairs} library (see library
chapter~\ref{lib:pairmutationchapter}), an argument that is a list
when the operation starts may be mutated by the passed procedure so
that it becomes a non-list during the execution of the operation.
Also, the procedure might escape to a different continuation,
preventing the operation to perform more checks.
Even if not, requiring the operation to check that the argument is a list after
each call to such a procedure would be impractical.  Furthermore, some
operations that accept list arguments only need to traverse the lists
partially to perform their function---requiring the implementation to
check that the arguments are lists would be impractical or potentially
violate reasonable performance assumptions.  For these reasons, the
programmer's obligations may exceed the checking obligations of the
implementation.  Implementations are, however, encouraged to perform
as much checking as possible and give detailed feedback about
violations.

When an implementation detects a violation of an argument
specification at run time, it must either raise an exception with
condition type {\cf\&violation}, or abort the program in a way
consistent with the safety of execution as described in the next
section.

\section{Safety}
\label{safeunsafemodesection}

As defined by this document, the Scheme programming language
is safe in the following sense:
If a Scheme program is said to be safe, then its execution
cannot go so badly wrong as to crash or to continue to
execute while behaving in ways that are
inconsistent with the semantics described in this document,
unless said execution first encounters some implementation
restriction or other defect in the implementation of Scheme
that is executing the program.

Violations of an implementation restriction must raise an
exception with condition type {\cf\&implementation-restriction},
as must all
violations and errors that would otherwise threaten system
integrity in ways that might result in execution that is
inconsistent with the semantics described in this document.

The above safety properties are guaranteed only for top-level programs
and libraries that are said to be safe.  Implementations
may provide access to unsafe libraries, and may interpret
implementation-specific declarations in ways that
cannot guarantee safety.

\section{Boolean values}
\label{booleanvaluessection}

Although there is a separate boolean type, any Scheme value can be
used as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
\schfalse{}.  This report uses the word ``true'' to refer to any
Scheme value except \schfalse{}, and the word ``false'' to refer to
\schfalse{}. \mainindex{true} \mainindex{false}

\section{Multiple return values}
\label{multiplereturnvaluessection}

A Scheme expression can evaluate to an arbitrary finite number of
values.  These values are passed to the expression's continuation.

Not all continuations accept any number of values: A continuation that
accepts the argument to a procedure call is guaranteed to accept
exactly one value.  The effect of passing some other number of values
to such a continuation is unspecified.  The {\cf call-with-values}
procedure
described in section~\ref{controlsection} makes it possible to create
continuations that accept specified numbers of return values.
If the number of
return values passed to a continuation created by a call to
{\cf call-with-values} is not accepted by its consumer
that was passed in that call, then an exception is raised.
A more complete description of the number of values accepted by
different continuations and the consequences of passing an unexpected
number of values is given in the description of the {\cf values}
procedure in section~\ref{values}.

A number of forms in the base library have sequences of expressions
as subforms that are evaluated sequentially, with the return values of
all but the last expression being discarded.  The continuations
discarding these values accept any number of values.

\section{Storage model}
\label{storagemodel}

Variables and objects such as pairs, vectors, and strings implicitly
denote locations\mainindex{location} or sequences of locations.  A string, for
example, denotes as many locations as there are characters in the string. 
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the {\tt string-set!} procedure, but
the string continues to denote the same locations as before.

An object fetched from a location, by a variable reference or by
a procedure such as {\cf car}, {\cf vector-ref}, or {\cf string-ref}, is
equivalent in the sense of \ide{eqv?} % and \ide{eq?} ??
(section~\ref{equivalencesection})
to the object last stored in the location before the fetch.

Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to denote them.

It is desirable for constants\index{constant} (i.e. the values of
literal expressions) to reside in read-only-memory.  To express this,
it is convenient to imagine that every object that denotes locations
is associated with a flag telling whether that object is
mutable\index{mutable} or immutable\index{immutable}.  Literal
constants, the strings returned by \ide{symbol->string}, records with
no mutable fields, and other values explicitly designated as immutable
are immutable objects, while all objects created by the other
procedures listed in this report are mutable.  An attempt to store a
new value into a location that is denoted by an immutable object
should raise an exception with condition type {\cf\&assertion}.

\section{Proper tail recursion}
\label{proper tail recursion}

Implementations of Scheme are required to be
{\em properly tail-recursive}\mainindex{proper tail recursion}.
Procedure calls that occur in certain syntactic
contexts defined below are `tail calls'.  A Scheme implementation is
properly tail-recursive if it supports an unbounded number of active
tail calls.  A call is {\em active} if the called procedure may still
return.  Note that this includes calls that may be returned from either
by the current continuation or by continuations captured earlier by
{\cf call-with-current-continuation} that are later invoked.
In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not
yet returned.
A formal definition of proper tail recursion can be found
in~\cite{propertailrecursion}.  The rules for identifying tail calls
in base-library constructs are described in
section~\ref{basetailcontextsection}.

\begin{rationale}

Intuitively, no space is needed for an active tail call because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call.  Although an improper
implementation might use a new continuation in the call, a return
to this new continuation would be followed immediately by a return
to the continuation passed to the procedure.  A properly tail-recursive
implementation returns to that continuation directly.

Proper tail recursion was one of the central ideas in Steele and
Sussman's original version of Scheme.  Their first Scheme interpreter
implemented both functions and actors.  Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller.  In the terminology
of this section, each actor finished with a tail call to another actor.

Steele and Sussman later observed that in their interpreter the code
for dealing with actors was identical to that for functions and thus
there was no need to include both in the language.

\end{rationale}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
