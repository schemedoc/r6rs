%\vfill\eject
\chapter{Basic concepts and terminology}
\label{basicchapter}

\section{Entry format}

The chapters describing bindings in the core language and the standard
libraries are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
built-in procedure.  An entry begins with one or more header lines of the form

\noindent\pproto{\var{template}}{\var{category}}\unpenalty

If \var{category} is ``\exprtype'', the entry describes an expression
type, and the template gives the syntax of the expression type.  Even
though the template is written in a notation similar to a right-hand
side of the BNF rules in chapter~\ref{readsyntaxchapter}, it describes
the set of S-expressions equivalent to the S-expressions matching the
template.

Components of the S-expressions described by a template are designated
by syntactic variables, which are written using angle brackets, for
example, \hyper{expression}, \hyper{variable}.  Syntactic variables
should be understood to denote other S-expressions, or, in some cases,
sequences of them.  A syntactic variable may refer to a non-terminal
in the S-expression grammar, in which case only S-expressions matching
that non-terminal are permissible in that position.  For example,
\hyper{expression} stands for any S-expression which is a
syntactically valid expression.  Other non-terminals that are used in
templates will be defined as part of the specification.

The notation
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
indicates zero or more occurrences of a \hyper{thing}, and
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
indicates one or more occurrences of a \hyper{thing}.

If \var{category} is ``procedure'', then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Parameter
names in the template are \var{italicized}.  Thus the header line

\noindent\pproto{(vector-ref \var{vector} \var{k})}{procedure}\unpenalty

indicates that the built-in procedure {\tt vector-ref} takes
two arguments, a vector \var{vector} and an exact non-negative integer
\var{k} (see below).  The header lines

\noindent%
\pproto{(make-vector \var{k})}{procedure}
\pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty

indicate that the {\tt make-vector} procedure must be defined to take
either one or two arguments.

\label{typeconventions}
An operation that is presented with an argument that it
is not specified to handle will raise an exception with exception type
{\cf\&contract}.  For succinctness, we follow the convention
that if an argument name is also the name of a type, then that argument must be of the named type.
For example, the header line for {\tt vector-ref} given above dictates that the
first argument to {\tt vector-ref} must be a vector.  The following naming
conventions imply type restrictions:
\newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
$$
\begin{tabular}{ll}
\var{obj}&any object\\
\foo{list}&list (see section~\ref{listsection})\\
\foo{vector}&vector (see section~\ref{vectorsection})\\
\foo{z}&complex number\\
\foo{x}&real number\\
\foo{y}&real number\\
\foo{q}&rational number\\
\foo{n}&integer\\
\foo{k}&exact non-negative integer\\
\foo{condition}&condition (see section~\ref{conditionssection})\\
\foo{bytes}&bytes object (see section~\ref{bytessection})\\
\foo{hash-table}&hash table (see section~\ref{hash-table})\\
\end{tabular}
$$

Other type restrictions are defined used in specific chapters.  For
example, chapter~\ref{numberchapter} uses a number of special parameter
variables for the various subsets of the numbers.

\todo{Provide an example entry??}

If \var{category} is something other than ``syntax'' and
``procedure,'' then the entry describes a non-procedural value, and
the \var{category} describes the type of that value.  The header line

\noindent\rvproto{\&who}{condition type}

indicates that {\cf\&who} is a condition type.

\section{List arguments}

Lists are mutable in Scheme, so a pair that is the head of a list at
one moment may not always be the head of a list.  Any procedures
defined in this report specified as accepting a list argument must
check if that argument indeed appears to be a list.  This checking is
complicated by the fact that many procedures accepting lists such as
{\cf map} or {\cf filter} call arbitrary procedures that are passed as
arguments.  These argument procedures may mutate the list while it is
being traversed.  Moreover, in the presence of concurrent evaluation,
whether a pair is the head of a list is not computable in general.

Consequently, procedures like {\cf length} are only required to check
that a list argument is a \textit{plausible list\index{plausible
    list}}.  Informally, a plausible list is an object that appears as
a list during a sequential traversal, where that traversal must also
detect a cycle.  A more formal definition follows:

Plausible lists are defined with respect to the time interval between
the time an argument is passed to the specified procedure and the
first return of a value to that procedure's continuation.

The times are in any global time that satisfies the axioms proposed in
chapter 2 of MIT AI TR-633~\cite{AITR633}.

\begin{note}
In most implementations,
the definitions above are believed to be invariant under
transformations of global time that are allowed by those axioms.
\end{note}

A \textit{plausible list up to $n$ between times $t_0$ and $t_n$} is a
Scheme value $x$ such that
%
\begin{enumerate}
\item $x$ is a pair, and $n$ is $0$; or
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list up to $n-1$ between
  times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible list of length $n$ between times $t_0$ and $t_n$}
is a Scheme value $x$ such that

\begin{enumerate}
\item $x$ is the empty list, and $n$ is $0$; or
\item $x$ is a pair $p$, $n > 0$, and there exists some time
  $t_1$ in $(t_0,t_n]$ such that taking the cdr of $p$ at
  time $t_1$ yields a plausible list of length $n-1$
  between times $t_1$ and $t_n$.
\end{enumerate}

A \textit{plausible prefix of length $n$ between times $t_0$ and
  $t_n$} is a sequence of Scheme values $x_0,\ldots,x_n$ and strictly
increasing times $t_1,\ldots,t_n$ such that $x_0$ through $x_{n-1}$
are pairs, $x_n$ is either the empty list or a pair, and taking the
cdr of a pair $x_{i-1}$ at time $t_i$ yields $x_i$.

\textit{A plausible alist up to $n$ between times $t_0$ and $t_n$} is
a plausible list up to $n$ between $t_0$ and $t_n$ such that, for all
possible choices of the times $t_1$ and pairs $p$ mentioned in part
(3) above, there exists a time $t_2$ such that $t_1 < t_2 < t_n$ and
the car of $p$ at time $t_2$ is a pair.

\textit{A plausible alist of length $n$} is defined similarly, as is
\textit{a plausible alist prefix of length $n$}.

\textit{A plausible list (alist) between times $t_0$ and $t_n$} is a
plausible list (alist) of some length $n$ between those times.

\section{Evaluation examples}

The symbol ``\evalsto'' used in program examples should be read
``evaluates to.''  For example,

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

means that the expression {\tt(* 5 8)} evaluates to the object {\tt 40}.
Or, more precisely:  the expression given by the sequence of characters
``{\tt(* 5 8)}'' evaluates, in the initial environment, to an object
that may be represented externally by the sequence of characters ``{\tt
40}''.  See chapter~\ref{readsyntaxchapter} for a discussion of external
representations of objects.

\section{Exceptional situations}

\mainindex{error} When speaking of an exceptional situation, this
report uses the phrase ``an exception must be raised'' to indicate
that implementations must detect the situation and report it to the
program through the exception system described in
chapter~\ref{exceptionsconditionschapter}.

Several variations on ``an exception must be raised'' are possible:

\begin{itemize}
\item ``Should raise an exception" means that implementations
  are encouraged, but not required, to detect the situation
  and to raise an exception.

\item ``May raise an exception'' means that implementations
are allowed, but not required or encouraged, to detect
the situation and to raise an exception.

\item ``Might raise an exception'' means that implementations
are allowed, but discouraged, to detect the situation
and to raise an exception.
\end{itemize}

A variety of exceptional situations are distinguished in this report,
among them violations of program syntax, violations of a procedure's
specification, violations of implementation restrictions, and
exceptional situations in the environment.  When an exception is
raised, an object is provided that describes the nature of the
exceptional siutation.  The report uses the condition system described
in section~\ref{conditionssection} to describe exceptional situations,
classifying them by condition types.  This report uses the phrase
``an exception with condition type \meta{condition-type}'' to indicate
that the object provided with the exception is a condition object of
the specified type.

\vest For example, an exception with condition type {\cf\&contract}
must be raised if a procedure is passed an argument that the procedure
is not explicitly specified to handle, even though such domain
exceptions are not always mentioned in this report.

The above requirements for violations and implementation restrictions
only apply in \textit{safe mode}.  Implementations may not raise
exceptions in those situations in \textit{unsafe mode}.  The
distinction is explained in section~\ref{safeunsafemodesection}.

Implementation restrictions indicate circumstances under which an
implementation is permitted to raise an exception if it is unable to
continue execution of a correct program because of some restriction
imposed by the implementation.

Some possible implementation restrictions
such as the lack of representations for NaNs and infinities (see
section~\ref{infinitiesnanssection}) are covered by this report, and
implementations must raise an exception of the appropriate condition
type if it encounters such a situation.

Implementation restrictions not explicitly covered in this report are
of course discouraged, but implementations are encouraged to report
violations of implementation restrictions.\mainindex{implementation
  restriction} For example, an implementation may raise an exception
with condition type {\cf\&implementation-restriction} if it does not
have enough storage to run a program.
 
\section{Safe and unsafe mode}
\label{safeunsafemodesection}

FIXME

\section{Unspecified behavior}

\vest If the value of an expression is said to be ``unspecified,''
then the expression must evaluate without raising an exception, but
the values returned depends on the implementation; this report
explicitly does not say what values should be returned.
\mainindex{unspecified}

Some expressions are specified to return \emph{the} unspecified value,
which is a special value returned by the \texttt{unspecified}
procedure.  (See section~\ref{unspecifiedvalue}.)  In this case, the
return value is meaningless, and programmers are discouraged from
relying on its specific nature.

\section{Naming conventions}

By convention, the names of procedures that always return a boolean
value usually end
in ``\ide{?}''.  Such procedures are called predicates.

By convention, the names of procedures that store values into previously
allocated locations (see section~\ref{storagemodel}) usually end in
``\ide{!}''.
Such procedures are called mutation procedures.
By convention, the value returned by a mutation procedure is
\unspecifiedreturn{} (see section~\ref{unspecifiedvalue}).

By convention, ``\ide{->}'' appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, {\cf list->vector} takes a list and returns a vector whose
elements are the same as those of the list.


	
\todo{Terms that need defining: thunk, command (what else?).}

\section{Programs and libraries}

A Scheme consists of a set of \textit{libraries\index{library}}, each
of which defines a part of the program connected to the others through
explicitly specified exports and imports.  A library consists of a set
of import and export FIXME specifications and a body, which contains
the code defining the library.  Chapter~\ref{librarychapter} describes
the syntax and semantics for libraries.  The subsequent chapters
describe various standard libraries provided by a Scheme system.  In
particular, chapter~\ref{corelanguagecchapter} describes a core
language defining most of the constructs traditionally associated with
Scheme programs.

The division between the core language and other standard libraries is
based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or
run-time libraries rather than in terms of other standard procedures
 or syntactic forms are not part of the core language, but defined in
separate libraries.  Examples include the fixnum and flonum libraries,
the exceptions and conditions libraries, and the libraries for
records.

\section{Variables, syntactic keywords, and regions}
\label{specialformsection}
\label{variablesection}

In a library body,
an identifier\index{identifier} may name a type of syntax, or it may name
a location where a value can be stored.  An identifier that names a type
of syntax is called a {\em syntactic keyword}\mainindex{syntactic keyword}
and is said to be {\em bound} to that syntax.  An identifier that names a
location is called a {\em variable}\mainindex{variable} and is said to be
{\em bound} to that location.  The set of all visible
bindings\mainindex{binding} in effect at some point in a program is
known as the {\em environment} in effect at that point.  The value
stored in the location to which a variable is bound is called the
variable's value.  By abuse of terminology, the variable is sometimes
said to name the value or to be bound to the value.  This is not quite
accurate, but confusion rarely results from this practice.

\todo{Define ``assigned'' and ``unassigned'' perhaps?}

\todo{In programs without side effects, one can safely pretend that the
variables are bound directly to the arguments.  Or:
In programs without \ide{set!}, one can safely pretend that the
variable is bound directly to the value. }

\vest Certain expression types are used to create new kinds of syntax
and bind syntactic keywords to those new syntaxes, while other
expression types create new locations and bind variables to those
locations.  These expression types are called {\em binding constructs}.
\mainindex{binding construct}
The constructs in the core language that bind syntactic keywords are listed in section~\ref{macrosection}.
The most fundamental of the variable binding constructs is the
{\cf lambda} expression, because all other variable binding constructs
can be explained in terms of {\cf lambda} expressions.  The other
variable binding constructs are {\cf let}, {\cf let*}, {\cf letrec*}, {\cf letrec},
and {\cf do} expressions (see sections~\ref{lambda}, \ref{letrec}, and
\ref{do}).

%Note: internal definitions not mentioned here.

\vest Like Algol and Pascal, and unlike most other dialects of Lisp
except for Common Lisp, Scheme is a statically scoped language with
block structure.  To each place where an identifier is bound in a program
there corresponds a \defining{region} of the program text within which
the binding is visible.  The region is determined by the particular
binding construct that establishes the binding; if the binding is
established by a {\cf lambda} expression, for example, then its region
is the entire {\cf lambda} expression.  Every mention of an identifier
refers to the binding of the identifier that established the
innermost of the regions containing the use.  If there is no binding of
the identifier whose region contains the use, then the use refers to the
binding for the variable in the top level environment, if any
(FIXME chapters~\ref{modulelibraries}); if there is no
binding for the identifier,
it is said to be \defining{unbound}.\mainindex{bound}\index{top level
environment}

\todo{Mention that some implementations have multiple top level environments?}

\todo{Pitman sez: needs elaboration in case of {\tt(let ...)}}

\todo{Pitman asks: say something about vars created after scheme starts?
{\tt (define x 3) (define (f) x) (define (g) y) (define y 4)}
Clinger replies: The language was explicitly
designed to permit a view in which no variables are created after
Scheme starts.  In files, you can scan out the definitions beforehand.
I think we're agreed on the principle that interactive use should
approximate that behavior as closely as possible, though we don't yet
agree on which programming environment provides the best approximation.}


\section{Storage model}
\label{storagemodel}

Variables and objects such as pairs, vectors, and strings implicitly
denote locations\mainindex{location} or sequences of locations.  A string, for
example, denotes as many locations as there are characters in the string. 
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the {\tt string-set!} procedure, but
the string continues to denote the same locations as before.

An object fetched from a location, by a variable reference or by
a procedure such as {\cf car}, {\cf vector-ref}, or {\cf string-ref}, is
equivalent in the sense of \ide{eqv?} % and \ide{eq?} ??
(section~\ref{equivalencesection})
to the object last stored in the location before the fetch.

Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to denote them.

In many systems it is desirable for constants\index{constant} (i.e. the values of
literal expressions) to reside in read-only-memory.  To express this, it is
convenient to imagine that every object that denotes locations is associated
with a flag telling whether that object is mutable\index{mutable} or
immutable\index{immutable}.  In such systems literal constants and the strings
returned by \ide{symbol->string} are immutable objects, while all objects
created by the other procedures listed in this report are mutable.  An
attempt to store a new value into a location that is denoted by an
immutable object will raise an exception.

\section{Proper tail recursion}
\label{proper tail recursion}

Implementations of Scheme are required to be
{\em properly tail-recursive}\mainindex{proper tail recursion}.
Procedure calls that occur in certain syntactic
contexts defined below are `tail calls'.  A Scheme implementation is
properly tail-recursive if it supports an unbounded number of active
tail calls.  A call is {\em active} if the called procedure may still
return.  Note that this includes calls that may be returned from either
by the current continuation or by continuations captured earlier by
{\cf call-with-current-continuation} that are later invoked.
In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not
yet returned.
A formal definition of proper tail recursion can be found
in~\cite{propertailrecursion}.  The rules for identifying tail calls
in core-language programs are described in
section~\ref{coretailcontextsection}.

\begin{rationale}

Intuitively, no space is needed for an active tail call because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call.  Although an improper
implementation might use a new continuation in the call, a return
to this new continuation would be followed immediately by a return
to the continuation passed to the procedure.  A properly tail-recursive
implementation returns to that continuation directly.

Proper tail recursion was one of the central ideas in Steele and
Sussman's original version of Scheme.  Their first Scheme interpreter
implemented both functions and actors.  Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller.  In the terminology
of this section, each actor finished with a tail call to another actor.

Steele and Sussman later observed that in their interpreter the code
for dealing with actors was identical to that for functions and thus
there was no need to include both in the language.

\end{rationale}

