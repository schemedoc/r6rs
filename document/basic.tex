%\vfill\eject
\chapter{Basic concepts}
\label{basicchapter}

\section{Programs and libraries}

A Scheme consists of a set of \textit{libraries\index{library}}, each
of which defines a part of the program connected to the others through
explicitly specified exports and imports.  A library consists of a set
of import and export FIXME specifications and a body, which contains
the code defining the library.  Chapter~\ref{librarychapter} describes
the syntax and semantics for libraries.  The subsequent chapters
describe various standard libraries provided by a Scheme system.  In
particular, chapter~\ref{corelanguagecchapter} describes a core
language defining most of the constructs traditionally associated with
Scheme programs.

The division between the core language and other standard libraries is
based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or
run-time libraries rather than in terms of other standard procedures
 or syntactic forms are not part of the core language, but defined in
separate libraries.  Examples include the fixnum and flonum libraries,
the exceptions and conditions libraries, and the libraries for
records.

\section{Variables, syntactic keywords, and regions}
\label{specialformsection}
\label{variablesection}

In a library body,
an identifier\index{identifier} may name a type of syntax, or it may name
a location where a value can be stored.  An identifier that names a type
of syntax is called a {\em syntactic keyword}\mainindex{syntactic keyword}
and is said to be {\em bound} to that syntax.  An identifier that names a
location is called a {\em variable}\mainindex{variable} and is said to be
{\em bound} to that location.  The set of all visible
bindings\mainindex{binding} in effect at some point in a program is
known as the {\em environment} in effect at that point.  The value
stored in the location to which a variable is bound is called the
variable's value.  By abuse of terminology, the variable is sometimes
said to name the value or to be bound to the value.  This is not quite
accurate, but confusion rarely results from this practice.

\todo{Define ``assigned'' and ``unassigned'' perhaps?}

\todo{In programs without side effects, one can safely pretend that the
variables are bound directly to the arguments.  Or:
In programs without \ide{set!}, one can safely pretend that the
variable is bound directly to the value. }

\vest Certain expression types are used to create new kinds of syntax
and bind syntactic keywords to those new syntaxes, while other
expression types create new locations and bind variables to those
locations.  These expression types are called {\em binding constructs}.
\mainindex{binding construct}
Those that bind syntactic keywords are listed in section~\ref{macrosection}.
The most fundamental of the variable binding constructs is the
{\cf lambda} expression, because all other variable binding constructs
can be explained in terms of {\cf lambda} expressions.  The other
variable binding constructs are {\cf let}, {\cf let*}, {\cf letrec*}, {\cf letrec},
and {\cf do} expressions (see sections~\ref{lambda}, \ref{letrec}, and
\ref{do}).

%Note: internal definitions not mentioned here.

\vest Like Algol and Pascal, and unlike most other dialects of Lisp
except for Common Lisp, Scheme is a statically scoped language with
block structure.  To each place where an identifier is bound in a program
there corresponds a \defining{region} of the program text within which
the binding is visible.  The region is determined by the particular
binding construct that establishes the binding; if the binding is
established by a {\cf lambda} expression, for example, then its region
is the entire {\cf lambda} expression.  Every mention of an identifier
refers to the binding of the identifier that established the
innermost of the regions containing the use.  If there is no binding of
the identifier whose region contains the use, then the use refers to the
binding for the variable in the top level environment, if any
(FIXME chapters~\ref{modulelibraries}); if there is no
binding for the identifier,
it is said to be \defining{unbound}.\mainindex{bound}\index{top level
environment}

\todo{Mention that some implementations have multiple top level environments?}

\todo{Pitman sez: needs elaboration in case of {\tt(let ...)}}

\todo{Pitman asks: say something about vars created after scheme starts?
{\tt (define x 3) (define (f) x) (define (g) y) (define y 4)}
Clinger replies: The language was explicitly
designed to permit a view in which no variables are created after
Scheme starts.  In files, you can scan out the definitions beforehand.
I think we're agreed on the principle that interactive use should
approximate that behavior as closely as possible, though we don't yet
agree on which programming environment provides the best approximation.}

\section{Primitive syntax}

The body of a library is always a sequence of S-expressions.  Apart
from that, the concrete structure of the S-expressions that form a
library body largely depends on the libraries that are imported into
the current library.  The syntactic keywords imported determine which
of the S-expressions occurring in a library body, and which of their
sub-S-expressions are actually expressions.  While a library can
provide new means for forming expressions, a few expression types are
always available, independently from the imported libraries.  They are
described in this section.

\subsection{Constant literals}

\begin{entry}{%
\pproto{\hyper{constant}}{\exprtype}}

Numerical constants, string constants, character constants, and
boolean constants evaluate ``to themselves.''
\end{entry}

\subsection{Variable references}\unsection

\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

An expression consisting of a variable\index{variable}
(section~\ref{variablesection}) is a variable reference.  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is an error to reference an
unbound\index{unbound} variable.

\begin{scheme}
(define x 28) ; in the core language
x   \ev  28%
\end{scheme}
\end{entry}

\subsection{Procedure calls}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

A procedure call is written by simply enclosing in parentheses
expressions for the procedure to be called and the arguments to be
passed to it.  An S-expression in an expression context is a procedure
call if \hyper{operator} is not bound as a syntactic keyword.

When an procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting
arguments.\mainindex{call}\mainindex{procedure call} In the core
language:
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

Procedure calls may return any number of values (see \ide{values} in
section~\ref{proceduresection}).

\begin{note} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.
\end{note}

\begin{note}
Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.
\end{note}

\begin{note} In many dialects of Lisp, the S-expression {\tt
()} is a legitimate expression.  In Scheme, expressions written as
list/pair S-expressions  must have at
least one subexpression, so {\tt ()} is not a syntactically valid
expression.
\end{note}

\todo{Freeman:
I think an explanation as to why evaluation order is not specified
should be included.  It should not include any reference to parallel
evaluation.  Does any existing compiler generate better code because
the evaluation order is unspecified?  Clinger: yes: T3, MacScheme v2,
probably MIT Scheme and Chez Scheme.  But that's not the main reason
for leaving the order unspecified.}

\end{entry}

\section{Storage model}
\label{storagemodel}

Variables and objects such as pairs, vectors, and strings implicitly
denote locations\mainindex{location} or sequences of locations.  A string, for
example, denotes as many locations as there are characters in the string. 
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the {\tt string-set!} procedure, but
the string continues to denote the same locations as before.

An object fetched from a location, by a variable reference or by
a procedure such as {\cf car}, {\cf vector-ref}, or {\cf string-ref}, is
equivalent in the sense of \ide{eqv?} % and \ide{eq?} ??
(section~\ref{equivalencesection})
to the object last stored in the location before the fetch.

Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to denote them.

In many systems it is desirable for constants\index{constant} (i.e. the values of
literal expressions) to reside in read-only-memory.  To express this, it is
convenient to imagine that every object that denotes locations is associated
with a flag telling whether that object is mutable\index{mutable} or
immutable\index{immutable}.  In such systems literal constants and the strings
returned by \ide{symbol->string} are immutable objects, while all objects
created by the other procedures listed in this report are mutable.  It is an
error to attempt to store a new value into a location that is denoted by an
immutable object.

\section{Proper tail recursion}
\label{proper tail recursion}

Implementations of Scheme are required to be
{\em properly tail-recursive}\mainindex{proper tail recursion}.
Procedure calls that occur in certain syntactic
contexts defined below are `tail calls'.  A Scheme implementation is
properly tail-recursive if it supports an unbounded number of active
tail calls.  A call is {\em active} if the called procedure may still
return.  Note that this includes calls that may be returned from either
by the current continuation or by continuations captured earlier by
{\cf call-with-current-continuation} that are later invoked.
In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not
yet returned.
A formal definition of proper tail recursion can be found
in~\cite{propertailrecursion}.  The rules for identifying tail calls
in core-language programs are described in
section~\ref{coretailcontextsection}.

\begin{rationale}

Intuitively, no space is needed for an active tail call because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call.  Although an improper
implementation might use a new continuation in the call, a return
to this new continuation would be followed immediately by a return
to the continuation passed to the procedure.  A properly tail-recursive
implementation returns to that continuation directly.

Proper tail recursion was one of the central ideas in Steele and
Sussman's original version of Scheme.  Their first Scheme interpreter
implemented both functions and actors.  Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller.  In the terminology
of this section, each actor finished with a tail call to another actor.

Steele and Sussman later observed that in their interpreter the code
for dealing with actors was identical to that for functions and thus
there was no need to include both in the language.

\end{rationale}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
