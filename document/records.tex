\chapter{Records}
\label{recordschapter}
\mainindex{record}
This section describes abstractions for creating new data types
representing records---data structures with named fields. The record
mechanism comes in four libraries:

\begin{itemize}
\item the \library{r6rs records procedural} library,
  a procedural layer for creating and manipulating record types and record
  instances,
\item the \library{r6rs records explicit} library,
  an explicit-naming syntactic layer for defining record types and
  explicitly named bindings for various procedures to manipulate the record
  type,
\item the \library{r6rs records implicit} library,
  an implicit-naming syntactic layer that extends the explicit-naming
  syntactic layer, allowing the names of the defined procedures to be
  determined implicitly from the names of the record type and fields, and
\item the \library{r6rs records inspection} library,
  a set of inspection procedures.
\end{itemize}
% 
The procedural layer allows programs to construct new record types
and the associated procedures for creating and manipulating records
dynamically.
It is particularly useful for writing interpreters that construct
host-compatible record types.  It may also serve as a target for expansion
of the syntactic layers.

The explicit-naming syntactic layer provides a basic syntactic interface
whereby a single record definition serves as a shorthand for the definition of
several record creation and manipulation routines: a construction procedure, a
predicate, field accessors, and field mutators. As the name suggests, the
explicit-naming syntactic layer requires the programmer to name each of these
procedures explicitly.

The implicit-naming syntactic layer extends the explicit-naming syntactic layer
by allowing the names for the construction procedure, predicate, accessors, and
mutators to be determined automatically from the name of the record and names
of the fields. This establishes a standard naming convention and allows
record-type definitions to be more succinct, with the downside that the
procedure
definitions cannot easily be located via a simple search for the 
procedure name.
The programmer may override some or all of the default names by specifying them
explicitly, as in the explicit-naming syntactic layer.

The two syntactic layers are designed to be fully compatible; the
implicit-naming layer is simply a conservative extension of the
explicit-naming layer.  The design makes both explicit-naming and
implicit-naming definitions natural while allowing a seamless
transition between explicit and implicit naming.

Each of these layers permits record types to be extended via single
inheritance, allowing record types to model hierarchies that occur in
applications like algebraic data types as well as single-inheritance class
systems.

Each of the layers also supports generative and nongenerative record types.

The inspection procedures allow programs to obtain from a record instance a
descriptor for the type and from there obtain access to the fields of the
record instance. This allows the creation of portable printers and inspectors.
A program may prevent access to a record's type and thereby protect the
information stored in the record from the inspection mechanism by declaring the
type opaque. Thus, opacity as presented here can be used to enforce abstraction
barriers.

This section uses the \var{rtd} and \var{constructor-descriptor}
parameter names for arguments that must be record-type descriptors
and constructor descriptors, respectively (see
section~\ref{recordsproceduralsection}).

\section{Procedural layer}
\label{recordsproceduralsection}

The procedural layer is provided by the \deflibrary{r6rs records
  procedural} library.

\begin{entry}{%
\pproto{(make-record-type-descriptor \var{name}}{procedure}}
\mainschindex{make-record-type-descriptor}{\tt\obeyspaces\\
        \var{parent} \var{uid} \var{sealed?} \var{opaque?} \var{fields})}
   
Returns a \defining{record-type descriptor}, or \defining{rtd},
representing a record type distinct from all built-in types and
other record types.

The \var{name} argument must be a symbol. It names the record type,
and is intended purely for informational purposes and may be used for printing by
the underlying Scheme system.

The \var{parent} argument must be either \schfalse{} or an rtd. If it is an
rtd, the returned record type, \var{t}, extends the record type
\var{p} represented by \var{parent}. Each record of type \var{t} is also a
record of type \var{p}, and all operations applicable to a record of
type \var{p} are also applicable to a record of type \var{t}, except for
inspection operations if \var{t} is opaque but \var{p} is not. An exception with
condition type {\cf\&assertion} is raised if \var{parent} is sealed (see below).
   
The extension relationship is transitive in the sense that a type extends
its parent's parent, if any, and so on.
   
The \var{uid} argument must be either \schfalse{} or a symbol.
If \var{uid} is a symbol, the record-creation operation is
\emph{nongenerative} i.e., a new record type is created only
if no previous call to {\cf make-record-type-descriptor}
was made with the \var{uid}.
If \var{uid} is \schfalse{}, the record-creation operation is
\emph{generative}, i.e., a new record type is created even if
a previous call to {\cf make-record-type-descriptor} was
made with the same arguments.

If {\cf make-record-type-descriptor} is
called twice with the same \var{uid} symbol, the parent
arguments in the two calls must be {\cf eqv?}, the \var{fields}
arguments {\cf equal?}, the \var{sealed?} arguments Boolean-equivalent
(both false or both non-false), and the \var{opaque?} arguments
Boolean-equivalent.
If these conditions are not met, an exception with condition type
{\cf\&assertion} is raised when the second call occurs.
If they are met, the second call returns, without creating a new
record type, the same record-type descriptor
(in the sense of {\cf eqv?}) as the first call.

\begin{note}   
  Users are encouraged to use symbol names
  constructed using the UUID namespace (for example, using the
  record-type name as a prefix) for the uid argument.
\end{note}

The \var{sealed?} flag must be a Boolean. If true, the returned record type
is sealed, i.e., it cannot be extended.

The \var{opaque?} flag must be a Boolean. If true, the record type
is opaque.
If passed an instance of the record type,
{\cf record?} returns
\schfalse{}.  Moreover, if {\cf record-rtd} (see ``Inspection'' below)
is called an instance of the record type, 
an exception with condition type {\cf\&assertion} is raised.
The record type is also opaque if an opaque parent is
supplied.  If \var{opaque?} is false and an opaque parent is not
supplied, the record is not opaque.

The \var{fields} argument must be a vector of field specifiers. Each
field specifier must be a list of the form {\cf (mutable \var{name})}
or a list of the form {\cf (immutable \var{name})}.
Each name must be a symbol and names the corresponding field of the record
type; the names need not be distinct.  A field identified as mutable may
be modified, whereas, when a program attempts to obtain a mutator for a field identified
as immutable, an exception with condition type {\cf\&assertion} is raised.
Where field order is relevant, e.g., for record construction and field
access, the fields are considered to be ordered as specified, although
no particular order is required for the actual representation of a
record instance.

The specified fields are added to the parent fields, if any, to determine
the complete set of fields of the returned record type.
If \var{fields} is modified after {\cf make-record-type}
has been called, the effect on the returned
rtd is unspecified.

A record type is considered immutable if all fields
in its complete set of fields is immutable, and is mutable otherwise.

A generative record-type descriptor created by a call to {\cf
  make-record-type-descriptor} is not {\cf eqv?} to any record-type
descriptor (generative or nongenerative) created by another call to
{\cf make-record-type-descriptor}. A generative record-type descriptor
is {\cf eqv?}  only to itself, i.e., {\tt (eqv?~\vri{rtd} \vrii{rtd})} iff
{\tt (eq?~\vri{rtd} \vrii{rtd})}.
Also, two nongenerative record-type descriptors are {\cf eqv?} iff they were
created by calls to {\cf make-record-type-descriptor} with the same
uid arguments.

\begin{rationale}
  The record and field names passed to
  {\cf make-record-type-descriptor} and appearing in the explicit-naming
  syntactic layer are for informational purposes only, e.g., for
  printers and debuggers.
  In particular, the accessor and mutator creation routines do not use
  names, but rather field indices, to identify fields.
  
  Thus, field names are not required to be distinct in the procedural or
  implicit-naming syntactic layers.
  This relieves macros and other code generators from the need to
  generate distinct names.

  The record and field names are used in the implicit-naming syntactic
  layer for the generation of accessor and mutator names, and duplicate
  field names may lead to accessor and mutator naming conflicts.
\end{rationale}

\begin{rationale}
  Sealing a record type can help to enforce abstraction barriers by preventing
  extensions that may expose implementation details of the parent type.
  Type extensions also make monomorphic code polymorphic and
  difficult to change the parent class at a later time, and also
  prevent effective predictions of types by a compiler or human
  reader.
\end{rationale}

\begin{rationale}
  Multiple inheritance was considered but omitted from the records
  facility, as it raises a number of semantic issues such as
  sharing among common parent types.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{record-type-descriptor?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a record-type descriptor,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\pproto{(make-record-constructor-descriptor \var{rtd}}{procedure}}
\mainschindex{make-record-constructor-descriptor}{\tt\obeyspaces\\
        \var{parent-constructor-descriptor} \var{protocol})}

Returns a \defining{record-constructor descriptor} (or
\defining{constructor descriptor} for short) that can be used to
create record constructors (via {\cf record-constructor}; see below)
or other constructor descriptors.  \var{Rtd} must be a record-type
descriptor.  \var{Protocol}\mainindex{protocol} must be a procedure or \schfalse.
If it is \schfalse, a default \var{protocol} procedure is supplied.
If \var{protocol} is a procedure, it is called by {\cf record-constructor}
with a single argument \var{p} and should return a procedure that creates
and returns an instance of the record type using \var{p} as described
below.

If \var{rtd} is not an extension of another record type, then
\var{parent-constructor-descriptor} must be \schfalse.
In this case, \var{protocol}'s argument \var{p} is a procedure \var{new}
that expects one parameter for every field of \var{rtd} and returns a
record instance with the fields of \var{rtd} initialized to its arguments.
The procedure returned by \var{protocol} may take any number of arguments
but should call \var{new} with the number of arguments it expects and return
the resulting record instance, as shown in the simple example below.

\begin{scheme}
(lambda (\var{new})
  (lambda (v1 \ldots)
    (\var{new} v1 \ldots)))
\end{scheme}

Here, the call to \var{new} returns a record whose fields
are simply initialized with the arguments {\tt v1 \ldots}.
The expression above is equivalent to
{\cf (lambda (\var{new}) \var{new})}.

If \var{rtd} is an extension of another record type \var{parent-rtd},
\var{parent-constructor-descriptor} must be a constructor descriptor
of \var{parent-rtd} or \schfalse.
If it is \schfalse, a default constructor descriptor is assumed, whose
constructor accepts as many values as there are fields and initializes
the fields to the arguments.
In the extension case, \var{p} is a procedure that accepts the same number
of arguments as the constructor of \var{parent-constructor-descriptor}
and returns a procedure \var{new}, which, as above,
expects one parameter for every field of \var{rtd} (not including parent
fields) and returns a record instance with the fields of \var{rtd}
initialized to its arguments and the fields of \var{parent-rtd} and
its parents initialized by the constructor of
\var{parent-constructor-descriptor}.
A simple \var{protocol} in this case might be written as follows.

\begin{scheme}
(lambda (\var{p})
  (lambda (x1 \ldots v1 \ldots)
    (let ((\var{new} (\var{p} x \ldots)))
      (\var{new} v1 \ldots))))
\end{scheme}

This passes some number of arguments {\tt x1 \ldots} to \var{p} for the
constructor of \var{parent-constructor-descriptor} and calls \var{new}
with {\tt v1 \ldots} to initialize the child fields.

The constructor descriptors for a record type form a chain of
protocols exactly parallel to the chain of record-type parents. Each
constructor descriptor in the chain determines the field values for the
associated record type.
Child record constructors need not know the number or contents of parent
fields, only the number of arguments required by the parent constructor.

\var{protocol} may be \schfalse, specifying a default, only
if \var{rtd} is not an extension of another record
type, or, if it is, if the parent constructor-descriptor
encapsulates a default protocol. In the first case, the
default \var{protocol} procedure is equivalent to the following:

\begin{scheme}
(lambda (p)
  (lambda field-values
    (apply p field-values)))
\end{scheme}

or, simply, {\cf (lambda (\var{p}) \var{p})}.

In the second case, the default \var{protocol} procedure returns a
constructor that accepts one argument for each of the record type's
complete set of 
fields (including those of the parent record type, the parent's parent 
record type, etc.) and returns a record with the fields initialized to
those arguments, with the field values for the parent coming before
those of the extension in the argument list.

Even if \var{rtd} extends another record type,
\var{parent-constructor-descriptor} may also be \schfalse, in which case a
constructor with default protocol is supplied.

\implresp If \var{protocol} is a procedure, the implementation must
check the restrictions on it to the extent performed by applying it as
described when the constructor is called.

\begin{rationale}
  The constructor-descriptor mechanism is an infra\-struc\-ture for
  creating specialized constructors, rather than just creating default
  constructors that accept the initial values of all the fields as
  arguments. This infrastructure achieves full generality while
  leaving each level of an inheritance hierarchy in control over its
  own fields and allowing child record definitions to be abstracted
  away from the actual number and contents of parent fields.

  The design allows the initial values of the fields to be specially
  computed or to default to constant values. It also allows for
  operations to be performed on or with the resulting record, such as
  the registration of a record for finalization. Moreover, the
  constructor-descriptor mechanism allows the creation of such
  initializers in a modular manner, separating the initialization
  concerns of the parent types from those of the extensions.
  
  The mechanism described here achieves complete generality without
  cluttering the syntactic layer, sacrificing a bit of
  notational convenience in special cases.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{record-constructor}{ constructor-descriptor}{procedure}}
   
Calls the \var{protocol} of \var{constructor-descriptor} (as described for
{\cf make-record-constructor-descriptor}) and returns the resulting
construction procedure \var{constructor} for instances of the record type
associated with \var{constructor-descriptor}.

Two values created by \var{constructor} are equal according to {\cf
  equal?} iff they are {\cf eqv?}, provided their record type is not
used to implement any of the types explicitly mentioned in the
definition of {\cf equal?}.

For any \var{constructor} returned by {\cf record-constructor},
the following holds:

\begin{scheme}
(let ((r (\var{constructor} v \ldots)))
  (eqv? r r))                \ev \schtrue
\end{scheme}

For mutable records, but not necessarily for immutable ones, the following
hold.
(A record of a mutable record type is mutable;
a record of an immutable record type is immutable.)

\begin{scheme}
(let ((r (\var{constructor} v \ldots)))
  (eq? r r))                 \ev \schtrue

(let ((f (lambda () (\var{constructor} v \ldots))))
  (eq? (f) (f)))             \ev \schfalse
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{record-predicate}{ rtd}{procedure}}
   
Returns a procedure that, given an object \var{obj}, returns
a Boolean that is \schtrue{}
iff \var{obj} is a record of the type represented by
\var{rtd}.
\end{entry}

\begin{entry}{%
\proto{record-accessor}{ rtd k}{procedure}}

\domain{\var{K} must be a valid field index  of \var{rtd}.}
The {\cf record-accessor} procedure returns a one-argument procedure that, given a
record of the type represented by \var{rtd}, returns the value of the
selected field of that record.

The field selected is the one corresponding the \var{k}th element
(0-based) of the \var{fields} argument to the invocation of {\cf
  make-record-type-descriptor} that created \var{rtd}. Note that
\var{k} cannot be used to specify a field of any type \var{rtd} extends.

If the accessor procedure is given something other than
a record of the type represented by \var{rtd}, an exception with
condition type {\cf\&assertion} is raised.  Records
of the type represented by \var{rtd} include records of extensions of
the type represented by \var{rtd}.
\end{entry}

\begin{entry}{%
\proto{record-mutator}{ rtd k}{procedure}}
   
\domain{\var{K} must be a valid field index  of \var{rtd}.}
The {\cf record-mutator} procedure returns a two-argument procedure that, given a
record \var{r} of the type represented by \var{rtd} and an object
\var{obj}, stores \var{obj} within the field of \var{r} specified by
\var{k}. The \var{k} argument is as in {\cf record-accessor}. If
\var{k} specifies an immutable field, an exception with condition type
{\cf\&assertion} is raised.
The mutator returns the unspecified value.
\end{entry}

\begin{scheme}
(define :point
  (make-record-type-descriptor
    'point \schfalse{}
    \schfalse{} \schfalse{} \schfalse{} 
    '\sharpsign((mutable x) (mutable y))))

(define make-point
  (record-constructor
    (make-record-constructor-descriptor :point
      \schfalse{} \schfalse{})))

(define point? (record-predicate :point))
(define point-x (record-accessor :point 0))
(define point-y (record-accessor :point 1))
(define point-x-set! (record-mutator :point 0))
(define point-y-set! (record-mutator :point 1))

(define p1 (make-point 1 2))
(point? p1) \ev \schtrue{}
(point-x p1) \ev 1
(point-y p1) \ev 2
(point-x-set! p1 5) \ev \theunspecified
(point-x p1) \ev 5

(define :point2
  (make-record-type-descriptor
    'point2 :point 
    \schfalse{} \schfalse{} \schfalse{} '\sharpsign((mutable x) (mutable y))))

(define make-point2
  (record-constructor
    (make-record-constructor-descriptor :point2
      \schfalse{} \schfalse{})))
(define point2? (record-predicate :point2))
(define point2-xx (record-accessor :point2 0))
(define point2-yy (record-accessor :point2 1))

(define p2 (make-point2 1 2 3 4))
(point? p2) \ev \schtrue{}
(point-x p2) \ev 1
(point-y p2) \ev 2
(point2-xx p2) \ev 3
(point2-yy p2) \ev 4
\end{scheme}

\section{Explicit-naming syntactic layer}
\label{recordsexplicitnamingsection}

The explicit-naming syntactic layer is provided by the
\deflibrary{r6rs records explicit} library.

The record-type-defining form {\cf define-record-type} is a definition and
can appear anywhere any other \hyper{definition} can appear.

\begin{entry}{%
\proto{define-record-type}{ \hyper{name spec} \arbno{\hyper{record clause}}}{\exprtype}}

A {\cf define-record-type} form defines a record type along with
associated constructor descriptor and constructor, predicate, field
accessors, and field mutators. The {\cf define-record-type} form expands into
a set of definitions in the environment where {\cf define-record-type}
appears; hence, it is possible to refer to the bindings (except for
that of the record type itself) recursively.

The \hyper{name spec} specifies the names of the record type,
construction procedure, and predicate. It must take the following
form.

\begin{scheme}
(\hyper{record name} \hyper{constructor name} \hyper{predicate name})
\end{scheme}

\hyper{Record name}, \hyper{constructor name}, and \hyper{predicate
  name} must all be identifiers.

\hyper{Record name}, taken as a symbol, becomes the name of the record
type.  Additionally, it is bound by this definition to an expand-time
or run-time description of the record type for use as parent name in
syntactic record-type definitions that extend this definition. It may
also be used as a handle to gain access to the underlying record-type
descriptor and constructor descriptor (see {\cf
  record-type-descriptor} and {\cf record-constructor-descriptor}
below).

\hyper{Constructor name} is defined by this definition to be a
constructor for the defined record type, with a protocol specified by
the {\cf protocol} clause, or, in its absence, using a default protocol. For
details, see the description of the {\cf protocol} clause below.

\hyper{Predicate name} is defined by this definition to a predicate
for the defined record type.

Each \hyper{record clause} must take one of the following forms; it is
a syntax violation if multiple \hyper{record clause}s of the same kind appear in a
{\cf define-record-type} form.

\begin{itemize}
\item {\tt (fields \arbno{\hyper{field-spec}})}
   
  where each \hyper{field-spec} has one of the following forms
  
\begin{scheme}
(immutable \hyper{field name} \hyper{accessor name})
(mutable \hyper{field name}
         \hyper{accessor name} \hyper{mutator name})
\end{scheme}

  \hyper{Field name}, \hyper{accessor name}, and \hyper{mutator name}
  must all be identifiers. The first form declares an immutable field
  called \hyper{field name}, with the corresponding accessor named \hyper{accessor
  name}. The second form declares a mutable field called \hyper{field name},
  with the corresponding accessor named \hyper{accessor name}, and with the
  corresponding mutator named \hyper{mutator name}.
   
  The \hyper{field name}s become, as symbols, the names of the fields of the
  record type being created, in the same order. They are not used in any
  other way.
   
\item {\tt (parent \hyper{parent name})}
   
  This specifies that the record type is to have parent type
  \hyper{parent name}, where \hyper{parent name} is the \hyper{record
      name} of a record type previously defined using {\cf
      define-record-type}. The absence of a {\cf parent} clause implies a
    record type with no parent type.
   
\item {\tt (protocol \hyper{expression})}
   
  \hyper{Expression} is evaluated in the same environment as the
  define-record-type form, and must evaluate to a protocol appropriate
  for the record type being defined (see the description of
  {\cf make-record-constructor-descriptor}). The protocol is used to
  create a record-constructor descriptor where, if the record type
  being defined has a parent, the parent-type constructor descriptor
  is the one associated with the parent type specified in the {\cf
    parent} clause.
   
  If no {\cf protocol} clause is specified, a constructor descriptor
  is still created using a default protocol. The rules for this are
  the same as for {\cf make-record-constructor-descriptor}: the clause
  can be absent only if the record type defined has no parent type, or
  if the parent definition does not specify a protocol.
   
\item {\tt (sealed \schtrue)}\\
  {\tt (sealed \schfalse)}
   
  If this option is specified with operand \schtrue, the defined
  record type is sealed.  If this option is specified with operand
  \schfalse, or is absent, the defined record type is not sealed.
   
\item {\tt (opaque \schtrue)}\\
  {\tt (opaque \schfalse)}
   
  If this option is specified with operand \schtrue, or if an opaque
  parent record type is specified, the defined record type is opaque.
  Otherwise, the defined record type is not opaque.
   
\item {\tt (nongenerative \hyper{uid})}\\
{\tt (nongenerative)}
   
  This specifies that the record type is nongenerative with uid
  \hyper{uid}, which must be an \hyper{identifier}.
  If \hyper{uid} is absent, a unique uid is generated at macro-expansion time.
  If two record-type definitions specify the same \var{uid}, then
  the implied arguments to {\cf make-record-type-descriptor}
  must be equivalent as described under {\cf make-record-type-descriptor}.
  If this condition is not met, it is either considered a syntax violation or
  an exception with condition type {\cf\&assertion} is raised.
  If the condition is met, a single record type is generated for both
  definitions.

  In the absence of a {\cf nongenerative} clause, a new record type is
  generated every time a {\cf define-record-type} form is evaluated:

\begin{scheme}
(let ((f (lambda (x)
           (define-record-type r \ldots)
           (if x r? (make-r \ldots)))))
  ((f \schtrue) (f \schfalse))) \ev \schfalse{}
\end{scheme}
\end{itemize}

All bindings created by {\cf define-record-type} (for the record type,
the construction procedure, the predicate, the accessors, and the
mutators) must have names that are pairwise distinct.
\end{entry}

\begin{entry}{%
\proto{record-type-descriptor}{ \hyper{record name}}{\exprtype}}
   
Evaluates to the record-type descriptor associated with the type
specified by \hyper{record-name}.
   
Note that {\cf record-type-descriptor} works on both opaque and non-opaque record
types.
\end{entry}

\begin{entry}{%
\proto{record-constructor-descriptor}{ \hyper{record name}}{\exprtype}}
   
Evaluates to the record-constructor descriptor associated with
\hyper{record name}.
\end{entry}

Explicit-naming syntactic-layer examples:

\begin{scheme}
(define-record-type (point3 make-point3 point3?)
  (fields (immutable x point3-x)
          (mutable y point3-y set-point3-y!))
  (nongenerative
    point3-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point3)
  (protocol
   (lambda (p)
     (lambda (x y c) 
       ((p x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p3-1 (make-point3 1 2))
(define p3-2 (make-cpoint 3 4 'red))

(point3? p3-1) \ev \schtrue{}
(point3? p3-2) \ev \schtrue{}
(point3? (vector)) \ev \schfalse{}
(point3? (cons 'a 'b)) \ev \schfalse{}
(cpoint? p3-1) \ev \schfalse{}
(cpoint? p3-2) \ev \schtrue{}
(point3-x p3-1) \ev 1
(point3-y p3-1) \ev 2
(point3-x p3-2) \ev 3
(point3-y p3-2) \ev 4
(cpoint-rgb p3-2) \ev '(rgb . red)

(set-point3-y! p3-1 17)
(point3-y p3-1) \ev 17)

(record-rtd p3-1) \lev (record-type-descriptor point3)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (new) (lambda a (new a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))
(ex1-f ex1-i1) \ev '(1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (new) (lambda (a . b) (new a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))
(ex2-a ex2-i1) \ev 1
(ex2-b ex2-i1) \ev '(2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (new)
     (lambda (x y z)
       (let ((length 
               (sqrt (+ (* x x) (* y y) (* z z)))))
         (new (/ x length)
              (/ y length)
              (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))
\end{scheme}

\section{Implicit-naming syntactic layer}

The implicit-naming syntactic layer is provided by the
\deflibrary{r6rs records implicit} library.

The {\cf define-record-type} form of the implicit-naming syntactic
layer is a conservative extension of the {\cf define-record-type} form
of the explicit-naming layer: a {\cf define-record-type} form that
conforms to the syntax of the explicit-naming layer also conforms to
the syntax of the implicit-naming layer, and any definition in the
implicit-naming layer can be understood by its translation into the
explicit-naming layer.

This means that a record type defined by the {\cf define-record-type}
form of either layer can be used by the other.

The implicit-naming syntactic layer extends the explicit-naming layer
in two ways. First, \hyper{name-spec} may be a single identifier
representing just the record name. In this case, the name of the
construction procedure is generated by prefixing the record name with
{\tt make-}, and the predicate name is generated by adding a question
mark ({\tt ?}) to the end of the record name. For example, if the
record name is {\tt frob}, the name of the construction procedure is
{\tt make-frob}, and the predicate name is {\tt frob?}.

Second, the syntax of \hyper{field-spec} is extended to allow the
accessor and mutator names to be omitted. That is, \hyper{field-spec}
can take one of the following forms as well as the forms described in
the preceding section.

\begin{scheme}
(immutable \hyper{field name})
(mutable \hyper{field name})%
\end{scheme}

If \hyper{field-spec} takes one of these forms, the accessor name
is generated by appending the record name and field name with a hyphen
separator, and the mutator name (for a mutable field) is generated by
adding a {\tt -set!} suffix to the accessor name. For example, if the
record name is {\tt frob} and the field name is {\tt widget}, the
accessor name is {\tt frob-widget} and the mutator name is
{\tt frob-widget-set!}.

Third, the syntax of \hyper{field-spec} is also extended to consist of
just the field name.  The corresponding field is assumed to be immutable.

Any definition that takes advantage of implicit naming can be
rewritten trivially to a definition that conforms to the syntax of the
explicit-naming layer merely by specifying the names explicitly. For
example, the implicit-naming layer record definition:

\begin{scheme}
(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

is equivalent to the following explicit-naming layer record definition.

\begin{scheme}
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget frob-widget-set!))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

Also, the implicit-naming layer record definition:

\begin{scheme}
(define-record-type point (fields x y))%
\end{scheme}

is equivalent to the following explicit-naming layer record
definition:

\begin{scheme}
(define-record-type (point make-point point?)
  (fields 
    (immutable x point-x)
    (immutable y point-y)))%
\end{scheme}

With the implicit-naming layer, one can choose to specify just some of
the names explicitly; for example, the following overrides the choice
of accessor and mutator names for the widget field.

\begin{scheme}
(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

\begin{scheme}
(define *ex3-instance* \schfalse{})

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (p)
     (lambda (x y t)
       (let ((r ((p x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields 
   (mutable thickness))
  (sealed \schtrue{}) (opaque \schtrue{}))

(define ex3-i1 (make-ex3 1 2 17))
(ex3? ex3-i1) \ev \schtrue{}
(cpoint-rgb ex3-i1) \ev '(rgb . red)
(ex3-thickness ex3-i1) \ev 17
(ex3-thickness-set! ex3-i1 18)
(ex3-thickness ex3-i1) \ev 18
{}*ex3-instance* \ev ex3-i1

(record? ex3-i1) \ev \schfalse{}
\end{scheme}

\begin{entry}{%
\rproto{record-type-descriptor}{ \hyper{record name}}{\exprtype}}

This is the same as {\cf record-type-descriptor} from the
\library{r6rs records explicit} library.
\end{entry}

\begin{entry}{%
\rproto{record-constructor-descriptor}{ \hyper{record name}}{\exprtype}}
   
This is the same as {\cf record-constructor-descriptor} from the
\library{r6rs records explicit} library.
\end{entry}

\section{Inspection}

The implicit-naming syntactic layer is provided by the
\deflibrary{r6rs records inspection} library.

A set of procedures are provided for inspecting records and their
record-type descriptors. These procedures are designed to allow the
writing of portable printers and inspectors.

Note that {\cf record?} and {\cf record-rtd} treat records of opaque
record types as if they were not records. On the other hand, the
inspection procedures that operate on record-type descriptors
themselves are not affected by opacity. In other words, opacity
controls whether a program can obtain an rtd from an instance. If the
program has access to the original rtd via {\cf
  make-record-type-descriptor} or {\cf record-type-descriptor}, it can
still make use of the inspection procedures.

Any of the standard types mentioned in this report may or may not be
implemented as an opaque record type.  Consequently, {\cf record?},
when applied to an object of one of these types, may return
\schtrue{}.  In this case, inspection is possible for these objects.

\begin{entry}{%
\proto{record?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a record, and its record type is
not opaque. Returns \schfalse{} otherwise.  
\end{entry}

\begin{entry}{%
\proto{record-rtd}{ record}{procedure}}
   
Returns the rtd representing the type of \var{record} if the type is not
opaque. The rtd of the most precise type is returned; that is, the
type \var{t} such that \var{record} is of type \var{t} but not of any
type that extends \var{t}.  If the type is opaque, an exception is
raised with condition type {\cf\&assertion}.
\end{entry}

\begin{entry}{%
\proto{record-type-name}{ rtd}{procedure}}
   
Returns the name of the record-type descriptor \var{rtd}.
\end{entry}   

\begin{entry}{%
\proto{record-type-parent}{ rtd}{procedure}}
   
Returns the parent of the record-type descriptor \var{rtd}, or
\schfalse{} if it has none.
\end{entry}

\begin{entry}{%
\proto{record-type-uid}{ rtd}{procedure}}
   
Returns the uid of the record-type descriptor rtd, or \schfalse{} if it has none.
(An implementation may assign a generated uid to a record type even if the
type is generative, so the return of a uid does not necessarily imply that
the type is nongenerative.)
\end{entry}

\begin{entry}{%
\proto{record-type-generative?}{ rtd}{procedure}}
   
Returns \schtrue{} if \var{rtd} is generative, and \schfalse{} if not.
\end{entry}

\begin{entry}{%
\proto{record-type-sealed?}{ rtd}{procedure}}

Returns a Boolean value indicating whether the record-type descriptor is
sealed.
\end{entry}

\begin{entry}{%
\proto{record-type-opaque?}{ rtd}{procedure}}
   
Returns a Boolean value indicating whether the record-type descriptor is
opaque.
\end{entry}

\begin{entry}{%
\proto{record-type-field-names}{ rtd}{procedure}}
   
Returns a vector of symbols naming the fields of the type represented by \var{rtd}
(not including the fields of parent types) where the fields are ordered as
described under {\cf make-record-type-descriptor}.  The returned
vector may be immutable.
If the returned vector is modified, the effect on 
\var{rtd} is unspecified.
\end{entry}

\begin{entry}{%
\proto{record-field-mutable?}{ rtd k}{procedure}}
   
Returns a Boolean value indicating whether the field specified by
\var{k} of the type represented by \var{rtd} is mutable, where \var{k}
is as in {\cf record-accessor}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
