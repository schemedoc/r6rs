\chapter{Formal syntax and semantics}
\label{formalchapter}

This chapter provides formal descriptions of what has already been
described informally in previous chapters of this report.

\todo{Allow grammar to say that else clause needn't be last?}


\subsection{Expressions}
\label{expressions}

\begin{grammar}%
\meta{expression} \: \meta{variable}
\>  \| \meta{literal}
\>  \| \meta{procedure call}
\>  \| \meta{lambda expression}
\>  \| \meta{conditional}
\>  \| \meta{assignment}
\>  \| \meta{derived expression}
\>  \| \meta{macro use}
\>  \| \meta{macro block}

\meta{literal} \: \meta{quotation} \| \meta{self-evaluating}
\meta{self-evaluating} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string}
\meta{quotation} \: '\meta{datum} \| (quote \meta{datum})
\meta{procedure call} \: (\meta{operator} \arbno{\meta{operand}})
\meta{operator} \: \meta{expression}
\meta{operand} \: \meta{expression}

\meta{lambda expression} \: (lambda \meta{formals} \meta{body})
\meta{formals} \: (\arbno{\meta{variable}}) \| \meta{variable}
\>  \| (\atleastone{\meta{variable}} .\ \meta{variable})
\meta{body} \: \arbno{\meta{definition}} \meta{sequence}
\meta{sequence} \: \arbno{\meta{command}} \meta{expression}
\meta{command} \: \meta{expression}

\meta{conditional} \: (if \meta{test} \meta{consequent} \meta{alternate})
\meta{test} \: \meta{expression}
\meta{consequent} \: \meta{expression}
\meta{alternate} \: \meta{expression} \| \meta{empty}

\meta{assignment} \: (set! \meta{variable} \meta{expression})

\meta{derived expression} \:
\>  \> (cond \atleastone{\meta{cond clause}})
\>  \| (cond \arbno{\meta{cond clause}} (else \meta{sequence}))
\>  \| (c\=ase \meta{expression}
\>       \>\atleastone{\meta{case clause}})
\>  \| (c\=ase \meta{expression}
\>       \>\arbno{\meta{case clause}}
\>       \>(else \meta{sequence}))
\>  \| (and \arbno{\meta{test}})
\>  \| (or \arbno{\meta{test}})
\>  \| (let (\arbno{\meta{binding spec}}) \meta{body})
\>  \| (let \meta{variable} (\arbno{\meta{binding spec}}) \meta{body})
\>  \| (let* (\arbno{\meta{binding spec}}) \meta{body})
\>  \| (letrec* (\arbno{\meta{binding spec}}) \meta{body})
\>  \| (letrec (\arbno{\meta{binding spec}}) \meta{body})
\>  \| (let-values (\arbno{\meta{mv binding spec}}) \meta{body})
\>  \| (let*-values (\arbno{\meta{mv binding spec}}) \meta{body})
\>  \| (begin \meta{sequence})
\>  \| (d\=o \=(\arbno{\meta{iteration spec}})
\>       \>  \>(\meta{test} \meta{do result})
\>       \>\arbno{\meta{command}})
\>  \| (delay \meta{expression})
\>  \| \meta{quasiquotation}

\meta{cond clause} \: (\meta{test} \meta{sequence})
\>   \| (\meta{test})
\>   \| (\meta{test} => \meta{recipient})
\meta{recipient} \: \meta{expression}
\meta{case clause} \: ((\arbno{\meta{datum}}) \meta{sequence})
\meta{binding spec} \: (\meta{variable} \meta{expression})
\meta{mv binding spec} \: (\meta{formals} \meta{expression})
\meta{iteration spec} \: (\meta{variable} \meta{init} \meta{step})
\> \| (\meta{variable} \meta{init})
\meta{init} \: \meta{expression}
\meta{step} \: \meta{expression}
\meta{do result} \: \meta{sequence} \| \meta{empty}

\meta{macro use} \: (\meta{keyword} \arbno{\meta{datum}})
\meta{keyword} \: \meta{identifier}

\meta{macro block} \:
\>  (let-syntax (\arbno{\meta{syntax spec}}) \meta{body})
\>  \| (letrec-syntax (\arbno{\meta{syntax spec}}) \meta{body})
\meta{syntax spec} \: (\meta{keyword} \meta{transformer spec})

\end{grammar}

\subsection{Quasiquotations}

The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for $D = 1, 2,
3, \ldots$.  $D$ keeps track of the nesting depth.

\begin{grammar}%
\meta{quasiquotation} \: \meta{quasiquotation 1}
\meta{qq template 0} \: \meta{expression}
\meta{quasiquotation $D$} \: `\meta{qq template $D$}
\>    \| (quasiquote \meta{qq template $D$})
\meta{qq template $D$} \: \meta{simple datum}
\>    \| \meta{list qq template $D$}
\>    \| \meta{vector qq template $D$}
\>    \| \meta{unquotation $D$}
\meta{list qq template $D$} \: (\arbno{\meta{qq template or splice $D$}})
\>    \| (\atleastone{\meta{qq template or splice $D$}} .\ \meta{qq template $D$})
\>    \| '\meta{qq template $D$}
\>    \| \meta{quasiquotation $D+1$}
\meta{vector qq template $D$} \: \#(\arbno{\meta{qq template or splice $D$}})
\meta{unquotation $D$} \: ,\meta{qq template $D-1$}
\>    \| (unquote \meta{qq template $D-1$})
\meta{qq template or splice $D$} \: \meta{qq template $D$}
\>    \| \meta{splicing unquotation $D$}
\meta{splicing unquotation $D$} \: ,@\meta{qq template $D-1$}
\>    \| (unquote-splicing \arbno{\meta{qq template $D-1$}})
\>    \| (unquote \arbno{\meta{qq template $D-1$}}) %
\end{grammar}

In \meta{quasiquotation}s, a \meta{list qq template $D$} can sometimes
be confused with either an \meta{un\-quota\-tion $D$} or a \meta{splicing
un\-quo\-ta\-tion $D$}.  The interpretation as an
\meta{un\-quo\-ta\-tion} or \meta{splicing
un\-quo\-ta\-tion $D$} takes precedence.

\subsection{Transformers}

\begin{grammar}%
\meta{transformer spec} \:
\> (syntax-rules (\arbno{\meta{identifier}}) \arbno{\meta{syntax rule}})
\meta{syntax rule} \: (\meta{pattern} \meta{template})
\meta{pattern} \: \meta{pattern identifier}
\>  \| (\arbno{\meta{pattern}})
\>  \| (\atleastone{\meta{pattern}} . \meta{pattern})
\>  \| (\arbno{\meta{pattern}} \meta{pattern} \meta{ellipsis})
\>  \| \#(\arbno{\meta{pattern}})
\>  \| \#(\arbno{\meta{pattern}} \meta{pattern} \meta{ellipsis})
\>  \| \meta{pattern datum}
\meta{pattern datum} \: \meta{string}
\>  \| \meta{character}
\>  \| \meta{boolean}
\>  \| \meta{number}
\meta{template} \: \meta{pattern identifier}
\>  \| (\arbno{\meta{template element}})
\>  \| (\atleastone{\meta{template element}} . \meta{template})
\>  \| \#(\arbno{\meta{template element}})
\>  \| \meta{template datum}
\meta{template element} \: \meta{template}
\>  \| \meta{template} \meta{ellipsis}
\meta{template datum} \: \meta{pattern datum}
\meta{pattern identifier} \: \meta{any identifier except {\cf ...}}
\meta{ellipsis} \: \meta{the identifier {\cf ...}}
\end{grammar}

\subsection{Programs and definitions}

\begin{grammar}%
\meta{program} \: \arbno{\meta{command or definition}}
\meta{command or definition} \: \meta{command}
\> \| \meta{definition}
\> \| \meta{syntax definition}
\> \| (begin \atleastone{\meta{command or definition}})
\meta{definition} \: (define \meta{variable} \meta{expression})
\>   \| (define (\meta{variable} \meta{def formals}) \meta{body})
\>   \| (define \meta{variable})
\>   \| (begin \arbno{\meta{definition}})
\meta{def formals} \: \arbno{\meta{variable}}
\>   \| \arbno{\meta{variable}} .\ \meta{variable}
\meta{syntax definition} \:
\>  (define-syntax \meta{keyword} \meta{transformer spec})
\end{grammar}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
