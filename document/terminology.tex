%\vfill\eject
\chapter{Notation and terminology}
\label{terminologychapter}

\section{Requirement levels} 
\label{requirementsection}

The key words ``must'', ``must not'', ``required'', ``shall'', ``shall
not'', ``should'', ``should not'', ``recommended'', ``may'', and
``optional'' in this document are to be interpreted as described in
RFC~2119~\cite{mustard}.  Specifically:

\begin{description}
\item[must]\mainindex{must} This word means that a statement is an absolute
  requirement of the specification.
\item[must not]\mainindex{must not} This phrase means that a statement is an absolute
  prohibition of the specification.
\item[should]\mainindex{should} This word, or the adjective ``recommended'', mean that
  valid reasons may exist in particular circumstances to ignore a
  statement, but that the implications must be understood and weighed
  before choosing a different course.
\item[should not]\mainindex{should not} This phrase, or the phrase ``not recommended'', mean
  that valid reasons max exist in particular circumstances when the
  behavior of a statement is acceptable, but that the implications
  should be understood and weighed before choosing the course described
  by the statement.
\item[may]\mainindex{may} This word, or the adjective ``optional'', mean that an item
  is truly optional.
\end{description}

\section{Entry format}

The chapters describing bindings in the base library and the standard
libraries are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
built-in procedure.  An entry begins with one or more header lines of the form

\noindent\pproto{\var{template}}{\var{category}}\unpenalty

If \var{category} is ``\exprtype'', the entry describes a 
special syntactic form, and the template gives the syntax of the form.  Even
though the template is written in a notation similar to a right-hand
side of the BNF rules in chapter~\ref{readsyntaxchapter}, it describes
the set of forms equivalent to the forms matching the
template as syntactic datums.  Some ``\exprtype'' entries carry a
suffix ({\cf expand}), specifying that the form is exported with level
$1$.  Otherwise, the form is exported with level $0$; see
section~\ref{phasessection}.

Components of the form described by a template are designated
by syntactic variables, which are written using angle brackets, for
example, \hyper{expression}, \hyper{variable}.  Case is insignificant
in syntactic variables.  Syntactic variables
denote other forms, or, in some cases,
sequences of them.  A syntactic variable may refer to a non-terminal
in the grammar for syntactic datums, in which case only forms matching
that non-terminal are permissible in that position.  For example,
\hyper{expression} stands for any form which is a
syntactically valid expression.  Other non-terminals that are used in
templates will be defined as part of the specification.

The notation
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
indicates zero or more occurrences of a \hyper{thing}, and
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
indicates one or more occurrences of a \hyper{thing}.

It is the programmer's responsibility to ensure that the component of
a form has the shape specified by a template.  Descriptions of syntax
may express other restrictions on the components of a form.
Typically, such a restriction is formulated as a phrase of the form
``\hyper{x} must be\mainindex{must be} a \ldots''.  Again, these
specify the programmer's responsibility.  It is the implementation's
responsibility to check that these restrictions are satisfied, as long
as the macro transformers involved in expanding the form terminate.
If the implementation detects that a component does not meet the
restriction, an exception with condition type {\cf\&syntax} is raised.

If \var{category} is ``procedure'', then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Parameter
names in the template are \var{italicized}.  Thus the header line

\noindent\pproto{(vector-ref \var{vector} \var{k})}{procedure}\unpenalty

indicates that the built-in procedure {\tt vector-ref} takes
two arguments, a vector \var{vector} and an exact non-negative integer
\var{k} (see below).  The header lines

\noindent%
\pproto{(make-vector \var{k})}{procedure}
\pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty

indicate that the {\tt make-vector} procedure takes
either one or two arguments.  The parameter names are
case-insensitive: \var{Vector} is the same as \var{vector}.

As with syntax templates, an ellipsis \dotsfoo{} at the end of a header
line, as in

\noindent\pproto{(= \vari{z} \varii{z} \variii{z} \dotsfoo)}{procedure}\unpenalty

indicates that the procedure takes arbitrarily many arguments of the
same type as specified for the last parameter name.  In this case,
{\cf =} accepts two or more arguments that must all be complex
numbers.

\label{typeconventions}
A procedure that detects an argument that it is not specified to
handle must either raise an exception with condition type
{\cf\&assertion} or abort the execution of the program.  Also, if the
number of arguments provided in a procedure call does not match any
argument count specified for the called procedure, an exception with
condition type {\cf\&assertion} must be raised or the execution of the
program must be aborted.  See section~\ref{argumentcheckingsection}.

For succinctness, we follow the convention
that if a parameter name is also the name of a type, then the corresponding argument must be of the named type.
For example, the header line for {\tt vector-ref} given above dictates that the
first argument to {\tt vector-ref} must be a vector.  The following naming
conventions imply type restrictions:
%
\begin{center}
\begin{tabular}{ll}
\var{obj}&any object\\
\var{z}&complex number\\
\var{x}&real number\\
\var{y}&real number\\
\var{q}&rational number\\
\var{n}&integer\\
\var{k}&exact non-negative integer\\
\var{octet}&exact integer in $\{0, \ldots, 255\}$\\
\var{byte}&exact integer in $\{-128, \ldots, 127\}$\\
\var{char}&character (see section~\ref{charactersection})\\
\var{pair}&pair (see section~\ref{listsection})\\
\var{vector}&vector (see section~\ref{vectorsection})\\
\var{string}&string (see section~\ref{stringsection})\\
\var{condition}&condition (see library section~\extref{lib:conditionssection}{Conditions})\\
\var{bytevector}&bytevector (see library chapter~\extref{lib:bytevectorschapter}{Bytevectors})\\
\var{proc}&procedure (see section~\ref{proceduressection})
\end{tabular}
\end{center}

Other type restrictions are expressed through parameter naming
conventions that are described in specific chapters.  For example,
library chapter~\extref{lib:numberchapter}{Arithmetic} uses a number of special
parameter variables for the various subsets of the numbers.

With the listed type restrictions, the programmer's responsibility of
ensuring that the corresponding argument is of the specified type
corresponds to the implementation's responsibility of checking for
that type, see section~\ref{argumentcheckingsection}.

The \var{list} parameter naming conventions means that it is the
programmer's responsibility to pass a list argument (see
section~\ref{listsection}).  It is the implementation's responsibility
to check that the argument is appropriately structured for the
operation to perform its function, to the extent that this is possible
and reasonable.  The implementation must at least check that the
argument is either an empty list or a pair.

Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form ``\var{x} must be a \ldots''. (or otherwise
using the word ``must''.) 

If the description does not explicitly distinguish between the
programmer's and the implementation's responsibilities, the
restrictions describe both the programmer's responsibility, who must
ensure that an appropriate argument is passed, and the
implementation's responsibilities, which must check that the argument
is appropriate.  A description may explicitly list the
implementation's responsibilities for some arguments in a paragraph
labelled ``\textit{Implementation responsibilities}''.  In that case,
the responsibilities specified for these arguments in the rest of the
description are only for the programmer.

If \var{category} is something other than ``syntax'' and
``procedure'', then the entry describes a non-procedural value, and
the \var{category} describes the type of that value.  The header line

\noindent\rvproto{\&who}{condition type}

indicates that {\cf\&who} is a condition type.

The description of an entry occasionally states that it is \textit{the
  same} as another entry.  This means that both entries are
equivalent.  Specifically, it means that if both entries have the same
name and are thus exported from different libraries, the entries from
both libraries can be imported under the same name without conflict.

\section{Evaluation examples}

The symbol ``\evalsto'' used in program examples can be read
``evaluates to''.  For example,

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

means that the expression {\tt(* 5 8)} evaluates to the object {\tt 40}.
Or, more precisely:  the expression given by the sequence of characters
``{\tt(* 5 8)}'' evaluates, in the initial environment, to an object
that may be represented externally by the sequence of characters ``{\tt
40}''.  See section~\ref{readsyntaxsection} for a discussion of external
representations of objects.

The ``\evalsto'' symbol is also used when the evaluation of an
expression causes a violation.  For example,

\begin{scheme}
(integer->char \sharpsign{}xD800) \ev \exception{\&assertion}
\end{scheme}

means that the evaluation of the expression {\cf (integer->char
  \sharpsign{}xD800)} must raise an exception with condition type
{\cf\&assertion} or abort the execution of the program.

\section{Unspecified behavior}

\vest If the value of an expression is said to be ``unspecified'',
then the expression must evaluate without raising an exception, but
the values returned depend on the implementation; this report
explicitly does not say what values should be returned.
\mainindex{unspecified behavior}

Some expressions are specified to return \emph{the} unspecified value,
which is a special value returned by the \texttt{unspecified}
procedure.  (See section~\ref{unspecifiedvalue}.)  In this case, the
return value is meaningless, and programmers are discouraged from
relying on its specific nature.

\section{Exceptional situations}

When speaking of an exceptional situation (see section~\ref{exceptionalsituationsection}), this
report uses the phrase ``an exception is raised'' to indicate
that implementations must detect the situation and report it to the
program through the exception system described in
library chapter~\extref{lib:exceptionsconditionschapter}{Exceptions
  and conditions}.

Several variations on ``an exception is raised'' using the keywords
described in section~\ref{requirementsection} are possible, in
particular ``an exception must be raised'' (equivalent to ``an
exception is raised''), ``an exception should be raised'', and ``an
exception may be raised''.

This report uses the phrase ``an exception with condition type \var{t}''
to indicate that the object provided with the
exception is a condition object of the specified type.

The phrase ``a continuable exception is raised'' indicates an
exceptional situation that permits the exception handler to return,
thereby allowing program execution to continue at the place where the
original exception occurred.  See library
section~\extref{lib:exceptionssection}{Exceptions}.

\section{Naming conventions}

By convention, the names of procedures that store values into previously
allocated locations (see section~\ref{storagemodel}) usually end in
``\ide{!}''.
Such procedures are called mutation procedures.
By convention, the value returned by a mutation procedure is
\unspecifiedreturn{} (see section~\ref{unspecifiedvalue}),
but this convention is not always followed.

By convention, ``\ide{->}'' appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, {\cf list->vector} takes a list and returns a vector whose
elements are the same as those of the list.

By convention, the names of condition types usually start with
``{\cf\&}''\index{&@\texttt{\&}}.

By convention, the names of predicates---procedures that always return
a boolean value---end in ``\ide{?}'' when the name contains any
letters; otherwise, the predicate's name does not end with a question
mark.

The components of compound names are usually separated by ``\ide{-}''
In particular, prefixes that are actual words or can be pronounced as
though they were actual words are followed by a hyphen, except when
the first character following the hyphen would be something other than
a letter, in which case the hyphen is omitted.  Short,
unpronounceable prefixes (``\ide{fx}'' and ``\ide{fl}'') are not
followed by a hyphen.

\section{Syntax violations}

Scheme implementations conformant with this report must detect
violations of the syntax.  A \defining{syntax violation} is an error
with respect to the syntax of library bodies, top-level bodies,
or the ``\exprtype'' entries in the
specification of the base library or the standard libraries.
Moreover, attempting to assign to an immutable variable (i.e., the
variables exported by a library; see
section~\ref{importsareimmutablesection}) is also
considered a syntax violation.

If a top-level or library form is not syntactically correct, then the
execution of that top-level program or library must not be allowed to begin.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
