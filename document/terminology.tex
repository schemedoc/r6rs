%\vfill\eject
\chapter{Notation and terminology}
\label{terminologychapter}

\section{Entry format}

The chapters describing bindings in the base library and the standard
libraries are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
built-in procedure.  An entry begins with one or more header lines of the form

\noindent\pproto{\var{template}}{\var{category}}\unpenalty

If \var{category} is ``\exprtype'', the entry describes a 
special syntactic form, and the template gives the syntax of the form.  Even
though the template is written in a notation similar to a right-hand
side of the BNF rules in chapter~\ref{readsyntaxchapter}, it describes
the set of forms equivalent to the forms matching the
template as syntactic datums.

Components of the form described by a template are designated
by syntactic variables, which are written using angle brackets, for
example, \hyper{expression}, \hyper{variable}.  Case is insignificant
in syntactic variables.  Syntactic variables
should be understood to denote other forms, or, in some cases,
sequences of them.  A syntactic variable may refer to a non-terminal
in the grammar for syntactic datums, in which case only forms matching
that non-terminal are permissible in that position.  For example,
\hyper{expression} stands for any form which is a
syntactically valid expression.  Other non-terminals that are used in
templates will be defined as part of the specification.

The notation
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
indicates zero or more occurrences of a \hyper{thing}, and
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
indicates one or more occurrences of a \hyper{thing}.

It is a syntax violation if a component of a form does not have the
shape specified by a template---an exception with condition type
{\cf\&syntax} is raised at expansion time.

Descriptions of syntax may express other restrictions on the
components of a form.  Typically, such a restriction is formulated
as a phrase of the form ``\hyper{x} must be a \ldots'' (or otherwise
using the word ``must.'')  As with
implicit restrictions, such a phrase means that an exception with
condition type {\cf\&syntax} is raised if the component does not
meet the restriction.


If \var{category} is ``procedure'', then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Parameter
names in the template are \var{italicized}.  Thus the header line

\noindent\pproto{(vector-ref \var{vector} \var{k})}{procedure}\unpenalty

indicates that the built-in procedure {\tt vector-ref} takes
two arguments, a vector \var{vector} and an exact non-negative integer
\var{k} (see below).  The header lines

\noindent%
\pproto{(make-vector \var{k})}{procedure}
\pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty

indicate that the {\tt make-vector} procedure takes
either one or two arguments.  The parameter names are
case-insensitive: \var{Vector} is the same as \var{vector}.

\label{typeconventions}
A procedure that is called with an argument that it is not
specified to handle raises an exception with condition type
{\cf\&contract}.  Also, if the number of arguments provided in
a procedure call does not match any argument count specified for the
called procedure, an exception with condition type {\cf\&contract}
must be raised.

For succinctness, we follow the convention
that if a parameter name is also the name of a type, then the corresponding argument must be of the named type.
For example, the header line for {\tt vector-ref} given above dictates that the
first argument to {\tt vector-ref} must be a vector.  The following naming
conventions imply type restrictions:
\newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
$$
\begin{tabular}{ll}
\var{obj}&any object\\
\var{z}&complex number\\
\var{x}&real number\\
\var{y}&real number\\
\var{q}&rational number\\
\var{n}&integer\\
\var{k}&exact non-negative integer\\
\var{octet}&exact integer in $$\{0, \ldots, 255\}\\
\var{byte}&exact integer in $$\{-128, \ldots, 127\}\\
\var{char}&character (see section~\ref{charactersection})\\
\var{pair}&pair (see section~\ref{listsection})\\
\var{list}&list (see section~\ref{listargumentssection})\\
\var{vector}&vector (see section~\ref{vectorsection})\\
\var{string}&string (see section~\ref{stringsection})\\
\var{condition}&condition (see section~\ref{conditionssection})\\
\var{bytes}&bytes object (see chapter~\ref{byteschapter})\\
\var{proc}&procedure (see section~\ref{proceduressection})

\end{tabular}
$$

Other type restrictions are expressed through parameter naming
conventions that are described in specific chapters.  For
example, chapter~\ref{numberchapter} uses a number of special parameter
variables for the various subsets of the numbers.

Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form ``\var{x} must be a \ldots'' (or otherwise
using the word ``must.'')  As with
implicit restrictions, such a phrase means that an exception with
condition type {\cf\&contract} is raised if the argument does not
meet the restriction.

If \var{category} is something other than ``syntax'' and
``procedure,'' then the entry describes a non-procedural value, and
the \var{category} describes the type of that value.  The header line

\noindent\rvproto{\&who}{condition type}

indicates that {\cf\&who} is a condition type.

The description of an entry occasionally states that it is \textit{the
  same} as another entry.  This means that both entries are
equivalent.  Specifically, it means that if both entries have the same
name and are thus exported from different libraries, the entries from
both libraries can be imported under the same name without conflict.

\section{Boolean values}
\label{booleanvaluessection}

Although there is a separate boolean type, any Scheme value can be
used as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
\schfalse{}.  This report uses the word ``true'' to refer to any
Scheme value except \schfalse{}, and the word ``false'' to refer to
\schfalse{}. \mainindex{true} \mainindex{false}

\section{List arguments}
\label{listargumentssection}

List arguments are immutable in programs that do not make use of the
\library{r6rs mutable-pairs} library.  In such programs, a procedure accepting a list as an
argument can check whether the argument is a list by traversing it.

In programs that mutate pairs through use of the \library{r6rs
  mutable-pairs} library, a pair
that is the head of a list at one moment may not always be the head of
a list.  Thus a traversal of the structure cannot by itself guarantee
that the structure is a list; one must also know that no concurrent or
interleaved computation can mutate the pairs of the structure.
This greatly complicates the description of how certain procedures
must verify that their arguments are valid.

For that reason, the specifications of procedures that accept lists
generally assume that those lists are not mutated.
Section~\ref{mutablelistargumentsection} relaxes that assumption
and states more precise restrictions on the arguments to these
procedures.

\section{Evaluation examples}

The symbol ``\evalsto'' used in program examples should be read
``evaluates to.''  For example,

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

means that the expression {\tt(* 5 8)} evaluates to the object {\tt 40}.
Or, more precisely:  the expression given by the sequence of characters
``{\tt(* 5 8)}'' evaluates, in the initial environment, to an object
that may be represented externally by the sequence of characters ``{\tt
40}''.  See section~\ref{readsyntaxsection} for a discussion of external
representations of objects.

The ``\evalsto'' symbol is also used when the evaluation of an
expression raises an exception.  For example,

\begin{scheme}
(integer->char \sharpsign{}xD800) \ev \exception{\&contract}
\end{scheme}

means that the evaluation of the expression {\cf (integer->char
  \sharpsign{}xD800)} causes an exception with condition type
{\cf\&contract} to be raised.

\section{Unspecified behavior}

\vest If the value of an expression is said to be ``unspecified,''
then the expression must evaluate without raising an exception, but
the values returned depends on the implementation; this report
explicitly does not say what values should be returned.
\mainindex{unspecified behavior}

Some expressions are specified to return \emph{the} unspecified value,
which is a special value returned by the \texttt{unspecified}
procedure.  (See section~\ref{unspecifiedvalue}.)  In this case, the
return value is meaningless, and programmers are discouraged from
relying on its specific nature.

\section{Exceptional situations}

When speaking of an exceptional situation (see section~\ref{exceptionalsituationsection}), this
report uses the phrase ``an exception is raised'' to indicate
that implementations must detect the situation and report it to the
program through the exception system described in
chapter~\ref{exceptionsconditionschapter}.

Several variations on ``an exception is raised'' are possible:

\begin{itemize}
\item ``An exception should be raised'' means that implementations
  are encouraged, but not required, to detect the situation
  and to raise an exception.

\item ``An exception may be raised'' means that implementations
are allowed, but not required or encouraged, to detect
the situation and to raise an exception.

\item ``An exception might be raised'' means that implementations
are allowed, but discouraged, to detect the situation
and to raise an exception.
\end{itemize}

This report uses the phrase ``an exception with condition type \var{t}''
to indicate that the object provided with the
exception is a condition object of the specified type.

The phrase ``a continuable exception is raised'' indicates
an exceptional situation that permits the exception handler to return,
thereby allowing program execution to continue at the place where the
original exception occurred.  See sectionj~\ref{exceptionssection}.

\vest For example, an exception with condition type {\cf\&contract}
is raised if a procedure is passed an argument that the procedure
is not explicitly specified to handle, even though such domain
exceptions are not always mentioned in this report.

\section{Naming conventions}

By convention, the names of procedures that always return a boolean
value usually end
in ``\ide{?}''.  Such procedures are called predicates.

By convention, the names of procedures that store values into previously
allocated locations (see section~\ref{storagemodel}) usually end in
``\ide{!}''.
Such procedures are called mutation procedures.
By convention, the value returned by a mutation procedure is
\unspecifiedreturn{} (see section~\ref{unspecifiedvalue}),
but this convention is not always followed.

By convention, ``\ide{->}'' appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, {\cf list->vector} takes a list and returns a vector whose
elements are the same as those of the list.

\section{Syntax violations}

Scheme implementations conformant with this report must detect
violations of the syntax.  A \defining{syntax violation} is an error
with respect to the syntax of library bodies, script bodies,
or the ``\exprtype'' entries in the
specification of the base library or the standard libraries.
Moreover, attempting to assign to an immutable variable (i.e., the
variables exported by a library; see
section~\ref{importsareimmutablesection}) is also
considered a syntax violation.

If a script or library form is not syntactically correct, then the
execution of that script or library must not be allowed to begin.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
