\chapter{Standard types}
\label{standardtypes}

This chapter describes Scheme's built-in types and operations on them,
as well as Scheme's record mechanism for defining new types.

\section{Numbers}
\label{numbersection}
\index{number}

%%R4%% The excessive use of the code font in this section was
% confusing, somewhat obnoxious, and inconsistent with the rest
% of the report and with parts of the section itself.  I added
% a \tupe no-op, and changed most old uses of \type to \tupe,
% to make it easier to change the fonts back if people object
% to the change.

\newcommand{\type}[1]{{\it#1}}
\newcommand{\tupe}[1]{{#1}}

Numerical computation has traditionally been neglected by the Lisp
community.  Until Common Lisp there was no carefully thought out
strategy for organizing numerical computation, and with the exception of
the MacLisp system \cite{Pitman83} little effort was made to
execute numerical code efficiently.  This report recognizes the excellent work
of the Common Lisp committee and accepts many of their recommendations.
In some ways this report simplifies and generalizes their proposals in a manner
consistent with the purposes of Scheme.

It is important to distinguish between the mathematical numbers, the
Scheme numbers that attempt to model them, the machine representations
used to implement the Scheme numbers, and notations used to write numbers.
This report uses the types \type{number}, \type{complex}, \type{real},
\type{rational}, and \type{integer} to refer to both mathematical numbers
and Scheme numbers.  Machine representations such as fixed point and
floating point are referred to by names such as \type{fixnum} and
\type{flonum}.

%%R4%% I did some reorganizing here to move the discussion of mathematical
% numbers before the discussion of the Scheme numbers, hoping that this
% would help to motivate the discussion of representation independence.

\subsection{Numerical types}
\label{numericaltypes}
\index{numerical types}

%%R4%% A Scheme system provides data of type \type{number}, which is the most
%general numerical type supported by that system.
%\type{Number} is
%likely to be a complicated union type implemented in terms of
%\type{fixnum}s, \type{bignum}s, \type{flonum}s, and so forth, but this
%should not be apparent to a naive user.  What the user should see is
%that the usual operations on numbers produce the mathematically
%expected results, within the limits of the implementation.

%%R4%%  I rewrote the following paragraph to make the various levels of
% the tower into subsets of each other, instead of relating them by
% injections.  I think the injections tended to put people in the frame
% of mind of thinking about coercions between non-overlapping numeric
% types in mainstream programming languages.

\vest Mathematically, numbers may be arranged into a tower of subtypes
%%R4%% with injections relating adjacent levels of the tower:
in which each level is a subset of the level above it:
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{number} \\
\> \tupe{complex} \\
\> \tupe{real} \\
\> \tupe{rational} \\
\> \tupe{integer} 
\end{tabbing}

For example, 3 is an integer.  Therefore 3 is also a rational,
a real, and a complex.  The same is true of the Scheme numbers
that model 3.  For Scheme numbers, these types are defined by the
predicates \ide{number?}, \ide{complex?}, \ide{real?}, \ide{rational?},
and \ide{integer?}.

There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

%%R4%% I moved "Implementations of Scheme are not required to implement
% the whole tower..." to the subsection on implementation restrictions.

Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an implementation
of Scheme may use fixnum, flonum, and perhaps other representations for
numbers, this should not be apparent to a casual programmer writing
simple programs.

It is necessary, however, to distinguish between numbers that are
represented exactly and those that may not be.  For example, indexes
into data structures must be known exactly, as must some polynomial
coefficients in a symbolic algebra system.  On the other hand, the
results of measurements are inherently inexact, and irrational numbers
may be approximated by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers are
required, Scheme explicitly distinguishes exact from inexact numbers.
This distinction is orthogonal to the dimension of type.

\subsection{Exactness}

%%R4%% I tried to direct the following paragraph away from philosophizing
% about the exactness of mathematical numbers, and toward philosophizing
% about the exactness of Scheme numbers.

\mainindex{exactness} \label{exactly}
Scheme numbers are either \type{exact} or \type{inexact}.  A number is
\tupe{exact} if it was written as an exact constant or was derived from
\tupe{exact} numbers using only \tupe{exact} operations.  A number is
\tupe{inexact} if it was written as an inexact constant,
%%R4%% models a quantity (e.g., a measurement) known only approximately,
if it was
derived using \tupe{inexact} ingredients, or if it was derived using
\tupe{inexact} operations. Thus \tupe{inexact}ness is a contagious
property of a number.
%%R4%% The rest of this paragraph (from R3RS) has been dropped.

\vest If two implementations produce \tupe{exact} results for a
computation that did not involve \tupe{inexact} intermediate results,
the two ultimate results will be mathematically equivalent.  This is
generally not true of computations involving \tupe{inexact} numbers
since approximate methods such as floating point arithmetic may be used,
but it is the duty of each implementation to make the result as close as
practical to the mathematically ideal result.

\vest Rational operations such as {\cf +} should always produce
\tupe{exact} results when given \tupe{exact} arguments.
%%R4%%If an implementation is
%unable to represent an \tupe{exact} result (for example, if it does not
%support infinite precision integers and rationals)
If the operation is unable to produce an \tupe{exact} result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an \tupe{inexact} value.
%%R4%%Such a coercion may cause an error later.
See section~\ref{restrictions}.

\vest With the exception of \ide{inexact->exact}, the operations described in
this section must generally return inexact results when given any inexact
arguments.  An operation may, however, return an \tupe{exact} result if it can
prove that the value of the result is unaffected by the inexactness of its
arguments.  For example, multiplication of any number by an \tupe{exact} zero
may produce an \tupe{exact} zero result, even if the other argument is
\tupe{inexact}.

\subsection{Implementation restrictions}

\index{implementation restriction}\label{restrictions}

\vest Implementations of Scheme are not required to implement the whole
tower of subtypes given in section~\ref{numericaltypes},
but they must implement a coherent subset consistent with both the
purposes of the implementation and the spirit of the Scheme language.
For example, an implementation in which all numbers are \tupe{real}
may still be quite useful.

\vest Implementations may also support only a limited range of numbers of
any type, subject to the requirements of this section.  The supported
range for \tupe{exact} numbers of any type may be different from the
supported range for \tupe{inexact} numbers of that type.  For example,
an implementation that uses flonums to represent all its
\tupe{inexact} \tupe{real} numbers may
support a practically unbounded range of \tupe{exact} \tupe{integer}s
and \tupe{rational}s
while limiting the range of \tupe{inexact} \tupe{real}s (and therefore
the range of \tupe{inexact} \tupe{integer}s and \tupe{rational}s)
to the dynamic range of the flonum format.
Furthermore
the gaps between the representable \tupe{inexact} \tupe{integer}s and
\tupe{rational}s are
likely to be very large in such an implementation as the limits of this
range are approached.

\vest An implementation of Scheme must support exact integers
throughout the range of numbers that may be used for indexes of
lists, vectors, and strings or that may result from computing the length of a
list, vector, or string.  The \ide{length}, \ide{vector-length},
and \ide{string-length} procedures must return an exact
integer, and it is an error to use anything but an exact integer as an
index.  Furthermore any integer constant within the index range, if
expressed by an exact integer syntax, will indeed be read as an exact
integer, regardless of any implementation restrictions that may apply
outside this range.  Finally, the procedures listed below will always
return an exact integer result provided all their arguments are exact integers
and the mathematically expected result is representable as an exact integer
within the implementation:

\begin{scheme}
+            -             *
quotient     remainder     modulo
max          min           abs
numerator    denominator   gcd
lcm          floor         ceiling
truncate     round         rationalize
expt%
\end{scheme}

\vest Implementations are encouraged, but not required, to support
\tupe{exact} \tupe{integer}s and \tupe{exact} \tupe{rational}s of
practically unlimited size and precision, and to implement the
above procedures and the {\cf /} procedure in
such a way that they always return \tupe{exact} results when given \tupe{exact}
arguments.  If one of these procedures is unable to deliver an \tupe{exact}
result when given \tupe{exact} arguments, then it may either report a
violation of an
implementation restriction or it may silently coerce its result to an
\tupe{inexact} number.  Such a coercion may cause an error later.

%%R4%% I moved this stuff here.
% It seems to me that the only thing that this requires is that
% implementations that support inexact numbers have to have both
% exact and inexact representations for the integers 0 through 15.
% If that's what it's saying, I'd rather say it that way.
% On the other hand, letting the limit be as small as 15 sounds a
% tad silly, though I think I understand how that number was arrived at.
% (Or is 35 the number?)
%
%Implementations are encouraged, but not required, to support \tupe{inexact}
%numbers.  For any implementation that supports \tupe{inexact} numbers,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include all non-negative
%integers up to some limit specified by the implementation.  This limit
%must be 16 or greater.  The
%\ide{exact\coerce{}inexact} and \ide{inexact\coerce{}exact}
%procedures implement the natural one-to-one correspondence between
%the \tupe{inexact} and \tupe{exact} integers within this range.

\vest An implementation may use floating point and other approximate 
representation strategies for \tupe{inexact} numbers.
%%R4%% The following sentence seemed a bit condescending as well as
% awkward.  It didn't seem to be very enforceable, so I flushed it.
%
%This is not to
%say that implementors need not use the best known algorithms for
%\tupe{inexact} computations---only that approximate methods of high
%quality are allowed.
%
This report recommends, but does not require, that the IEEE 32-bit
and 64-bit floating point standards be followed by implementations that use
flonum representations, and that implementations using
other representations should match or exceed the precision achievable
using these floating point standards~\cite{IEEE}.

\vest In particular, implementations that use flonum representations
must follow these rules: A \tupe{flonum} result
must be represented with at least as much precision as is used to express any of
the inexact arguments to that operation.  It is desirable (but not required) for
potentially inexact operations such as {\cf sqrt}, when applied to \tupe{exact}
arguments, to produce \tupe{exact} answers whenever possible (for example the
square root of an \tupe{exact} 4 ought to be an \tupe{exact} 2).
If, however, an
\tupe{exact} number is operated upon so as to produce an \tupe{inexact} result
(as by {\cf sqrt}), and if the result is represented as a \tupe{flonum}, then
the most precise \tupe{flonum} format available must be used; but if the result
is represented in some other way then the representation must have at least as
much precision as the most precise \tupe{flonum} format available.

Although Scheme allows a variety of written
%%R4%% representations of 
notations for
numbers, any particular implementation may support only some of them.
%%R4%%
For example, an implementation in which all numbers are \tupe{real}
need not support the rectangular and polar notations for complex
numbers.  If an implementation encounters an \tupe{exact} numerical constant that
it cannot represent as an \tupe{exact} number, then it may either report a
violation of an implementation restriction or it may silently represent the
constant by an \tupe{inexact} number.


\subsection{Syntax of numerical constants}
\label{numbernotations}

%@@@@LOSE@@@@

%%R4%%  I removed the following paragraph in an attempt to tighten up
% this subsection.  Except for its first sentence, which I moved to
% the subsection on implementation restrictions, I think its content
% is implied by the rest of the section.
%
%Although Scheme allows a variety of written representations of numbers,
%any particular implementation may support only some of them.
%These syntaxes are intended to be purely notational; any kind of number
%may be written in any form that the user deems convenient.  Of course,
%writing 1/7 as a limited-precision decimal fraction will not express the
%number exactly, but this approximate form of expression may be just what
%the user wants to see.

The syntax of the written representations for numbers is described formally in
section~\ref{numbersyntax}.  Note that case is not significant in numerical
constants.

%%R4%%  See section~\ref{numberformats} for many examples.

A number may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
no radix prefix, a number is assumed to be expressed in decimal.

A
%%R4%%
% simple
numerical constant may be specified to be either \tupe{exact} or
\tupe{inexact} by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
for \tupe{exact}, and {\cf \#i}\sharpindex{i} for \tupe{inexact}.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the written representation of a number has no exactness prefix, the
constant may be either \tupe{inexact} or \tupe{exact}.  It is
\tupe{inexact} if it contains a decimal point, an
exponent, or a ``\sharpsign'' character in the place of a digit,
otherwise it is \tupe{exact}.
%%R4%%  With our new syntax, the following sentence is redundant:
%
%The written representation of a
%compound number, such as a ratio or a complex, is exact if and only if
%all of its constituents are exact.

In systems with \tupe{inexact} numbers
of varying precisions it may be useful to specify
the precision of a constant.  For this purpose, numerical constants
may be written with an exponent marker that indicates the
desired precision of the \tupe{inexact}
representation.  The letters {\cf s}, {\cf f},
{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
\var{double}, and \var{long} precision, respectively.  (When fewer
than four internal
%%R4%%\tupe{flonum}
\tupe{inexact}
representations exist, the four size
specifications are mapped onto those available.  For example, an
implementation with two internal representations may map short and
single together and long and double together.)  In addition, the
exponent marker {\cf e} specifies the default precision for the
implementation.  The default precision has at least as much precision
as \var{double}, but
implementations may wish to allow this default to be set by the user.

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}


\subsection{Numerical operations}

The reader is referred to section~\ref{typeconventions} for a summary
of the naming conventions used to specify restrictions on the types of
arguments to numerical routines.
%%R4%% The following sentence has already been said twice, and the
% term "exactness-preserving" is no longer defined by the Report.
%
%  Remember that
%an exactness-preserving operation may coerce its result to inexact if the
%implementation is unable to represent it exactly.
The examples used in this section assume that any numerical constant written
using an \tupe{exact} notation is indeed represented as an \tupe{exact}
number.  Some examples also assume that certain numerical constants written
using an \tupe{inexact} notation can be represented without loss of
accuracy; the \tupe{inexact} constants were chosen so that this is
likely to be true in implementations that use flonums to represent
inexact numbers.

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object is
of the named type, and otherwise they return \schfalse{}.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
%%R4%% The new section on implementation restrictions subsumes: 
% Not every system
%supports all of these types; for example, it is entirely possible to have a
%Scheme system that has only \tupe{integer}s.  Nonetheless every implementation
%of Scheme must have all of these predicates.

If \vr{z} is an inexact complex number, then {\cf (real? \vr{z})} is true if
and only if {\cf (zero? (imag-part \vr{z}))} is true.  If \vr{x} is an inexact
real number, then {\cf (integer? \vr{x})} is true if and only if
{\cf (= \vr{x} (round \vr{x}))}.

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schtrue
(real? \#e1e10)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
The behavior of these type predicates on \tupe{inexact} numbers
is unreliable, since any inaccuracy may affect the result.
\end{note}

\begin{note}
In many implementations the \ide{rational?} procedure will be the same
as \ide{real?}, and the \ide{complex?} procedure will be the same as
\ide{number?}, but unusual implementations may be able to represent
some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{procedure}
\proto{inexact?}{ \vr{z}}{procedure}}

These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates
is true.

\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{procedure}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}}

%- Some implementations allow these procedures to take many arguments, to 
%- facilitate range checks.  
These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

These predicates are required to be transitive.

\begin{note}
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
\end{note}

\begin{note}
While it is not an error to compare \tupe{inexact} numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of \ide{=} and \ide{zero?}.
When in doubt, consult a numerical analyst.
\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{library procedure}
\proto{positive?}{ \vr{x}}{library procedure}
\proto{negative?}{ \vr{x}}{library procedure}
\proto{odd?}{ \vr{n}}{library procedure}
\proto{even?}{ \vr{n}}{library procedure}}

These numerical predicates test a number for a particular property,
returning \schtrue{} or \schfalse.  See note above.

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{library procedure}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{library procedure}}

These procedures return the maximum or minimum of their arguments.

\begin{scheme}
(max 3 4)              \ev  4    ; exact
(max 3.9 4)            \ev  4.0  ; inexact%
\end{scheme}

\begin{note}
If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If {\cf min} or
{\cf max} is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{procedure}
\proto{*}{ \vri{z} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.
%- These procedures are exactness preserving.

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vri{z} \vrii{z}}{procedure}
\rproto{-}{ \vr{z}}{procedure}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{optional procedure}
\proto{/}{ \vri{z} \vrii{z}}{procedure}
\rproto{/}{ \vr{z}}{procedure}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{optional procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.
%- These procedures are exactness preserving, except that division may
%- coerce its result to inexact in implementations that do not support
%- \tupe{ratnum}s. 

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{library procedure}}

{\cf Abs} returns the absolute value of its argument.  
%- {\cf Abs} is exactness preserving when its argument is real.
\begin{scheme}
(abs -7)                \ev  7
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{modulo}{ \vri{n} \vrii{n}}{procedure}}

These procedures implement number-theoretic (integer)
division.  \vrii{n} should be non-zero.  All three procedures
return integers.  If \vri{n}/\vrii{n} is an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vri{n}/\vrii{n}
    (remainder \vri{n} \vrii{n})  \ev 0
    (modulo \vri{n} \vrii{n})     \ev 0
\end{scheme}
If \vri{n}/\vrii{n} is not an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vr{n_q}
    (remainder \vri{n} \vrii{n})  \ev \vr{n_r}
    (modulo \vri{n} \vrii{n})     \ev \vr{n_m}
\end{scheme}
where \vr{n_q} is $\vri{n}/\vrii{n}$ rounded towards zero,
$0 < |\vr{n_r}| < |\vrii{n}|$, $0 < |\vr{n_m}| < |\vrii{n}|$,
\vr{n_r} and \vr{n_m} differ from \vri{n} by a multiple of \vrii{n},
\vr{n_r} has the same sign as \vri{n}, and
\vr{n_m} has the same sign as \vrii{n}.

From this we can conclude that for integers \vri{n} and \vrii{n} with
\vrii{n} not equal to 0,
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (quotient \vri{n} \vrii{n}))
           (remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
provided all numbers involved in that computation are exact.

\begin{scheme}
(modulo 13 4)           \ev  1
(remainder 13 4)        \ev  1

(modulo -13 4)          \ev  3
(remainder -13 4)       \ev  -1

(modulo 13 -4)          \ev  -3
(remainder 13 -4)       \ev  1

(modulo -13 -4)         \ev  -1
(remainder -13 -4)      \ev  -1

(remainder -13 -4.0)    \ev  -1.0  ; inexact%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{library procedure}
\proto{lcm}{ \vri{n} \dotsfoo}{library procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.
%- These procedures are exactness preserving.

%%R4%% I added the inexact example.
\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; inexact
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{procedure}
\proto{denominator}{ \vr{q}}{procedure}}

These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
%- The remarks about denominators are new.
%- Clearly, they are exactness-preserving procedures.
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (exact->inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}
}

These procedures return integers.
\vest {\cf Floor} returns the largest integer not larger than \vr{x}.
{\cf Ceiling} returns the smallest integer not smaller than~\vr{x}.
{\cf Truncate} returns the integer closest to \vr{x} whose absolute
value is not larger than the absolute value of \vr{x}.  {\cf Round} returns the
closest integer to \vr{x}, rounding to even when \vr{x} is halfway between two
integers.

\begin{rationale}
{\cf Round} rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

\begin{note}
If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the {\cf inexact->exact} procedure.
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; inexact

(round 7/2)           \ev  4    ; exact
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{library procedure}
%- \proto{rationalize}{ x}{procedure}
}

{\cf Rationalize} returns the {\em simplest} rational number
differing from \vr{x} by no more than \vr{y}.  A rational number $r_1$ is
{\em simpler} \mainindex{simplest rational} than another rational number
$r_2$ if $r_1 = p_1/q_1$ and $r_2 = p_2/q_2$ (in lowest terms) and $|p_1|
\leq |p_2|$ and $|q_1| \leq |q_2|$.  Thus $3/5$ is simpler than $4/7$.
Although not all rationals are comparable in this ordering (consider $2/7$
and $3/5$) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler $2/5$ lies
between $2/7$ and $3/5$).  Note that $0 = 0/1$ is the simplest rational of
all.

\begin{scheme}
(rationalize
  (inexact->exact .3) 1/10)  \ev 1/3    ; exact
(rationalize .3 1/10)        \ev \#i1/3  ; inexact%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{procedure}
\proto{log}{ \vr{z}}{procedure}
\proto{sin}{ \vr{z}}{procedure}
\proto{cos}{ \vr{z}}{procedure}
\proto{tan}{ \vr{z}}{procedure}
\proto{asin}{ \vr{z}}{procedure}
\proto{acos}{ \vr{z}}{procedure}
\proto{atan}{ \vr{z}}{procedure}
\rproto{atan}{ \vr{y} \vr{x}}{procedure}}

These procedures are part of every implementation that supports
%%R4%%
general
real numbers; they compute the usual transcendental functions.  {\cf Log}
computes the natural logarithm of \vr{z} (not the base ten logarithm).
{\cf Asin}, {\cf acos}, and {\cf atan} compute arcsine ($\sin^{-1}$),t
arccosine ($\cos^{-1}$), and arctangent ($\tan^{-1}$), respectively.
The two-argument variant of {\cf atan} computes {\tt (angle
(make-rectangular \vr{x} \vr{y}))} (see below), even in implementations
that don't support general complex numbers.

In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of $\log z$ is defined to be the one whose imaginary
part lies in the range from $-\pi$ (exclusive) to $\pi$ (inclusive).
$\log 0$ is undefined.
With $\log$ defined this way, the values of $\sin^{-1} z$, $\cos^{-1} z$,
and $\tan^{-1} z$ are according to the following formul\ae:
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

The above specification follows~\cite{CLtL}, which in turn
cites~\cite{Penfield81}; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.

%%R4%%
\todo{The cited references are likely to change their branch cuts
soon to allow for the possibility of distinct positive and negative
zeroes, as in IEEE floating point.  We may not want to follow those
changes, since we may want a complex number with zero imaginary part
(whether positive or negative zero) to be treated as a real.  I don't
think there are any better standards for complex arithmetic than the
ones cited, so we're really on our own here.}

\end{entry}


\begin{entry}{%
\proto{sqrt}{ \vr{z}}{procedure}}

Returns the principal square root of \vr{z}.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{procedure}}

Returns \vri{z} raised to the power \vrii{z}.  For $z_1 \neq 0$
$${z_1}^{z_2} = e^{z_2 \log {z_1}}$$
$0^z$ is 1 if $z = 0$ and 0 otherwise.
\end{entry}

%- \begin{entry}{%- 
%- \proto{approximate}{ z x}{procedure}}
%- 
%- Returns an approximation to \vr{z} in a representation whose precision is
%- the same as that 
%- of the representation of \vr{x}, which must be an inexact number.  The
%- result is always inexact.
%- 
%- \begin{scheme}
%- (approximate 3.1415926535 1F10)
%-         \ev  3.14159F0
%- (approximate 3.1415926535 \#I65535)
%-         \ev \#I3
%- (approximate 3.14F0 1L8)
%-         \ev  3.14L0
%- (approximate 3.1415926535F0 1L8)
%-         \ev  3.14159L0
%- \end{scheme}
%- \end{entry}



\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{procedure}
\proto{make-polar}{ \vriii{x} \vriv{x}}{procedure}
\proto{real-part}{ \vr{z}}{procedure}
\proto{imag-part}{ \vr{z}}{procedure}
\proto{magnitude}{ \vr{z}}{procedure}
\proto{angle}{ \vr{z}}{procedure}}

These procedures are part of every implementation that supports
%%R4%%
general
complex numbers.  Suppose \vri{x}, \vrii{x}, \vriii{x}, and \vriv{x} are
real numbers and \vr{z} is a complex number such that
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{{\displaystyle{\hbox{$i$}} \vriv{x}}}$$
Then
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$
\end{scheme}
where $-\pi < x_{angle} \le \pi$ with $x_{angle} = \vriv{x} + 2\pi n$
for some integer $n$.

\begin{rationale}
{\cf Magnitude} is the same as \ide{abs} for a real argument,
but {\cf abs} must be present in all implementations, whereas
{\cf magnitude} need only be present in implementations that support
general complex numbers.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{exact->inexact}{ \vr{z}}{procedure}
\proto{inexact->exact}{ \vr{z}}{procedure}}

{\cf Exact\coerce{}inexact} returns an \tupe{inexact} representation of \vr{z}.
The value returned is the
\tupe{inexact} number that is numerically closest to the argument.  
%%R4%%For
%\tupe{exact} arguments which have no reasonably close \tupe{inexact} equivalent,
%it is permissible to signal an error.
If an \tupe{exact} argument has no reasonably close \tupe{inexact} equivalent,
then a violation of an implementation restriction may be reported.

{\cf Inexact\coerce{}exact} returns an \tupe{exact} representation of
\vr{z}.  The value returned is the \tupe{exact} number that is numerically
closest to the argument.
%%R4%%  For \tupe{inexact} arguments which have no
%reasonably close \tupe{exact} equivalent, it is permissible to signal
%an error.
If an \tupe{inexact} argument has no reasonably close \tupe{exact} equivalent,
then a violation of an implementation restriction may be reported.

%%R%% I moved this to the section on implementation restrictions.
%For any implementation that supports \tupe{inexact} quantities,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include the non-negative
%integers up to a limit specified by the implementation.  The limit
%must be big enough to represent all digits in reasonable radices, and
%may correspond to some natural word size for the implementation.  For
%such integers, these procedures implement the natural one-to-one
%correspondence between the representations.

These procedures implement the natural one-to-one correspondence between
\tupe{exact} and \tupe{inexact} integers throughout an
implementation-dependent range.  See section~\ref{restrictions}.

\end{entry}

\medskip

\subsection{Numerical input and output}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}}

\vr{Radix} must be an exact integer, either 2, 8, 10, or 16.  If omitted,
\vr{radix} defaults to 10.
The procedure {\cf number\coerce{}string} takes a
number and a radix and returns as a string an external representation of
the given number in the given radix such that
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))
\end{scheme}
is true.  It is an error if no possible result makes this expression true.

If \vr{z} is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent and trailing
zeroes) needed to make the above expression
true~\cite{howtoprint,howtoread};
otherwise the format of the result is unspecified.

The result returned by {\cf number\coerce{}string}
never contains an explicit radix prefix.

\begin{note}
The error case can occur only when \vr{z} is not a complex number
or is a complex number with a non-rational real or imaginary part.
\end{note}

\begin{rationale}
If \vr{z} is an inexact number represented using flonums, and
the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}

%%R4%% I didn't include the (string->number string radix exactness)
% case, since I haven't heard any resolution of the coding to be used
% for the third argument.

Returns a number of the maximally precise representation expressed by the
given \vr{string}.  \vr{Radix} must be an exact integer, either 2, 8, 10,
or 16.  If supplied, \vr{radix} is a default radix that may be overridden
by an explicit radix prefix in \vr{string} (e.g. {\tt "\#o177"}).  If \vr{radix}
is not supplied, then the default radix is 10.  If \vr{string} is not
a syntactically valid notation for a number, then {\cf string->number}
returns \schfalse{}.

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0
(string->number "15\#\#")       \ev  1500.0%
\end{scheme}

\begin{note}
The domain of {\cf string->number} may be restricted by implementations
in the following ways.  {\cf String->number} is permitted to return
\schfalse{} whenever \vr{string} contains an explicit radix prefix.
If all numbers supported by an implementation are real, then
{\cf string->number} is permitted to return \schfalse{} whenever
\vr{string} uses the polar or rectangular notations for complex
numbers.  If all numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
the fractional notation is used.  If all numbers are exact, then
{\cf string->number} may return \schfalse{} whenever
an exponent marker or explicit exactness prefix is used, or if
a {\tt \#} appears in place of a digit.  If all inexact
numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
a decimal point is used.
\end{note}

\end{entry}

\section{Other data types}

This section describes operations on some of Scheme's non-numeric data types:
booleans, pairs, lists, symbols, characters, strings and vectors.

\subsection{Booleans}
\label{booleansection}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}  What really
matters, though, are the objects that the Scheme conditional expressions
({\cf if}, {\cf cond}, {\cf and}, {\cf or}, {\cf do}) treat as
true\index{true} or false\index{false}.  The phrase ``a true value''\index{true}
(or sometimes just ``true'') means any object treated as true by the
conditional expressions, and the phrase ``a false value''\index{false} (or
``false'') means any object treated as false by the conditional expressions.

\vest Of all the standard Scheme values, only \schfalse{}
% is guaranteed to count
counts as false in conditional expressions.
%  It is not
% specified whether the empty list\index{empty list} counts as false
% or as true in conditional expressions.
Except for \schfalse{},
% and possibly the empty list,
all standard Scheme values, including \schtrue,
pairs, the empty list, symbols, numbers, strings, vectors, and procedures,
count as true.

%\begin{note}
%In some implementations the empty list counts as false, contrary
%to the above.
%Nonetheless a few examples in this report assume that the
%empty list counts as true, as in \cite{IEEEScheme}.
%\end{note}

% \begin{rationale}
% For historical reasons some implementations regard \schfalse{} and the
% empty list as the same object.  These implementations therefore cannot
% make the empty list count as true in conditional expressions.
% \end{rationale}

\begin{note}
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both \schfalse{} and the empty list \index{empty list}
from the symbol \ide{nil}.
\end{note}

\vest Boolean constants evaluate to themselves, so they do not need to be quoted
in programs.

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{library procedure}}

{\cf Not} returns \schtrue{} if \var{obj} is false, and returns
\schfalse{} otherwise.

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{library procedure}}

{\cf Boolean?} returns \schtrue{} if \var{obj} is either \schtrue{} or
\schfalse{} and returns \schfalse{} otherwise.

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

 
\subsection{Pairs and lists}
\label{listsection}

A \defining{pair} (sometimes called a \defining{dotted pair}) is a
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure {\cf cons}.
The car and cdr fields are accessed by the procedures {\cf car} and
{\cf cdr}.  The car and cdr fields are assigned by the procedures
{\cf set-car!}\ and {\cf set-cdr!}.

Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list\index{empty list} or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set \var{X} such that

\begin{itemize}
\item The empty list is in \var{X}.
\item If \var{list} is in \var{X}, then any pair whose cdr field contains
      \var{list} is also in \var{X}.
\end{itemize}

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

The empty list\mainindex{empty list} is a special object of its own type
(it is not a pair); it has no elements and its length is zero.

\begin{note}
The above definitions imply that all lists have finite length and are
terminated by the empty list.
\end{note}

The most general notation (external representation) for Scheme pairs is
the ``dotted'' notation \hbox{\cf (\vari{c} .\ \varii{c})} where
\vari{c} is the value of the car field and \varii{c} is the value of the
cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
cdr is 5.  Note that {\cf (4 .\ 5)} is the external representation of a
pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list\index{empty list} is written {\tt()} .  For example,

\begin{scheme}
(a b c d e)%
\end{scheme}

and

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

are equivalent notations for a list of symbols.

A chain of pairs not ending in the empty list is called an
\defining{improper list}.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

\begin{scheme}
(a b c . d)%
\end{scheme}

is equivalent to

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

Whether a given pair is a list depends upon what is stored in the cdr
field.  When the \ide{set-cdr!} procedure is used, an object can be a
list one moment and not the next:

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

%It is often convenient to speak of a homogeneous list of objects
%of some particular data type, as for example \hbox{\cf (1 2 3)} is a list of
%integers.  To be more precise, suppose \var{D} is some data type.  (Any
%predicate defines a data type consisting of those objects of which the
%predicate is true.)  Then
%
%\begin{itemize}
%\item The empty list is a list of \var{D}.
%\item If \var{list} is a list of \var{D}, then any pair whose cdr is
%      \var{list} and whose car is an element of the data type \var{D} is also a
%      list of \var{D}.
%\item There are no other lists of \var{D}.
%\end{itemize}

Within literal expressions and representations of objects read by the
\ide{read} procedure, the forms \singlequote\hyper{datum}\schindex{'},
\backquote\hyper{datum}, {\tt,}\hyper{datum}\schindex{,}, and
{\tt,@}\hyper{datum} denote two-ele\-ment lists whose first elements are
the symbols \ide{quote}, \ide{quasiquote}, \hbox{\ide{unquote}}, and
\ide{unquote-splicing}, respectively.  The second element in each case
is \hyper{datum}.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  \todo{Can or need this be stated
more carefully?} That is, according to Scheme's grammar, every
\meta{expression} is also a \meta{datum} (see section~\ref{datum}).
Among other things, this permits the use of the {\cf read} procedure to
parse Scheme programs.  See section~\ref{externalreps}. 
 

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

{\cf Pair?} returns \schtrue{} if \var{obj} is a pair, and otherwise
returns \schfalse.

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

Returns a newly allocated pair whose car is \vari{obj} and whose cdr is
\varii{obj}.  The pair is guaranteed to be different (in the sense of
{\cf eqv?}) from every existing object.

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the car field of \var{pair}.  Note that it is an
error to take the car of the empty list\index{empty list}.

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the cdr field of \var{pair}.
Note that it is an error to take the cdr of the empty list.

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}  
Stores \var{obj} in the car field of \var{pair}.
The value returned by {\cf set-car!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Stores \var{obj} in the cdr field of \var{pair}.
The value returned by {\cf set-cdr!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{library procedure}


\begin{entry}{%
\proto{caar}{ pair}{library procedure}
\proto{cadr}{ pair}{library procedure}
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}
\proto{cdddar}{ pair}{library procedure}
\proto{cddddr}{ pair}{library procedure}}

These procedures are compositions of {\cf car} and {\cf cdr}, where
for example {\cf caddr} could be defined by

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{library procedure}}

Returns \schtrue{} if \var{obj} is the empty list\index{empty list},
otherwise returns \schfalse.

% \begin{note}
% In implementations in which the empty
% list is the same as \schfalse{}, {\cf null?} will return \schtrue{}
% if \var{obj} is \schfalse{}.
% \end{note}
 
\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{library procedure}}

Returns \schtrue{} if \var{obj} is a list, otherwise returns \schfalse{}.
By definition, all lists have finite length and are terminated by
the empty list.

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{library procedure}}

Returns a newly allocated list of its arguments.

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{library procedure}}

\nodomain{\var{List} must be a list.}
Returns the length of \var{list}.

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{library procedure}}

\nodomain{All \var{list}s should be lists.}
Returns a list consisting of the elements of the first \var{list}
followed by the elements of the other \var{list}s.

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}

The resulting list is always newly allocated, except that it shares
structure with the last \var{list} argument.  The last argument may
actually be any object; an improper list results if the last argument is not a
proper list.  \todo{This is pretty awkward.  I should get Bartley to fix this.}

\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{library procedure}}

\nodomain{\var{List} must be a list.}
Returns a newly allocated list consisting of the elements of \var{list}
in reverse order.

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{library procedure}}

Returns the sublist of \var{list} obtained by omitting the first \vr{k}
elements.  It is an error if \var{list} has fewer than \vr{k} elements.
{\cf List-tail} could be defined by

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{library procedure}}

Returns the \vr{k}th element of \var{list}.  (This is the same
as the car of {\tt(list-tail \var{list} \vr{k})}.)
It is an error if \var{list} has fewer than \vr{k} elements.

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (inexact->exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}


%\begin{entry}{%
%\proto{last-pair}{ list}{library procedure}}
%
%Returns the last pair in the nonempty, possibly improper, list \var{list}.
%{\cf Last-pair} could be defined by
%
%\begin{scheme}
%(define last-pair
%  (lambda (x)
%    (if (pair? (cdr x))
%        (last-pair (cdr x))
%        x)))%
%\end{scheme} 
% 
%\end{entry}


\begin{entry}{%
\proto{memq}{ obj list}{library procedure}
\proto{memv}{ obj list}{library procedure}
\proto{member}{ obj list}{library procedure}}

These procedures return the first sublist of \var{list} whose car is
\var{obj}, where the sublists of \var{list} are the non-empty lists
returned by {\tt (list-tail \var{list} \var{k})} for \var{k} less
than the length of \var{list}.  If
\var{obj} does not occur in \var{list}, then \schfalse{} (not the empty list) is
returned.  {\cf Memq} uses {\cf eq?}\ to compare \var{obj} with the elements of
\var{list}, while {\cf memv} uses {\cf eqv?}\ and {\cf member} uses {\cf equal?}.

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{library procedure}
\proto{assv}{ obj alist}{library procedure}
\proto{assoc}{ obj alist}{library procedure}}

\domain{\var{Alist} (for ``association list'') must be a list of
pairs.}  These procedures find the first pair in \var{alist} whose car field is \var{obj},
and returns that pair.  If no pair in \var{alist} has \var{obj} as its
car, then \schfalse{} (not the empty list) is returned.  {\cf Assq} uses
{\cf eq?}\ to compare \var{obj} with the car fields of the pairs in \var{alist},
while {\cf assv} uses {\cf eqv?}\ and {\cf assoc} uses {\cf equal?}.

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
Although they are ordinarily used as predicates,
{\cf memq}, {\cf memv}, {\cf member}, {\cf assq}, {\cf assv}, and {\cf assoc} do not
have question marks in their names because they return useful values rather
than just \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}


\subsection{Symbols}
\label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eqv?}) if and only if their
names are spelled the same way.  This is exactly the property needed to
represent identifiers\index{identifier} in programs, and so most
implementations of Scheme use them internally for that purpose.  Symbols
are useful for many other applications; for instance, they may be used
the way enumerated values are used in Pascal.

\vest The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections~\ref{syntaxsection}
and~\ref{identifiersyntax}.

\vest It is guaranteed that any symbol written out using the {\cf
  write} procedure, will read back in as the identical symbol (in the
sense of {\cf eqv?}).

A symbol literal is formed using {\cf quote}.  Any character within a
symbol literal may be specified by its scalar value, using the {\tt
  \sharpsign\backwhack{}x} escape notation.

\begin{scheme}
Hello \ev Hello
'H\backwhack{}x65;llo \ev Hello
'$\lambda$ \ev $\lambda$
'\backwhack{}x3BB; \ev $\lambda$
(string->symbol "a b") \ev a\backwhack{}x20;b
(string->symbol "a\backwhack{}\backwhack{}b") \ev a\backwhack{}x5C;b
'a\backwhack{}x20;b \ev a\backwhack{}x20;b
'|a b| \>\>; \emph{parse error}
\>\>\textrm{; (illegal character}
\>\>\textrm{; vertical bar)}
'a\backwhack{}nb  \>\>; \emph{parse error}
\>\>\textrm{; (illegal use of backslash)}
'a\backwhack{}x20 \>\>; \emph{parse error}
\>\>\textrm{; (missing semi-colon to}
\>\>\textrm{; terminate \backwhack{}x escape)}
\end{scheme}

\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as a string.  It is an error
to apply mutation procedures like \ide{string-set!} to strings returned
by this procedure.

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}. 

\begin{scheme}
(eq? 'mISSISSIppi 'mississippi)  \lev  \schfalse
(string->symbol "mISSISSIppi")  \lev%
  {\rm{}the symbol with name} "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\subsection{Characters}
\label{charactersection}

\mainindex{Unicode}
\mainindex{scalar value}

\defining{Characters} are objects that represent Unicode scalar
values~\cite{Unicode41}.

\begin{note}
  Unicode defines a standard mapping between sequences of {\em code
  points}\mainindex{code point} (integers in the range 0 to \#x10FFFF
  in the latest version of the standard) and human-readable
  ``characters.'' More precisely, Unicode distinguishes between
  glyphs, which are printed for humans to read, and characters, which
  are abstract entities that map to glyphs (sometimes in a way that's
  sensitive to surrounding characters).  Furthermore, different
  sequences of code points sometimes correspond to the same character.
  The relationships among code points, characters, and glyphs are
  subtle and complex.

  Despite this complexity, most things that a literate human would
  call a ``character'' can be represented by a single code point in
  Unicode (though there may exist code-point sequences that represent
  that same character). For example, Roman letters, Cyrillic letters,
  Hebrew consonants, and most Chinese characters fall into this
  category. Thus, the ``code point'' approximation of ``character''
  works well for many purposes. It is thus appropriate to define
  Scheme characters as Unicode {\em scalar values}\mainindex{scalar
    value}, which includes all code points except those designated as
  surrogates. A \defining{surrogate} is a code point in the range
  \#xD800 to \#xDFFF that is used in pairs in the UTF-16 encoding to
  encode a supplementary character (whose code is in the range
  \#x10000 to \#x10FFFF).
\end{note}


%There is no requirement that the data type of
%characters be disjoint from other data types; implementations are
%encouraged to have a separate character data type, but may choose to
%represent characters as integers, strings, or some other type.
Character literals are written using the notation
\sharpsign\backwhack\hyper{character} or
\sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}, where the latter
specifies the scalar value of a character with a hexadecimal number of
no more than eight digits.

For example:

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}a}&; lower case letter\\
{\tt \#\backwhack{}A}&; upper case letter\\
{\tt \#\backwhack{}(}&; left parenthesis\\
{\tt \#\backwhack{} }&; the space character\\
{\tt \#\backwhack{}nul}& ; Unicode 0\\
{\tt \#\backwhack{}alarm}& ; Unicode 7\\
{\tt \#\backwhack{}backspace}& ; Unicode 8\\
{\tt \#\backwhack{}tab}& ; Unicode 9\\
{\tt \#\backwhack{}linefeed}& ; Unicode 10\\
{\tt \#\backwhack{}vtab}& ; Unicode 11\\
{\tt \#\backwhack{}page}& ; Unicode 12\\
{\tt \#\backwhack{}return}& ; Unicode 13\\
{\tt \#\backwhack{}esc}& ; Unicode 27\\
{\tt \#\backwhack{}space}& ; Unicode 32;\\& \quad the preferred way to write a space\\
{\tt \#\backwhack{}delete}& : Unicode 127\\[1ex]

{\tt \#\backwhack{}xFF}& ; Unicode 255\\
{\tt \#\backwhack{}x03BB}& ; Unicode 955\\
{\tt \#\backwhack{}x00006587}& ; Unicode 25991\\
{\tt \#\backwhack{}$\lambda$}& ; Unicode 955\\[1ex]

{\tt \#\backwhack{}x0001z}& ; parse error\\
{\tt \#\backwhack{}$\lambda$x}& ; parse error\\
{\tt \#\backwhack{}alarmx}& ; parse error\\
{\tt \#\backwhack{}alarm x}& ; Unicode 7 followed by {\tt x}\\
{\tt \#\backwhack{}Alarm}& ; parse error\\
{\tt \#\backwhack{}alert}& ; parse error\\
{\tt \#\backwhack{}xA}& ; Unicode 10\\
{\tt \#\backwhack{}xFF}& ; Unicode 255\\
{\tt \#\backwhack{}xff}& ; Unicode 255\\
{\tt \#\backwhack{}x ff}& ; Unicode 120 followed by another datum, \\& \quad {\tt ff}\\
{\tt \#\backwhack{}x(ff)}& ; Unicode 120 followed by another datum, \\& \quad a parenthesized {\tt ff}\\
{\tt \#\backwhack{}(x)}& ; parse error\\
{\tt \#\backwhack{}(x}& ; parse error\\
{\tt \#\backwhack{}((x)}& ; Unicode 40 followed by another datum, \\& \quad parenthesized {\tt x}\\
{\tt \#\backwhack{}x00110000}& ; parse error (out of range)\\
{\tt \#\backwhack{}x000000001}& ; parse error (too many digits)\\
{\tt \#\backwhack{}xD800}& ; parse error (in excluded range)
\end{tabular}
$$

Case is significant in \sharpsign\backwhack\hyper{character}, and in in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
but not in \sharpsign\backwhack{}x\atleastone{\hyper{digit 16}}.  
The character after a character literal
must be a delimiter character such as a
space or parenthesis.  This rule resolves various ambiguous cases, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
could be taken to be either a representation of the space character or a
representation of the character ``{\tt\sharpsign\backwhack s}'' followed
by a representation of the symbol ``{\tt pace}.''

\todo{Fix}
Characters written in the \sharpsign\backwhack{} notation are self-evaluating.
That is, they do not have to be quoted in programs.  
%The \sharpsign\backwhack{}
%notation is not an essential part of Scheme, however.  Even implementations
%that support the \sharpsign\backwhack{} notation for input do not have to
%support it for output.

\vest Some of the procedures that operate on characters ignore the
difference between upper case and lower case.  The procedures that
ignore case have \hbox{``{\tt -ci}''} (for ``case
insensitive'') embedded in their names.


\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}

\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{n}}{procedure}}

Given a character, {\cf char\coerce{}integer} returns its scalar value
as an exact integer.  Given an exact integer that is
s scalar value, i.e.\ a number in $\left[0, \#x\textrm{D7FF}\right] \cup
\left[\#x\textrm{E000}, \#x\textrm{10FFFF}\right]$,
{\cf integer\coerce{}char}
returns its associated character.

\begin{scheme}
(integer->char 32) \ev \sharpsign\backwhack{}space
(char->integer (integer->char 5000))
\ev 5000
(integer->char \sharpsign{}xD800) \ev \textit{error}
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char=?}{ \vari{char} \varii{char}}{procedure}
\proto{char<?}{ \vari{char} \varii{char}}{procedure}
\proto{char>?}{ \vari{char} \varii{char}}{procedure}
\proto{char<=?}{ \vari{char} \varii{char}}{procedure}
\proto{char>=?}{ \vari{char} \varii{char}}{procedure}}

\label{characterequality}
\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures impose a total ordering on the set of characters
according to their scalar values.

Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

\begin{scheme}
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}\ss) \ev \schtrue
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse
\end{scheme}

\begin{note}
These procedures could be defined as follows:
%
\begin{scheme}
; char-comparator is not itself part of the
; specification; it is used only to define 
; other procedures
(define (char-comparator num-comp)
  (lambda (a-char b-char)
    (num-comp (char->integer a-char)
              (char->integer b-char))))

(define char=? (char-comparator =))
(define char<? (char-comparator <))
(define char>? (char-comparator >))
(define char<=? (char-comparator <=))
(define char>=? (char-comparator >=))
\end{scheme}
\end{note}
\end{entry}

\begin{entry}{%
\proto{char-upcase}{ char}{library procedure}
\proto{char-downcase}{ char}{library procedure}
\proto{char-titlecase}{ char}{library procedure}
\proto{char-foldcase}{ char}{library procedure}}

\nodomain{\var{Char} must be a character.}
These procedures take a character argument and return a character
result. If the argument is an upper case or title case character, and if
there is a single character which is its lower case form, then
{\cf char-downcase} returns that character. If the argument is a lower case
or title case character, and if there is a single character which is
its uppercase form, then {\cf char-upcase} returns that character.
If the argument is a lower case
or upper case character, and if there is a single character which is
its titlecase form, then {\cf char-titlecase} returns that character.
Finally, if the character has a case-folded character, {\cf char-foldcase}
returns that character. Otherwise, the character returned is the same
as the argument. For Turkic characters 0 ({\tt \#\backwhack{}x130})
and 1 ({\tt \#\backwhack{}x131}),
{\cf char-foldcase} behaves as the identity function, otherwise it is the
same as {\cf char-downcase} composed with {\cf char-upcase}.
%
Otherwise, the character returned is the same as the argument.

\begin{scheme}
(char-upcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-downcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i
(char-titlecase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-foldcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i

(char-upcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-downcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-titlecase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-foldcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss

(char-upcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$
(char-titlecase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$

(char-upcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\varsigma$
(char-titlecase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\sigma$
\end{scheme}

\begin{note}
  Unicode defines locale-independent mappings from scalar values to
  scalar values for upcase, downcase, titlecase, and case-folding
  operations. (These mappings can be extracted from {\cf
    UnicodeData.txt} and {\cf CaseFolding.txt} from the Unicode
  Consortium, ignoring Turkic mappings in the latter.) These
  procedures map characters consistent with the Unicode specification.

  Note that these character-based procedures are an incomplete
  approximation to case conversion, even ignoring the user's locale;
  in general, case mappings require the context of a string, both in
  arguments and in result. See {\cf string-upcase} and {\cf
    string-downcase} for more general case-conversion procedures.
\end{note}
\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vari{char} \varii{char}}{library procedure}
\proto{char-ci<?}{ \vari{char} \varii{char}}{library procedure}
\proto{char-ci>?}{ \vari{char} \varii{char}}{library procedure}
\proto{char-ci<=?}{ \vari{char} \varii{char}}{library procedure}
\proto{char-ci>=?}{ \vari{char} \varii{char}}{library procedure}}

\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures are similar to {\cf char=?}\ et cetera, but operate
on the fold-cased versions of the characters.

Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

\begin{scheme}
(char-ci<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse
(char-ci=? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schtrue
(char-ci=? \sharpsign\backwhack{}$\varsigma$ \sharpsign\backwhack{}$\sigma$) \ev \schtrue
\end{scheme}

\begin{note}
These procedures could be defined as follows:
%
\begin{scheme}
; char-ci-comparator is not itself part of the
; specification; it is used only to define 
; other procedures
(define (char-ci-comparator cs-comp)
  (lambda (a-char b-char)
    (cs-comp (char-foldcase a-char)
             (char-foldcase b-char))))

(define char-ci=? (char-ci-comparator char=?))
(define char-ci<? (char-ci-comparator char<?))
(define char-ci>? (char-ci-comparator char>?))
(define char-ci<=? (char-ci-comparator char<=?))
(define char-ci>=? (char-ci-comparator char>=?))
\end{scheme}
\end{note}
\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{library procedure}
\proto{char-numeric?}{ char}{library procedure}
\proto{char-whitespace?}{ char}{library procedure}
\proto{char-upper-case?}{ letter}{library procedure}
\proto{char-lower-case?}{ letter}{library procedure}
\proto{char-title-case?}{ letter}{library procedure}}

These procedures return \schtrue{} if their arguments are alphabetic,
numeric, whitespace, upper case, lower case, or title case characters,
respectively, otherwise they return \schfalse.

A character is alphabetic if it is a Unicode letter, i.e.\ if it is in
one of categories Lu, Ll, Lt, Lm, and Lo.  A character is numeric if
it is in categeory Nd.  A characters is whitespace if it is in one of
the space, line, or paragraph separator categories (Zs, Zl or Zp), or
if is Unicode 9 (Horizontal tabulation), Unicode 10 (Line feed),
Unicode 11 (Vertical tabulation), Unicode 12 (Form feed), or Unicode
13 (Carriage return).  A character is upper case if it has the Unicode
``Uppercase'' property, lower case if it has the ``Lowercase''
property, and title case if it is in the Lt general category,
respectively.

\begin{scheme}
(char-alphabetic? \sharpsign\backwhack{}a) \ev \schtrue{}
(char-numeric? \sharpsign\backwhack{}1) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}space) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}x00A0) \ev \schtrue{}
(char-upper-case? \sharpsign\backwhack{}$\Sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}$\sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}x00AA) \ev \schtrue{}
(char-title-case? \sharpsign\backwhack{}I) \ev \schfalse{}
(char-title-case? \sharpsign\backwhack{}x01C5) \ev \schtrue{}
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{char-general-category}{ char}{library procedure}}

This procedure takes a character and returns a symbol representing its
Unicode general category, one of \ide{lu}, \ide{ll}, \ide{lt},
\ide{lm}, \ide{lo}, \ide{mn}, \ide{mc}, \ide{me}, \ide{nd}, \ide{nl},
\ide{no}, \ide{ps}, \ide{pe}, \ide{pi}, \ide{pf}, \ide{pd}, \ide{pc},
\ide{po}, \ide{sc}, \ide{sm}, \ide{sk}, \ide{so}, \ide{zs}, \ide{zp},
\ide{zl}, \ide{cc}, \ide{cf}, \ide{cs}, \ide{co}, or \ide{cn}.

\begin{scheme}
(char-general-category \#\backwhack{}a) \ev ll
(char-general-category \#\backwhack{}space) \lev zs
(char-general-category \#\backwhack{}x10FFFF) \lev cn  
\end{scheme}
\end{entry}


\subsection{Strings}
\label{stringsection}

Strings are sequences of characters.  
\vest String literals are written as sequences of characters enclosed within doublequotes
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} denote characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\tt \backwhack{}a} : alarm, Unicode 7
\item{\tt \backwhack{}b} : backspace, Unicode 8 
\item{\tt \backwhack{}t} : tab, Unicode 9 
\item{\tt \backwhack{}n} : linefeed, Unicode 10 
\item{\tt \backwhack{}v} : vertical tab, Unicode 11 
\item{\tt \backwhack{}f} : formfeed, Unicode 12 
\item{\tt \backwhack{}r} : return, Unicode 13 
\item{\tt \backwhack{}}\verb|"| : doublequote, Unicode 34 
\item{\tt \backwhack{}\backwhack{}} : backslash, Unicode 92 
\item{\tt \backwhack{}\hyper{linefeed}\hyper{intraline whitespace}} : nothing
\item{\tt \backwhack{}\ } : space, Unicode 32(useful for terminating the
  previous escape sequence before continuing with whitespace)
\item{\tt \backwhack{}x\atleastone{\hyper{digit 16}}} : (note the
  terminating semi-colon) where no more than eight \hyper{digit 16}s
  are provided, and the sequence of \hyper{digit 16}s forms a
  hexadecimal number between 0 and \sharpsign{}xFFFF excluding the
  range $\left[\sharpsign{}x\textrm{D800},
    \sharpsign{}x\textrm{DFFF}\right]$.
\end{itemize}

These escape sequences are case-sensitive, except that \hyper{digit
  16} can be an uppercase or lowercase hexadecimal digit.

Any other character in a string after a backslash is an error. Any
character outside of an escape sequence and not a doublequote stands
for itself in the string literal. For example the single-character
string {\tt "$\lambda$"} (double quote, a lower case lambda, double
quote) denotes the same string literal as {\tt "\backwhack{}x03bb;"}.

Examples:

\begin{center}
  \begin{tabular}{ll}
    {\tt "abc"}    & ; Unicode sequence 97, 98, 99\\
    {\tt "\backwhack{}x41;bc"} & ; ``Abc'', Unicode sequence 65, 98, 99\\
    {\tt "\backwhack{}x41; bc"} & ; ``A bc'', Unicode sequence 65, 32, 98, 99\\
    {\tt "\backwhack{}x41bc;"} & ; Unicode sequence 16828\\
    {\tt "\backwhack{}x41"} & ; parse error\\
    {\tt "\backwhack{}x;"} & ; parse error\\
    {\tt "\backwhack{}x41bx;"} & ; parse error\\
    {\tt "\backwhack{}x00000041;"} & ; ``A'', Unicode sequence 65\\
    {\tt "\backwhack{}x0010FFFF;"} &  ; Unicode sequence \#x10FFFF\\
    {\tt "\backwhack{}x00110000;"}&  ; parse error (out of range)\\
    {\tt "\backwhack{}x000000001;"}& ; parse error (too many digits)\\
    {\tt "\backwhack{}xD800;"}&      ; parse error (in excluded range)
  \end{tabular}
\end{center}

\vest The {\em length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed when the
string is created.  The \defining{valid indexes} of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

\vest In phrases such as ``the characters of \var{string} beginning with
index \var{start} and ending with index \var{end},'' it is understood
that the index \var{start} is inclusive and the index \var{end} is
exclusive.  Thus if \var{start} and \var{end} are the same index, a null
substring is referred to, and if \var{start} is zero and \var{end} is
the length of \var{string}, then the entire string is referred to.

\vest Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The versions that ignore case
have \hbox{``{\cf -ci}''} (for ``case insensitive'') embedded in their
names.


\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{procedure}
\rproto{make-string}{ \vr{k} char}{procedure}}

%\domain{\vr{k} must be a non-negative integer, and \var{char} must be
%a character.}  
{\cf Make-string} returns a newly allocated string of
length \vr{k}.  If \var{char} is given, then all elements of the string
are initialized to \var{char}, otherwise the contents of the
\var{string} are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{library procedure}}

Returns a newly allocated string composed of the arguments.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string}.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{procedure}}

\domain{\vr{k} must be a valid index of \var{string}.}
{\cf String-ref} returns character \vr{k} of \var{string} using zero-origin indexing.
\end{entry}


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{%\var{String} must be a string, 
\vr{k} must be a valid index of \var{string}%, and \var{char} must be a character
.}
{\cf String-set!} stores \var{char} in element \vr{k} of \var{string}
and returns an unspecified value.  % <!>

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vari{string} \varii{string}}{library procedure}}

Returns \schtrue{} if the two strings are the same length and contain the same
characters in the same positions, otherwise returns \schfalse.

\begin{scheme}
(string=? "Strae" "Strasse") \ev \schfalse
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string<?}{ \vari{string} \varii{string}}{library procedure}
\proto{string>?}{ \vari{string} \varii{string}}{library procedure}
\proto{string<=?}{ \vari{string} \varii{string}}{library procedure}
\proto{string>=?}{ \vari{string} \varii{string}}{library procedure}}

These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, {\cf string<?}\ is
the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters.  If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.

Implementations may generalize these and the {\cf string=?}\ and
{\cf string-ci=?} procedures to take more than two arguments, as with
the corresponding numerical predicates.

\begin{scheme}
(string<? "z" "\ss") \ev \schtrue
(string<? "z" "zz") \ev \schtrue
(string<? "z" "Z") \ev \schfalse
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{string-upcase}{ \var{string}}{library procedure}
\proto{string-downcase}{ \var{string}}{library procedure}
\proto{string-titlecase}{ \var{string}}{library procedure}
\proto{string-foldcase}{ \var{string}}{library procedure}}

These procedures take a string argument argument and return a string
result.  They are defined as in terms of Unicode's locale-independent
case mappings from scalar-value sequences to scalar-value sequences.
In particular, the length of the result string can be different than
the length of the input string.

The {\cf string-upcase} procedure converts a string to upper case,
{\cf string-downcase} converts a string to lowercase. The {\cf
  string-foldcase} procedure converts the string to its case-folded
counterpart, using the full case-folding mapping, but without the
special mappings for Turkic languages.  The {\cf string-titlecase}
procedure converts the first character to title case in each
contiguous sequence of cased characters within \var{string}, and it
downcases all other cased characters; for the purposes of detecting
cased-character sequences, case-ignorable characters are ignored
(i.e., they do not interrupt the sequence).

\begin{scheme}
(string-upcase "Hi") \ev "HI"
(string-downcase "Hi") \ev "hi"
(string-foldcase "Hi") \ev "hi"

(string-upcase "Stra\ss{}e") \ev "STRASSE"
(string-downcase "Stra\ss{}e") \ev "stra\ss{}e"
(string-foldcase "Stra\ss{}e") \ev "strasse"
(string-downcase "STRASSE")  \ev "strasse"

(string-downcase "$\Sigma$") \ev "$\sigma$"

; \textrm{Chi Alpha Omicron Sigma}:
(string-upcase "$\mathit{XAO}\Sigma$") \ev "$\mathit{XAO}\Sigma$" 
(string-downcase "$\mathit{XAO}\Sigma$") \ev "$\chi\alpha{}o\varsigma$"
(string-downcase "$\mathit{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\varsigma$"
(string-downcase "$\mathit{XAO}\Sigma~\Sigma$") \ev "$\chi\alpha{}o\varsigma~\sigma$"
(string-foldcase "$\mathit{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\sigma$"
(string-upcase "$\chi\alpha{}o\varsigma$") \ev "$\mathit{XAO}\Sigma$"
(string-upcase "$\chi\alpha{}o\sigma$") \ev "$\mathit{XAO}\Sigma$"

(string-titlecase "kNock KNoCK")
\ev "Knock Knock"
(string-titlecase "who's there?")
\ev "Who's There?"
(string-titlecase "r6rs") \ev "R6Rs"
(string-titlecase "R6RS") \ev "R6Rs"
\end{scheme}

\begin{note}
  These mappings can be extracted from {\cf UnicodeData.txt}, {\cf
    SpecialCasing.txt}, and {\cf CaseFolding.txt} from the Unicode
  Consortium.

  Since each of these procedures is locale-independent, they may not
  be completely appropriate for some locales.
\end{note}

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vari{string} \varii{string}}{library procedure}
\proto{string-ci<?}{ \vari{string} \varii{string}}{library procedure}
\proto{string-ci>?}{ \vari{string} \varii{string}}{library procedure}
\proto{string-ci<=?}{ \vari{string} \varii{string}}{library procedure}
\proto{string-ci>=?}{ \vari{string} \varii{string}}{library procedure}}

\nodomain{Both \vari{string} and \varii{string} must be strings.}
These procedures are similar to {\cf string=?}\ et cetera, but operate
on the fold-cased versions of the strings.

Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

\begin{scheme}
(string-ci<? "z" "Z") \ev \schfalse
(string-ci=? "z" "Z") \ev \schtrue
(string-ci=? "Stra\ss{}e" "Strasse") 
\ev \schtrue
(string-ci=? "Stra\ss{}e" "STRASSE")
\ev \schtrue
(string-ci=? "$\mathit{XAO}\Sigma$" "$\chi\alpha{}o\sigma$")
\ev \schtrue
\end{scheme}

\begin{note}
These procedures could be defined as follows:
%
\begin{scheme}
; string-ci-comparator itself is not part of the
; specification; it is used only to define 
; other procedures
(define (string-ci-comparator cs-comp)
  (lambda (a-string b-string)
    (cs-comp (string-foldcase a-string)
             (string-foldcase b-string))))

(define string-ci=? (string-ci-comparator string=?))
(define string-ci<? (string-ci-comparator string<?))
(define string-ci>? (string-ci-comparator string>?))
(define string-ci<=? (string-ci-comparator string<=?))
(define string-ci>=? (string-ci-comparator string>=?))
\end{scheme}
\end{note}

\end{entry}

\begin{entry}{%
\proto{substring}{ string start end}{library procedure}}

\domain{\var{String} must be a string, and \var{start} and \var{end}
must be exact integers satisfying
$$0 \leq \var{start} \leq \var{end} \leq \hbox{\tt(string-length \var{string})\rm.}$$}
{\cf Substring} returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} (inclusive) and ending with index
\var{end} (exclusive).
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{library procedure}}

Returns a newly allocated string whose characters form the concatenation of the
given strings.

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{library procedure}
\proto{list->string}{ list}{library procedure}}

{\cf String\coerce{}list} returns a newly allocated list of the
characters that make up the given string.  {\cf List\coerce{}string}
returns a newly allocated string formed from the characters in the list
\var{list}, which must be a list of characters. {\cf String\coerce{}list}
and {\cf list\coerce{}string} are
inverses so far as {\cf equal?}\ is concerned.  
%Implementations that provide
%destructive operations on strings should ensure that the result of
%{\cf list\coerce{}string} is newly allocated.

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{library procedure}}

Returns a newly allocated copy of the given \var{string}.

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string char}{library procedure}}

Stores \var{char} in every element of the given \var{string} and returns an
unspecified value.  % <!>

\end{entry}

\begin{entry}{
\proto{string-normalize-nfd}{ \var{string}}{library procedure}
\proto{string-normalize-nfkd}{ \var{string}}{library procedure}
\proto{string-normalize-nfc}{ \var{string}}{library procedure}
\proto{string-normalize-nfkc}{ \var{string}}{library procedure}}
  
These procedures take a string argument argument and return a string
result.  They each return a string that is the input string normalized
to Unicode form D, KD, C, or KC, respectively.

\begin{scheme}
(string-normalize-nfd "\backwhack{}xE9;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}xE9;")
\ev "\backwhack{}xE9;"
(string-normalize-nfd "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}xE9;"
\end{scheme}
\end{entry}

\subsection{Vectors}
\label{vectorsection}

Vectors are heterogenous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time required to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The {\em valid indexes}\index{valid indexes} of a
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Vectors are written using the notation {\tt\#(\var{obj} \dotsfoo)}.
For example, a vector of length 3 containing the number zero in element
0, the list {\cf(2 2 2 2)} in element 1, and the string {\cf "Anna"} in
element 2 can be written as following:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

Note that this is the external representation of a vector, not an
expression evaluating to a vector.  Like list constants, vector
constants must be quoted:

\begin{scheme}
'\#(0 (2 2 2 2) "Anna")  \lev  \#(0 (2 2 2 2) "Anna")%
\end{scheme}

\todo{Pitman sez: The visual similarity to lists is bound to be confusing
to some.  Elaborate on the distinction.}


\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{library procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-ref} returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (let ((i (round (* 2 (acos -1)))))
              (if (inexact? i)
                  (inexact->exact i)
                  i))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-set!} stores \var{obj} in element \vr{k} of \var{vector}.
The value returned by {\cf vector-set!}\ is unspecified.  % <!>

\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{library procedure}
\proto{list->vector}{ list}{library procedure}}

{\cf Vector->list} returns a newly allocated list of the objects contained
in the elements of \var{vector}.  {\cf List->vector} returns a newly
created vector initialized to the elements of the list \var{list}.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-fill!}{ vector fill}{library procedure}}

Stores \var{fill} in every element of \var{vector}.
The value returned by {\cf vector-fill!}\ is unspecified.  % <!>

\end{entry}

\section{Records}

This section describes abstractions for creating new data types
representing records---data structures with named fields. The record
mechanism comes in four parts:

\begin{itemize}
\item a procedural layer for creating and manipulating record types and record
  instances
\item an explicit-naming syntactic layer for defining the various entities
  associated with a record type---construction procedure, predicate, field
  accessors, mutators, etc.---at once
\item an implicit-naming syntactic layer built on top of the explicit-naming
  syntactic layer, which chooses the names for the various products based on
  the names of the record type and fields
\item a set of reflection procedures
\end{itemize}
% 
The procedural layer allows dynamic construction of new record types and
associated procedures for creating and manipulating records, which is
particularly useful when writing interpreters that construct host-compatible
record types. It may also serve as a target for expansion of the syntactic
layers.

The procedural layer allows record types to be extended. This allows using
record types to naturally model hierarchies that occur in applications like
algebraic data types, and also single-inheritance class systems. This model of
extension has a well-understood representation that is simple to implement.

The explicit-naming syntactic layer provides a basic syntactic interface
whereby a single record definition serves as a shorthand for the definition of
several record creation and manipulation routines: a construction procedure, a
predicate, field accessors, and field mutators. As the name suggests, the
explicit-naming syntactic layer requires the programmer to name each of these
products explicitly.
and non-generative record types.

The implicit-naming syntactic layer extends the explicit-naming syntactic layer
by allowing the names for the construction procedure, predicate, accessors, and
mutators to be determined automatically from the name of the record and names
of the fields. This establishes a standard naming convention and allows
record-type definitions to be more succinct, with the downside that the product
definitions cannot easily be located via a simple search for the product name.
The programmer may override some or all of the default names by specifying them
explicitly as in the explicit-naming syntactic layer.

The two layers are designed to be fully compatible; the implicit-naming layer
is simply a conservative extension of the explicit-naming layer. The goal is to
make both explicit-naming and implicit-naming definitions reasonably natural
while allowing a seamless transition between explicit and implicit naming.

The reflection procedures allow programs to obtain from a record instance a
descriptor for the type and from there obtain access to the fields of the
record instance. This allows the creation of portable printers and inspectors.
A program may prevent access to a record's type and thereby protect the
information stored in the record from the reflection mechanism by declaring the
type opaque. Thus, opacity as presented here can be used to enforce abstraction
barriers.

\subsection{Procedural layer}

\begin{entry}{%
\pproto{(make-record-type-descriptor \var{name}}{procedure}}
\mainschindex{make-record-type-descriptor}{\tt\obeyspaces\\
        \var{parent} \var{uid} \var{sealed?} \var{opaque?} \var{fields})}
   
This returns a \defining{record-type descriptor}, or \defining{rtd}.
The rtd represents a record type distinct from all built-in types and
other record types. The rtd and the data type it represents are new
except possibly if \var{uid} is provided (see below).

The \var{name} argument must be a symbol naming the record type; it is
purely for informational purposes, and may be used for printing by the
underlying Scheme system.

The \var{parent} argument is either \schfalse{} or an rtd. If it is an
rtd, the returned record type, \var{t}, extends the record type
\var{p} represented by parent. Each record of type \var{t} is also a
record of type \var{p}, and all operations applicable to a record of
type \var{p} are also applicable to a record of type \var{t}, except for
reflection operations if \var{t} is opaque but \var{p} is not. An error is
signalled if parent is sealed (see below).
   
The extension relationship is transitive in the sense that a type extends
its parent's parent, if any, and so on.
   
The \var{uid} argument is either \schfalse{} or a symbol. If it is a
symbol, the created record type is non-generative, i.e. there may be
only one record type with that \var{uid} in the entire system (in the
sense of {\cf eqv?}).  When {\cf make-record-type-descriptor} is
called repeatedly with the same \var{uid} argument (in the sense of
{\cf eq?}), the parent argument must be the same in the sense of {\cf
  eqv?}  (more on this below), and the \var{uid}, \var{sealed?},
\var{opaque?}, and \var{fields} arguments must be the same in the
sense of {\cf equal?}.  In this case, the same record-type descriptor
(in the sense of {\cf eqv?})  is returned every time. If a call with
the same uid differs in any argument, an error is signalled. If
\var{uid} is \schfalse, or if no record type with the given uid has
been created before, {\cf make-record-type-descriptor} returns a fresh
record-type descriptor representing a new type disjoint from all other
types.

\begin{note}   
  Users are strongly strongly encouraged to use symbol names
  constructed using the UUID namespace (for example, using the
  record-type name as a prefix) for the uid argument.
\end{note}

If \var{parent} is not \schfalse, and \var{uid} is not \schfalse, and
the parent is generative (i.e.  its uid is \schfalse), an error is signalled.
In other words, the parent of a non-generative rtd must be
non-generative itself.

The \var{sealed?} flag is a boolean. If true, the returned record type
is sealed, i.e., it cannot be extended.

The \var{opaque?} flag is a boolean. If true, the returned record type
is opaque.  This means that calls to {\cf record?} will return
\schfalse{} and {\cf record-rtd} (see ``Reflection'' below) will signal
an error. The record type is also opaque if an opaque parent is
supplied.  If \var{opaque?} is false and an opaque parent is not
supplied, the record is not opaque.

The \var{fields} argument must be a list of field specifiers. Each
field specifier must be a list of the form (mutable name), or a list
of the form (immutable name). The specified fields are added to the
parent fields, if any, to determine the complete set of fields of the
returned record type.  Each name must be a symbol and names the
corresponding field of the record type; the names need not be
distinct. A field with tag mutable may be modified, whereas an attempt
to obtain a mutator for a field with tag immutable will signal an
error.

Where field order is relevant, e.g., for record construction and field
access, the fields are considered to be ordered as specified, although
no particular order is required for the actual representation of a
record instance.

A record type whose complete set of fields are all immutable is
considered immutable itself. Conversely, a record type is considered
mutable if there is at least one mutable field in its complete set of
fields.

A generative record-type descriptor created by a call to {\cf
  make-record-type-descriptor} is not {\cf eqv?} to any record-type
descriptor (generative or non-generative) created by another call to
{\cf make-record-type-descriptor}. A generative record-type descriptor
is {\cf eqv?}  only to itself, i.e., {\tt (eqv?~\vri{rtd} \vrii{rtd})} iff
{\tt (eq?~\vri{rtd} \vrii{rtd})}.  Moreover:

\begin{scheme}
(let ((rtd (make-record-type-descriptor \ldots)))
  (eqv? rtd rtd))                \ev \schfalse
\end{scheme}

Note that this does not imply the following:

\begin{scheme}
(let ((rtd (make-record-type-descriptor \ldots)))
  (eq? rtd rtd))                 \ev \schtrue
\end{scheme}

Also, two non-generative record-type descriptors are eqv? iff they were
successfully created by calls to make-record-type-descriptor with the same
uid arguments.
\end{entry}

\begin{entry}{%
\proto{record-type-descriptor?}{ obj}{procedure}}
   
This returns \schtrue if the argument is a record-type descriptor,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{make-record-constructor-descriptor}{ rtd parent-constructor-descriptor protocol}{procedure}}
   
This returns a \defining{record-constructor descriptor} (or
\defining{constructor descriptor} for short) that can be used to
create record constructors (via {\cf record-constructor}; see below)
or other constructor descriptors.  \var{Rtd} must be a record-type
descriptor.  Protocol is a \defining{protocol}, that describes how to
initialize the fields of \var{rtd} in the record when it is constructed. The
protocol is a procedure of one parameter that must itself return a
procedure, the constructor. The protocol procedure is called by
{\cf record-constructor} with a procedure as an argument that can be used to
construct the record object itself and seed the fields of the parent
types of \var{rtd} with initial values.

If \var{rtd} is not an extension of another record type, then
parent-constructor-descriptor must be \schfalse. In this case, the
protocol receives as argument a procedure \var{new} that has a
parameter for every field of \var{rtd}; \var{new} will return a record
object with the fields of \var{rtd} initialized to its arguments.

Protocol example:

\begin{scheme}
(lambda (new) (lambda (v \ldots)  (new v \ldots)))
\end{scheme}

Here, the call to {\cf new} will return a record where the fields of
\var{rtd} are simply initialized with the arguments {\tt v \ldots}.

As the protocol can be used to construct records of an extension of
\var{rtd}, the record returned by new may actually be of a record type
extending \var{rtd}.  (See below.)

If \var{rtd} is an extension of another record type \var{rtd'},
parent-constructor-descriptor itself must be a constructor descriptor
of \var{rtd'} (except for default values; see below). In this case,
the protocol receives as argument a procedure \var{p} whose arguments
will be passed unchanged to the constructor of
parent-constructor-descriptor; \var{p} will return another procedure that
accepts as argument the initial values for the fields of \var{rtd} and
itself returns what the constructor of parent-constructor-descriptor
returned, with the field values of \var{rtd'} (and its parent and so on)
initialized according to parent-constructor-descriptor and with the
field values of \var{rtd} initialized according to \var{p}.

As a matter of convention, the constructor created through the
protocol should always return the record object itself.

Protocol example:

\begin{scheme}
(lambda (p)
  (lambda (x \ldots v \ldots)
    (let ((construct (p x \ldots)))
      (construct v \ldots))))
\end{scheme}
    
This will initialize the fields of the parent of \var{rtd} according
to parent-constructor-descriptor, calling the associated constructor
with {\tt x \ldots} as arguments, and initializing the fields of \var{rtd}
itself with {\tt v \ldots}

Summarizing: the constructor descriptors for a record type form a chain of
protocols exactly parallel to the chain of record-type parents. Each
constructor descriptor in the chain determines the field values for the
associated record type.

Protocol can be \schfalse, specifying a default. This is only
admissible if either \var{rtd} is not an extension of another record
type, or, if it is, if parent-constructor-descriptor itself was
constructed with a default protocol. In the first case, protocol will
default to a procedure equivalent to the following:

\begin{scheme}
(lambda (p)
  (lambda field-values
    (apply p field-values)))
\end{scheme}
  
In the latter case, it will default to a protocol that returns a
constructor that will accept as many arguments as \var{rtd} has total
fields (i.e. as the sum of the number of fields in the entire chain of
record types) and will return a record with fields initialized to
those arguments, with the field values for the parent coming before
those of the extension in the argument list.

\begin{rationale}
  The constructor-descriptor mechanism is an infrastructure for
  creating specialized constructors, rather than just creating default
  constructors that accept the initial values of all the fields as
  arguments. This infrastructure achieves full generality while
  leaving each level of an inheritance hierarchy in control over its
  own fields and allowing child record definitions to be abstracted
  away from the actual number and contents of parent fields.

  The design allows the initial values of the fields to be specially
  computed or default to constant values. It also allows for
  operations to be performed on or with the resulting record, such as
  the registration of a widget record for finalization. Moreover, the
  constructor-descriptor mechanism allows the creation of such
  initializers in a modular manner, separating the initialization
  concerns of the parent types of those of the extensions.
  
  The mechanism described here achieves complete generality without
  cluttering the syntactic layer, possibly sacrificing a bit of
  notational convenience in special cases.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{record-constructor}{ constructor-descriptor}{procedure}}
   
Calls the protocol of record-constructor descriptor
\var{constructor-descriptor} with an appropriate procedure \var{c} as
an argument (see the description of {\cf
  make-record-constructor-descriptor}) that will create a record of
the record type associated with \var{constructor-descriptor}.

If the record type associated with \var{constructor-descriptor} is
opaque, then the values created by such a constructor are not
considered by the reflection procedures to be records; see the
specification of {\cf record?} below.

A record from an immutable record type is called immutable;
conversely, a record from a mutable record type is called mutable.

Two records created by such a constructor are equal according to {\cf
  equal?} iff they are {\cf eqv?}, provided their record type was not
used to implement any of the types explicitly mentioned in the
definition of {\cf equal?}.

If construct is bound to a constructor returned by {\cf
  record-constructor}, the following holds:

\begin{scheme}
(let ((r (construct \ldots)))
  (eqv? r r))                \ev \schtrue
\end{scheme}

For mutable records, but not necessarily for immutable ones, the following
holds:

\begin{scheme}
(let ((r (construct \ldots)))
  (eq? r r))                 \ev \schtrue
\end{scheme}

For mutable records, the following holds:

\begin{scheme}
(let ((f (lambda () (construct \ldots))))
  (eq? (f) (f))) \ev \schfalse
\end{scheme}

For immutable records, the value of the above expression is
unspecified.
\end{entry}

\begin{entry}{%
\proto{record-predicate}{ rtd}{procedure}}
   
Returns a procedure that, given an object \var{obj}, returns
\schtrue{} iff \var{obj} is a record of the type represented by
\var{rtd}.
\end{entry}

\begin{entry}{%
\proto{record-accessor}{ rtd k}{procedure}}
   
Given a record-type descriptor \var{rtd} and an exact non-negative
integer \var{k} that specifies one of the fields of \var{rtd}, {\cf
  record-accessor} returns a one-argument procedure that, given a
record of the type represented by \var{rtd}, returns the value of the
selected field of that record.

It is an error if the accessor procedure is given something other than
a record of the type represented by \var{rtd}. Note that the records
of the type represented by \var{rtd} include records of extensions of
the type represented by \var{rtd}.

The field selected is the one corresponding the the \var{k}th element
(0-based) of the \var{fields} argument to the invocation of {\cf
  make-record-type-descriptor} that created \var{rtd}. Note that
\var{k} cannot be used to specify a field of any type \var{rtd} extends.
\end{entry}

\begin{entry}{%
\proto{record-mutator}{ rtd k}{procedure}}
   
Given a record-type descriptor \var{rtd} and an exact non-negative
integer \var{k} that specifies one of the mutable fields of \var{rtd},
{\cf record-accessor} returns a two-argument procedure that, given a
record \var{r} of the type represented by \var{rtd} and an object
\var{obj}, stores \var{obj} within the field of \var{r} specified by
\var{k}. The \var{k} argument is as in {\cf record-accessor}. If
\var{k} specifies an immutable field, an error is signalled.
\end{entry}

\begin{scheme}
(define :point
  (make-record-type-descriptor
   'point \schfalse{}
   \schfalse{} \schfalse{} \schfalse{} 
   '((mutable x) (mutable y))))

(define make-point
  (record-constructor
    (make-record-constructor-descriptor :point
                                        \schfalse{} \schfalse{})))

(define point? (record-predicate :point))
(define point-x (record-accessor :point 0))
(define point-y (record-accessor :point 1))
(define point-x-set! (record-mutator :point 0))
(define point-y-set! (record-mutator :point 1))

(define p1 (make-point 1 2))
(point? p1) \ev \schtrue{}
(point-x p1) \ev 1
(point-y p1) \ev 2
(point-x-set! p1 5)
(point-x p1) \ev 5

(define :point2
  (make-record-type-descriptor
   'point2 :point 
   \schfalse{} \schfalse{} \schfalse{} '((mutable x) (mutable y))))

(define make-point2
  (record-constructor
    (make-record-constructor-descriptor :point2
                                        \schfalse{} \schfalse{})))
(define point2? (record-predicate :point2))
(define point2-xx (record-accessor :point2 0))
(define point2-yy (record-accessor :point2 1))

(define p2 (make-point2 1 2 3 4))
(point? p2) \ev \schtrue{}
(point-x p2) \ev 1
(point-y p2) \ev 2
(point2-xx p2) \ev 3
(point2-yy p2) \ev 4
\end{scheme}

\subsection{Explicit-Naming Syntactic Layer}

The record-type-defining form {\cf define-record-type} is a definition and
can appear anywhere any other \hyper{definition} can appear.

\begin{entry}{%
\proto{define-record-type}{ \hyper{name spec} \arbno{\hyper{record clause}}}{library \exprtype}}

A {\cf define-record-type} form defines a new record type along with
associated constructor descriptor and constructor, predicate, field
accessors and field mutators. The {\cf define-record-type} form expands into
a set of definitions in the environment where {\cf define-record-type}
appears; hence, it is possible to refer to the bindings (except for
that of the record type itself) recursively.

The \hyper{name spec} specifies the names of the record type,
construction procedure, and predicate. It must take the following
form.

\begin{scheme}
(\hyper{record name} \hyper{constructor name} \hyper{predicate name})
\end{scheme}

\hyper{Record name}, \hyper{constructor name}, and \hyper{predicate
  name} must all be identifiers.

\hyper{Record name}, taken as a symbol, becomes the name of the record
type.  Additionally, it is bound by this definition to an expand-time
or run-time description of the record type for use as parent name in
syntactic record-type definitions that extend this definition. It may
also be used as a handle to gain access to the underlying record-type
descriptor and constructor descriptor (see {\cf
  record-type-descriptor} and {\cf record-constructor-descriptor}
below).

\hyper{Constructor name} is defined by this definition to a
constructor for the defined record type, with a protocol specified by
the protocol clause, or, in its absence, using a default value. For
details, see the description of the protocol clause below.

\hyper{Predicate name} is defined by this definition to a predicate
for the defined record type.

Each \hyper{record clause} must take one of the following forms; it is
an error if multiple \hyper{record clause}s of the same kind appear in a
{\cf define-record-type} form.

\begin{itemize}
\item {\tt (fields \arbno{\hyper{field-spec}})}
   
  where each \hyper{field-spec} has one of the following forms
  
\begin{scheme}
(immutable \hyper{field name} \hyper{accessor name})
(mutable \hyper{field name} \hyper{accessor name} \hyper{mutator name})
\end{scheme}

  \hyper{Field name}, \hyper{accessor name}, and \hyper{mutator name}
  must all be identifiers. The first form declares an immutable field
  called \hyper{field name}, with the corresponding accessor named \hyper{acccessor
  name}. The second form declares a mutable field called \hyper{field name},
  with the corresponding accessor named \hyper{acccessor name}, and with the
  corresponding mutator named \hyper{mutator name}.
   
  The \hyper{field name}s become, as symbols, the names of the fields of the
  record type being created, in the same order. They are not used in any
  other way.
   
\item {\tt (parent \hyper{parent name})}
   
  This specifies that the record type is to have parent type
  \hyper{parent name}, where \hyper{parent name} is the \hyper{record
      name} of a record type previously defined using {\cf
      define-record-type}. The absence of a parent clause implies a
    record type with no parent type.
   
\item {\tt (protocol \hyper{exp})}
   
  \hyper{Exp} is evaluated in the same environment as the
  define-record-type form, and must evaluate to a protocol appropriate
  for the record type being defined (see above in the description of
  {\cf make-record-constructor-descriptor}). The protocol is used to
  create a record-constructor descriptor where, if the record type
  being defined has a parent, the parent-type constructor descriptor
  is that associated with the parent type specified in the {\cf
    parent} clause.
   
  If no {\cf protocol} clause is specified, a constructor descriptor
  is still created using a default protocol. The rules for this are
  the same as for {\cf make-record-constructor-descriptor}: the clause
  can be absent only if the record type defined has no parent type, or
  if the parent definition does not specify a protocol.
   
\item {\tt (sealed \schtrue)}\\
  {\tt (sealed \schfalse)}
   
  If this option is specified, it means that the opacity of the type
  is the value specified as the operand. If no {\cf sealed} option is
  present, the defined record type is not sealed.
   
\item {\tt (opaque \schtrue)}\\
  {\tt (opaque \schfalse)}
   
  If this option is specified, it means that the opacity of the type
  is the value specified as the operand. It is also opaque if an
  opaque parent is specified. If the opaque {\cf option} is not
  present, the record type is not opaque.
   
\item {\tt (nongenerative \hyper{uid})}
   
  This specifies that the record type be nongenerative with uid
  \hyper{uid}, which must be an \hyper{identifier}. The absence of a
  {\cf nongenerative} clause implies that the defined type is
  generative. In the latter case, a new type may be generated once for
  each evaluation of the record definition or once for all evaluations
  of the record definition, but the type is guaranteed to be distinct
  even for verbatim copies of the same record definition appearing in
  different parts of a program.
   
  Note that all bindings created by this form (for the record type, the
  construction procedure, the predicate, the accessors, and the mutators)
  must have names that are pairwise distinct.

  For two non-generative record-type definitions with the same uid, if
  the implied arguments to {\cf make-record-type-descriptor} would
  create an equivalent record-type descriptor, the created type is the
  same as the previous one.  Otherwise, an error is signalled.

  Note again that, in the absence of a {\cf nongenerative} clause, the
  question of expand-time or run-time generativity is unspecified.
  Specifically, the return value of the following expression in
  unspecified:

\begin{scheme}
(let ((f (lambda (x)
           (define-record-type r \ldots)
           (if x r? (make-r \ldots)))))
  ((f \schtrue) (f \schfalse)))
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{record-type-descriptor}{ \hyper{record name}}{library \exprtype}}
   
This evaluates to the record-type descriptor associated with the type
specified by \hyper{record-name}.
   
Note that, in the absense, of a {\cf nongenerative} clause, the return value of
the following expression is unspecified:
  
\begin{scheme} 
(let ((f (lambda ()
           (define-record-type r \ldots)
           (record-type-descriptor r))))
  (eqv? (f) (f)))
\end{scheme}

Note that {\cf record-type-descriptor} works on both opaque and non-opaque record
types.
\end{entry}

\begin{entry}{%
\proto{record-constructor-descriptor}{ \hyper{record name}}{library \exprtype}}
   
This evaluates to the record-constructor descriptor associated with
\hyper{record-name}.
\end{entry}

\begin{scheme}
(define-record-type (point3 make-point3 point3?)
  (fields (immutable x point3-x)
          (mutable y point3-y set-point3-y!))
  (nongenerative
    point3-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point3)
  (protocol
   (lambda (p)
     (lambda (x y c) 
       ((p x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p3-1 (make-point3 1 2))
(define p3-2 (make-cpoint 3 4 'red))

(point3? p3-1) \ev \schtrue{}
(point3? p3-2) \ev \schtrue{}
(point3? (vector)) \ev \schfalse{}
(point3? (cons 'a 'b)) \ev \schfalse{}
(cpoint? p3-1) \ev \schfalse{}
(cpoint? p3-2) \ev \schtrue{}
(point3-x p3-1) \ev 1
(point3-y p3-1) \ev 2
(point3-x p3-2) \ev 3
(point3-y p3-2) \ev 4
(cpoint-rgb p3-2) \ev '(rgb . red)

(set-point3-y! p3-1 17)
(point3-y p3-1) \ev 17)

(record-rtd p3-1) \lev (record-type-descriptor point3)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (new) (lambda a (new a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))
(ex1-f ex1-i1) \ev '(1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (new) (lambda (a . b) (new a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))
(ex2-a ex2-i1) \ev 1
(ex2-b ex2-i1) \ev '(2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (new)
     (lambda (x y z)
       (let ((length (+ (* x x) (* y y) (* z z))))
         (new  (/ x length)
               (/ y length)
               (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))
\end{scheme}

\subsection{Implicit-Naming Syntactic Layer}

The {\cf define-record-type} form of the implicit-naming syntactic
layer is a conservative extension of the {\cf define-record-type} form
of the explicit-naming layer: a {\cf define-record-type} form that
conforms to the syntax of the explicit-naming layer also conforms to
the syntax of the implicit-naming layer, and any definition in the
implicit-naming layer can be understood by its translation into the
explicit-naming layer.

This means that a record type defined by the {\cf define-record-type}
form of either layer can be used by the other.

The implicit-naming syntactic layer extends the explicit-naming layer
in two ways. First, \hyper{name-spec} may be a single identifier
representing just the record name. In this case, the name of the
construction procedure is generated by prefixing the record name with
{\tt make-}, and the predicate name is generated by adding a question
mark ({\tt ?}) to the end of the record name. For example, if the
record name is {\tt frob} then the name of the construction procedure is
{\tt make-frob} and the predicate name is {\tt frob?}.

Second, the syntax of \hyper{field-spec} is extended to allow the
accessor and mutator names to be omitted. That is, \hyper{field-spec}
can take one of the following forms as well as the forms described in
the preceding section.

\begin{scheme}
(immutable \hyper{field name})
(mutable \hyper{field name})
\end{scheme}

If \hyper{field-spec} takes one of these forms, then the accessor name
is generated by appending the record name and field name with a hyphen
separator, and the mutator name (for a mutable field) is generated by
adding a {\tt -set!} suffix to the accessor name. For example, if the
record name is {\tt frob} and the field name is {\tt widget}, the
accessor name is {\tt frob-widget} and the mutator name is
{\tt frob-widget-set!}.

Note that the field names with implicitly-named accessors must be
distinct to avoid a conflict between the accessors.

Any definition that takes advantage of implicit naming can be
rewritten trivially to a definition that conforms to the syntax of the
explicit-naming layer merely by specifing the names explicitly. For
example, the implicit-naming layer record definition:

\begin{scheme}
(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

is equivalent to the following explicit-naming layer record definition.

\begin{scheme}
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget frob-widget-set!))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

With the explicit-naming layer, one can choose to specify just some of
the names explicitly; for example, the following overrides the choice
of accessor and mutator names for the widget field.

\begin{scheme}
(define-record-type (frob make-frob frob?)
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (c) (c (make-widget n)))))
\end{scheme}

\begin{scheme}
(define *ex3-instance* \schfalse{})

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (p)
     (lambda (x y t)
       (let ((r ((p x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields 
   (mutable thickness))
  (sealed \schtrue{}) (opaque \schtrue{}))

(define ex3-i1 (make-ex3 1 2 17))
(ex3? ex3-i1) \ev \schtrue{}
(cpoint-rgb ex3-i1) \ev '(rgb . red)
(ex3-thickness ex3-i1) \ev 17
(ex3-thickness-set! ex3-i1 18)
(ex3-thickness ex3-i1) \ev 18
*ex3-instance* \ev ex3-i1

(record? ex3-i1) \ev \schfalse{}
\end{scheme}


\subsection{Reflection}

A set of procedures are provided for reflecting on records and their
record-type descriptors. These procedures are designed to allow the
writing of portable printers and inspectors.

Note that {\cf record?} and {\cf record-rtd} treat records of opaque
record types as if they were not records. On the other hand, the
reflection procedures that operate on record-type descriptors
themselves are not affected by opacity. In other words, opacity
controls whether a program can obtain an rtd from an instance. If the
program has access to the original rtd via {\cf
  make-record-type-descriptor} or {\cf record-type-descriptor} it can
reflect upon it.

\begin{entry}{%
\proto{record?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a record, and its record type is
not opaque. Returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{record-rtd}{ rec}{procedure}}
   
Returns the rtd representing the type of \var{rec} if the type is not
opaque. The rtd of the most precise type is returned; that is, the
type \var{t} such that \var{rec} is of type \var{t} but not of any
type that extends \var{t}.  If the type is opaque, {\cf record-rtd} signals
an error.
\end{entry}

\begin{entry}{%
\proto{record-type-name}{ rtd}{procedure}}
   
Returns the name of the record-type descriptor \var{rtd}.
\end{entry}   

\begin{entry}{%
\proto{record-type-parent}{ rtd}{procedure}}
   
Returns the parent of the record-type descriptor \var{rtd}, or
\schfalse{} if it has none.
\end{entry}

\begin{entry}{%
\proto{record-type-uid}{ rtd}{procedure}}
   
Returns the uid of the record-type descriptor rtd, or \schfalse{} if it has none.
(An implementation may assign a generated uid to a record type even if the
type is generative, so the return of a uid does not necessarily imply that
the type is nongenerative.)
\end{entry}

\begin{entry}{%
\proto{record-type-generative?}{ rtd}{procedure}}
   
Returns \schtrue{} if \var{rtd} is generative, and \schfalse{} if not.
\end{entry}

\begin{entry}{%
\proto{record-type-sealed?}{ rtd}{procedure}}

Returns a boolean value indicating whether the record-type descriptor is
sealed.
\end{entry}

\begin{entry}{%
\proto{record-type-opaque?}{ rtd}{procedure}}
   
Returns a boolean value indicating whether the record-type descriptor is
opaque.
\end{entry}

\begin{entry}{%
\proto{record-type-field-names}{ rtd}{procedure}}
   
Returns a list of symbols naming the fields of the type represented by rtd
(not including the fields of parent types) where the fields are ordered as
described under {\cf make-record-type-descriptor}.
\end{entry}

\begin{entry}{%
\proto{record-field-mutable?}{ rtd k}{procedure}}
   
Returns a boolean value indicating whether the field specified by
\var{k} of the type represented by \var{rtd} is mutable, where \var{k}
is as in {\cf record-accessor}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 
