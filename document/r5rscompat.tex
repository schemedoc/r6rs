\chapter{R$^5$RS compatibility}
\label{r5rscompatchapter}

The procedures described in this chapter are exported from the
\deflibrary{r6rs r5rs} library, and provide procedures described in the
previous revision of this report~\cite{R5RS}, but omitted from this
revision.

\begin{entry}{%
\proto{exact->inexact}{ z}{procedure}
\proto{inexact->exact}{ z}{procedure}}

These are the same as the {\cf ->inexact} and {\cf ->exact}
procedures; see report section~\ref{report:->inexact}.
\end{entry}

\begin{entry}{%
\proto{quotient}{ \vari{n} \varii{n}}{procedure}
\proto{remainder}{ \vari{n} \varii{n}}{procedure}
\proto{modulo}{ \vari{n} \varii{n}}{procedure}}

These procedures implement number-theoretic (integer)
division.  \vrii{n} must be non-zero.  All three procedures
return integers.  If \vri{n}/\vrii{n} is an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vri{n}/\vrii{n}
    (remainder \vri{n} \vrii{n})  \ev 0
    (modulo \vri{n} \vrii{n})     \ev 0
\end{scheme}
If \vri{n}/\vrii{n} is not an integer:
\begin{scheme}
    (quotient \vri{n} \vrii{n})   \ev \vr{n_q}
    (remainder \vri{n} \vrii{n})  \ev \vr{n_r}
    (modulo \vri{n} \vrii{n})     \ev \vr{n_m}
\end{scheme}
where \vr{n_q} is $\vri{n}/\vrii{n}$ rounded towards zero,
$0 < |\vr{n_r}| < |\vrii{n}|$, $0 < |\vr{n_m}| < |\vrii{n}|$,
\vr{n_r} and \vr{n_m} differ from \vri{n} by a multiple of \vrii{n},
\vr{n_r} has the same sign as \vri{n}, and
\vr{n_m} has the same sign as \vrii{n}.

Consequently, for integers \vri{n} and \vrii{n} with
\vrii{n} not equal to 0,
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (quotient \vri{n} \vrii{n}))
           (remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
provided all numbers involved in that computation are exact.

\begin{scheme}
(modulo 13 4)           \ev  1
(remainder 13 4)        \ev  1

(modulo -13 4)          \ev  3
(remainder -13 4)       \ev  -1

(modulo 13 -4)          \ev  -3
(remainder 13 -4)       \ev  1

(modulo -13 -4)         \ev  -1
(remainder -13 -4)      \ev  -1

(remainder -13 -4.0)    \ev  -1.0  ; inexact%
\end{scheme}

\begin{note}
  These procedures could be defined in terms of {\cf div} and {\cf
    mod} (see report section~\ref{report:div}) as follows (without checking of the
  argument types):
\begin{scheme}
(define (sign n)
  (cond
    ((negative? n) -1)
    ((positive? n) 1)
    (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
\end{scheme}
\end{note}
\end{entry}

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{\exprtype}}

The {\cf delay} construct is used together with the procedure \ide{force} to
implement \defining{lazy evaluation} or \defining{call by need}.
{\tt(delay~\hyper{expression})} returns an object called a
\defining{promise} which at some point in the future may be asked (by
the {\cf force} procedure) to evaluate
\hyper{expression}, and deliver the resulting value.
The effect of \hyper{expression} returning multiple values
is unspecified.

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{procedure}}

{\var{Promise} must be a promise.}

Forces the value of \var{promise}.  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned.

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                               \ev  2%
\end{scheme}

Promises are mainly intended for programs written in
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Here is a possible implementation of {\cf delay} and {\cf force}.
Promises are implemented here as procedures of no arguments,
and {\cf force} simply calls its argument:

\begin{scheme}
(define force
  (lambda (object)
    (object)))%
\end{scheme}

The expression

\begin{scheme}
(delay \hyper{expression})%
\end{scheme}

has the same meaning as the procedure call

\begin{scheme}
(make-promise (lambda () \hyper{expression}))\rm
\end{scheme}

as follows

\begin{scheme}
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression))))),%
\end{scheme}

where {\cf make-promise} is defined as follows:

\begin{scheme}
(define make-promise
  (lambda (proc)
    (let ((result-ready? \schfalse)
          (result \schfalse))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? \schtrue)
                         (set! result x)
                         result))))))))%
\end{scheme}

\begin{rationale}
A promise may refer to its own value, as in the last example above.
Forcing such a promise may cause the promise to be forced a second time
before the value of the first force has been computed.
This complicates the definition of {\cf make-promise}.
\end{rationale}

Various extensions to this semantics of {\cf delay} and {\cf force}
are supported in some implementations:

\begin{itemize}
\item Calling {\cf force} on an object that is not a promise may simply
return the object.

\item It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either \schtrue{} or to \schfalse{},
depending on the implementation:

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Some implementations may implement ``implicit forcing'', where
the value of a promise is forced by primitive procedures like \cf{cdr}
and \cf{+}:

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  34%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{null-environment}{ n}{procedure}}

\domain{\var{N} must be the exact integer 5.}  The {\cf
  null-environment} procedure returns an
environment specifier suitable for use with {\cf eval} (see
chapter~\ref{evalchapter}) representing an environment that is empty except
for the (syntactic) bindings for all syntactic keywords described in
the previous revision of this report~\cite{R5RS}.
\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ n}{procedure}}

\domain{\var{N} must be the exact integer 5.}  The {\cf scheme-report-environment} procedure returns
an environment specifier for an environment that is empty except for
the bindings for the standard procedures described in the previous
revision of this report~\cite{R5RS}, omitting {\cf load}, {\cf
  transcript-on}, {\cf transcript-off}, and {\cf char-ready?}.  The
bindings have as values the procedures of the same names described in
this report.
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 
