\section{List utilities}
\label{listutilities}

%% FIXME: clarify if predicates need to return a boolean, or can
%% return anything

\begin{entry}{%
\proto{find}{ predicate list}{procedure}}

\domain{\var{Predicate} must be a predicate taking a single argument,
  and \var{list} must be a list.}  {\cf Find} applies
\var{predicate} to the elements of \var{list} in order.  If
\var{predicate} returns a true value for an element, {\cf find}
immediately returns that element.  If \var{predicate} returns
\schfalse{} for all elements of the list, it returns \schfalse{}

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev 4
(find even? '(3 1 5 1 5 9)) \ev \schfalse{}
\end{scheme}
  
\end{entry}

\begin{entry}{%
\proto{forall}{ predicate \vari{list} \varii{list} \dotsfoo}{procedure}
\proto{exists}{ predicate \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s must be lists, and \var{predicate} must be a
  predicate taking as many arguments as there are {\it list}s. If more
  than one \var{list} is given, then they must all be the same
  length.}  {\cf Forall} applies \var{predicate} element-wise to the
elements of the \var{list}s.  If \var{predicate} returns \schtrue{}
for all but the last elements of the list, \var{forall} performs a
tail call of \var{predicate} on the last elements.  If \var{predicate}
returns \schfalse{} on any set of elements, {\cf forall} returns
\schfalse{} after the first such application of \var{predicate}.  If
the \var{list}s are all empty, {\cf forall} returns \schtrue.

{\cf Exists} applies \var{predicate} element-wise to the
elements of the \var{list}s.  If \var{predicate} returns \schfalse{}
for all but the last elements of the list, \var{exists} performs a
tail call of \var{predicate} on the last elements.  If \var{predicate}
returns a true value on any set of elements, {\cf exists} returns
that value after the first such application of \var{predicate}.  If
the \var{list}s are all empty, {\cf exists} returns \schfalse.

\begin{scheme}
(forall even? '(3 1 4 1 5 9)) \ev \schfalse{}
(forall even? '(2 1 4 14)) \ev \schtrue{}
(forall (lambda (n) (and (even? n) n)) '(2 1 4 14) \ev 14

(exists even? '(3 1 4 1 5 9)) \ev \schtrue{}
(exists even? '(3 1 1 5 9)) \ev \schfalse{}
(exists (lambda (n) (and (even? n) n)) '(2 1 4 14) \ev 2
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{filter}{ predicate list}{procedure}
\proto{partition}{ predicate list}{procedure}
}

\domain{\var{Predicate} must be a predicate taking a single argument,
  and \var{list} must be a list.}  {\cf Filter} successively applies
\var{predicate} to the elements of \var{list} and returns a list of
the values of \var{list} for which \var{predicate} returned a true
value.  {\cf Partition} also successively applies \var{predicate} to
the elements of \var{list}, but returns two values, the first one a
list of the values of \var{list} for which \var{predicate} returned a
true value, and the second a list of the values of \var{list} for
which \var{predicate} returned \schfalse.

\begin{scheme}
(filter even? '(3 1 4 1 5 9 2 6)) \ev (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6) (3 1 1 5 9) ; two values
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{fold-left}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{The \var{list}s must be lists, and \var{kons} must be a
  procedure taking as one more argument than there are {\it list}s. If
  more than one \var{list} is given, then they must all be the same
  length.}  {\cf Fold-left} iterates the \var{kons} procedure over an
accumulator value and the values of the {\it list}s from left to
right, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-left} returns \var{nil} if the {\it list}s are
empty.  If they are not empty, \var{kons} is first applied to
\var{nil} and the respective first elements of the {\it list}s in
order.  The result becomes the new accumulator value, and \var{kons}
is applied to new accumulator value and the respective next elements
of the {\it list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

\begin{scheme}
(fold-left + 0 '(1 2 3 4 5) \ev 15

(fold-left cons '() '(1 2 3 4 5) \lev (5 4 3 2 1)

(fold-left (lambda (x count)
             (if (odd? x) (+ count 1) count))
           0
           '(3 1 4 1 5 9 2 6 5) \lev 6

(fold-left (lambda (s max-len)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer")) \lev 7

(fold-left cons '(q) '(a b c) \lev ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{fold-right}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{The \var{list}s must be lists, and \var{kons} must be a
  procedure taking as one more argument than there are {\it list}s. If
  more than one \var{list} is given, then they must all be the same
  length.}  {\cf Fold-right} iterates the \var{kons} procedure over
the values of the {\it list}s from right to left and an accumulator
value, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-right} returns \var{nil} if the {\it list}s
are empty.  If they are not empty, \var{kons} is first applied to the
respective last elements of the {\it list}s in order and \var{nil}.
The result becomes the new accumulator value, and \var{kons} is
applied to the respective previous elements of the {\it list} and the
new accumulator value.  This step is repeated until the beginning of the
list is reached; then the accumulator value is returned.

\begin{scheme}
(fold-right + 0 '(1 2 3 4 5) \ev 15

(fold-right cons '() '(1 2 3 4 5)) \lev (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5)
\ev (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c)) \lev (a b c q)

(fold-right + 0 '(1 2 3) (4 5 6)) \lev 21
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{remp}{ predicate list}{procedure}
\proto{remove}{ obj list}{procedure}
\proto{remv}{ obj list}{procedure}
\proto{remq}{ obj list}{procedure}}

\domain{\var{Predicate} must be a predicate taking a single argument.}
Each of these procedures returns a list of the elements of \var{lists}
that do not satisfy a given condition.  {\cf Remp} successively
applies \var{predicate} to the elements of \var{list} and returns a
list of the values of \var{list} for which \var{predicate} returned
\schfalse.  {\cf Remove}, {\cf remv}, and {\cf remq} returns a list of
the elements that are not \var{obj}.  {\cf Remq} uses {\cf eq?}\ to
compare \var{obj} with the elements of \var{list}, while {\cf remv}
uses {\cf eqv?}\ and {\cf remove} uses {\cf equal?}.

\begin{scheme}
(remp even? '(3 1 4 1 5 9 2 6 5)) \lev (3 1 1 5 9 2 5)

(remove 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz)) \ev (bar baz)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{memp}{ predicate l}{procedure}
\proto{member}{ obj l}{procedure}
\proto{memv}{ obj l}{procedure}
\proto{memq}{ obj l}{procedure}
}

\domain{\var{Predicate} must be a predicate taking a single argument.
  \var{L} must be a plausible list or a value according to the
  conditions specified below.}

These procedures return the first sublist of \var{l} whose car
satisfies a given condition, where the sublists of \var{l} are the
non-empty lists returned by {\tt (list-tail \var{l} \var{k})} for
\var{k} less than the length of \var{l}.  {\cf Memp} applies
\var{predicate} to the cars of the sublists of \var{l} until it
finds one for which \var{predicate} returns a true value.  {\cf
  Member}, {\cf memv}, and {\cf memq} look for the first occurrence of
\var{obj}.  If \var{l} does not contain an element satisfying the
condition, then \schfalse{} (not the empty list) is returned.  {\cf
  Member} uses {\cf equal?}\ to compare \var{obj} with the elements of
\var{l}, while {\cf memv} uses {\cf eqv?}\ and {\cf memq} uses
{\cf eq?}.

If \var{l} is not a plausible list, then it must be such that a
natural number $n$ exists where \var{l} is the first Scheme value of a
plausible prefix of length $n$ such that the car of the last value $x_n$ of that
prefix satisfies the given condition at some time after $t_n$ and before
the procedure returns.  (See section~\ref{listargumentsection}.)

\begin{scheme}
(memp even? '(3 1 4 1 5 9 2 6 5)) \lev (4 1 5 9 2 6 5)

(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
\begin{rationale}
  Although they are ordinarily used as predicates, {\cf memp}, {\cf
    member}, {\cf memv}, {\cf memq}, do not have question marks in
  their names because they return useful values rather than just
  \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{assp}{ predicate al}{procedure}
\proto{assoc}{ obj al}{procedure}
\proto{assv}{ obj al}{procedure}
\proto{assq}{ obj al}{procedure}}

\domain{\var{Al} (for ``association list'') must be a a plausible
  alist or a value according to the conditions specified below.
  \var{Predicate} must be a predicate taking a single argument.}

These procedures find the first pair in \var{al}
whose car field satisfies a given condition, and returns that pair.
If no pair in \var{al} satisfies the condition, then \schfalse{}
(not the empty list) is returned.  {\cf Assp} successively applies
\var{predicate} to the car fields of \var{al} and looks for a pair
for which it returns a true value.  {\cf Assoc}, {\cf assv}, and {\cf
  assq} look for a pair that has \var{obj} as its car {\cf Assoc} uses
{\cf equal?}\ to compare \var{obj} with the car fields of the pairs in
\var{al}, while {\cf assv} uses {\cf eqv?}\ and {\cf assq} uses
{\cf eq?}.

If \var{al} is not a plausible alist, then a natural number $n$ must
exist such that \var{al} is the first Scheme value of a plausible
prefix of length $n$ such that every Scheme value $x_1$ through $x_n$
of that prefix is a pair, and $x_n$ has a pair as its car at some time
after $t_n$, and at some time after that the car of that pair is the
first argument, all before the procedure returns.
(See section~\ref{listargumentsection}.)

\begin{scheme}
(define d '((3 a) (1 b) (4 c)))

(assp even? d) \ev (4 c)
(assp odd? d) \ev (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}

\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

