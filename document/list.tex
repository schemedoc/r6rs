\chapter{List utilities}
\label{listutilities}

This chapter describes the \deflibrary{r6rs lists} library.

\begin{entry}{%
\proto{find}{ proc list}{procedure}}

\domain{\var{Proc} must be a procedure; it must take a single argument
  if \var{list} is non-empty.}  The {\cf find} procedure applies
\var{proc} to the elements of \var{list} in order.  If
\var{proc} returns a true value for an element, {\cf find}
immediately returns that element.  If \var{proc} returns
\schfalse{} for all elements of the list, it returns \schfalse{}.

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev 4
(find even? '(3 1 5 1 5 9)) \ev \schfalse{}
\end{scheme}
  
\end{entry}

\begin{entry}{%
\proto{forall}{ proc \vari{l} \varii{l} \dotsfoo{} \varn{l}}{procedure}
\proto{exists}{ proc \vari{l} \varii{l} \dotsfoo{} \varn{l}}{procedure}}

\domain{Each \var{l} must be the
  empty list or a chain of pairs according to the conditions specified
  below.  \var{Proc} must be a procedure; it must take as many
  arguments as there are \var{l}s if \vari{l} is non-empty.}

For natural numbers $i = 0, 1, \ldots$, the {\cf forall} procedure
successively applies \var{proc} to arguments $x_i^1 \ldots x_i^n$,
where $x_i^j$ is the $i$th element of \varj{l}, until \schfalse{} is
returned.  If \var{proc} returns true values for all but the last
element of \vari{l}, \var{forall} performs a tail call of \var{proc}
on the $k$th elements, where $k$ is the length of \vari{l}---in this
case, the \var{l}s must all be lists of length $k$.  If \var{proc}
returns \schfalse{} on any set of elements, {\cf forall} returns
\schfalse{} after the first such application of \var{proc} without
further traversing the \var{l}s.  If the \var{l}s are all empty, {\cf
  forall} returns \schtrue.

For natural numbers $i = 0, 1, \ldots$, the {\cf exists} procedure
applies \var{proc} successively to arguments $x_i^1 \ldots x_i^n$,
where $x_i^j$ is the $i$th element of \varj{l}, until \schtrue{} is
returned.  If \var{proc} returns \schfalse{} for all but the last
elements of the \var{l}s, \var{exists} performs a tail call of
\var{proc} on the $k$th elements, where $k$ is the length of
\vari{l}---in this case, the \var{l}s must all be lists of length $k$.
If \var{proc} returns a true value on any set of elements, {\cf
  exists} returns that value after the first such application of
\var{proc} without further traversing the \var{l}s.  If the \var{l}s
are all empty, {\cf exists} returns \schfalse.

\begin{scheme}
(forall even? '(3 1 4 1 5 9)) \ev \schfalse{}
(forall even? '(3 1 4 1 5 9 . 2)) \ev \schfalse{}
(forall even? '(2 1 4 14)) \ev \schtrue{}
(forall even? '(2 1 4 14 . 9)) \lev \exception{\cf\&contract}
(forall (lambda (n) (and (even? n) n)) '(2 1 4 14)) \lev 14
(forall < '(1 2 3) '(2 3 4)) \ev \schtrue{}
(forall < '(1 2 4) '(2 3 4)) \ev \schfalse{}

(exists even? '(3 1 4 1 5 9)) \ev \schtrue{}
(exists even? '(3 1 1 5 9)) \ev \schfalse{}
(exists even? '(3 1 1 5 9 . 2)) \lev \exception{\cf\&contract}
(exists (lambda (n) (and (even? n) n)) '(2 1 4 14)) \lev 2
(exists < '(1 2 4) '(2 3 4)) \ev \schtrue{}
(exists > '(1 2 3) '(2 3 4)) \ev \schfalse{}
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{filter}{ proc list}{procedure}
\proto{partition}{ proc list}{procedure}
}

\domain{\var{Proc} must be a procedure; it must take a single argument
  if \var{list} is non-empty.}  The {\cf filter} procedure successively applies
\var{proc} to the elements of \var{list} and returns a list of
the values of \var{list} for which \var{proc} returned a true
value.  The {\cf partition} procedure also successively applies \var{proc} to
the elements of \var{list}, but returns two values, the first one a
list of the values of \var{list} for which \var{proc} returned a
true value, and the second a list of the values of \var{list} for
which \var{proc} returned \schfalse.

\begin{scheme}
(filter even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6) (3 1 1 5 9) ; two values
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{fold-left}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{If
  more than one \var{list} is given, then they must all be the same
  length.  \var{kons} must be a
  procedure; if the \var{list}s are non-empty, it must take one more
  argument than there are {\it list}s.}
The {\cf fold-left} procedure iterates the \var{kons} procedure over an
accumulator value and the values of the {\it list}s from left to
right, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-left} returns \var{nil} if the {\it list}s are
empty.  If they are not empty, \var{kons} is first applied to
\var{nil} and the respective first elements of the {\it list}s in
order.  The result becomes the new accumulator value, and \var{kons}
is applied to new accumulator value and the respective next elements
of the {\it list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

\begin{scheme}
(fold-left + 0 '(1 2 3 4 5)) \ev 15

(fold-left (lambda (a e) (cons e a)) '()
           '(1 2 3 4 5)) \lev (5 4 3 2 1)

(fold-left (lambda (x count)
             (if (odd? x) (+ count 1) count))
           0
           '(3 1 4 1 5 9 2 6 5)) \lev 6

(fold-left (lambda (max-len s)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer")) \lev 7

(fold-left cons '(q) '(a b c)) \lev ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{fold-right}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{ If
  more than one \var{list} is given, then they must all be the same
  length.  \var{kons} must be a
  procedure; if the \var{list}s are non-empty, it must take one more
  argument than there are {\it list}s.}
The {\cf fold-right} procedure iterates the \var{kons} procedure over
the values of the {\it list}s from right to left and an accumulator
value, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-right} returns \var{nil} if the {\it list}s
are empty.  If they are not empty, \var{kons} is first applied to the
respective last elements of the {\it list}s in order and \var{nil}.
The result becomes the new accumulator value, and \var{kons} is
applied to the respective previous elements of the {\it list} and the
new accumulator value.  This step is repeated until the beginning of the
list is reached; then the accumulator value is returned.

\begin{scheme}
(fold-right + 0 '(1 2 3 4 5)) \ev 15

(fold-right cons '() '(1 2 3 4 5)) \lev (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5))
\ev (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c)) \lev (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{remp}{ proc list}{procedure}
\proto{remove}{ obj list}{procedure}
\proto{remv}{ obj list}{procedure}
\proto{remq}{ obj list}{procedure}}

\domain{\var{Proc} must be a procedure; it must take a single argument
  if \var{list} is non-empty.}
Each of these procedures returns a list of the elements of \var{list}
that do not satisfy a given condition.  The {\cf remp} procedure successively
applies \var{proc} to the elements of \var{list} and returns a
list of the values of \var{list} for which \var{proc} returned
\schfalse.  The {\cf remove}, {\cf remv}, and {\cf remq} procedures return a list of
the elements that are not \var{obj}.  The {\cf remq} procedure uses {\cf eq?}\ to
compare \var{obj} with the elements of \var{list}, while {\cf remv}
uses {\cf eqv?}\ and {\cf remove} uses {\cf equal?}.

\begin{scheme}
(remp even? '(3 1 4 1 5 9 2 6 5)) \lev (3 1 1 5 9 5)

(remove 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz)) \ev (bar baz)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{memp}{ proc l}{procedure}
\proto{member}{ obj l}{procedure}
\proto{memv}{ obj l}{procedure}
\proto{memq}{ obj l}{procedure}
}

\domain{\var{Proc} must be a procedure; it must take a single argument
  if \var{l} is non-empty.
  \var{l} must be the empty list or a chain of pairs of size according
to the conditions stated below.}

These procedures return the first sublist of \var{l} whose car
satisfies a given condition, where the subchains of \var{l} are the
chains of pairs returned by {\tt (list-tail \var{l} \var{k})} for
\var{k} less than the length of \var{l}.  The {\cf memp} procedure applies
\var{proc} to the cars of the sublists of \var{l} until it
finds one for which \var{proc} returns a true value without traversing
\var{l} further.  The {\cf
  member}, {\cf memv}, and {\cf memq} procedures look for the first occurrence of
\var{obj}.  If \var{l} does not contain an element satisfying the
condition, then \schfalse{} (not the empty list) is returned; in that
case, \var{l} must be a list.  The {\cf
  member} procedure uses {\cf equal?}\ to compare \var{obj} with the elements of
\var{l}, while {\cf memv} uses {\cf eqv?}\ and {\cf memq} uses
{\cf eq?}.

\begin{scheme}
(memp even? '(3 1 4 1 5 9 2 6 5)) \lev (4 1 5 9 2 6 5)

(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
\begin{rationale}
  Although they are ordinarily used as predicates, {\cf memp}, {\cf
    member}, {\cf memv}, {\cf memq}, do not have question marks in
  their names because they return useful values rather than just
  \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{assp}{ proc al}{procedure}
\proto{assoc}{ obj al}{procedure}
\proto{assv}{ obj al}{procedure}
\proto{assq}{ obj al}{procedure}}

\domain{\var{Al} (for ``association list'') must be the empty list or
  a chain of pairs where each car contains a pair of size according to
  the conditions specified below.  \var{Proc} must be a procedure; it
  must take a single argument if \var{al} is non-empty.}

These procedures find the first pair in \var{al}
whose car field satisfies a given condition, and returns that pair
without traversing \var{al} further.
If no pair in \var{al} satisfies the condition, then \schfalse{}
is returned; in that case, \var{al} must be a
list.  The {\cf assp} procedure successively applies
\var{proc} to the car fields of \var{al} and looks for a pair
for which it returns a true value.  The {\cf assoc}, {\cf assv}, and {\cf
  assq} procedures look for a pair that has \var{obj} as its car.  The
{\cf assoc} procedure uses 
{\cf equal?}\ to compare \var{obj} with the car fields of the pairs in
\var{al}, while {\cf assv} uses {\cf eqv?}\ and {\cf assq} uses
{\cf eq?}.


\begin{scheme}
(define d '((3 a) (1 b) (4 c)))

(assp even? d) \ev (4 c)
(assp odd? d) \ev (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}

\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

