\section{List utilities}
\label{listutilities}

%% FIXME: clarify if predicates need to return a boolean, or can
%% return anything

\begin{entry}{%
\proto{find}{ predicate list}{library procedure}}

\domain{\var{Predicate} must be a predicate taking a single argument,
  and \var{list} must be a list.}  {\cf Find} applies
\var{predicate} to the elements of \var{list} in order.  If
\var{predicate} returns a true value for an element, {\cf find}
immediately returns that element.  If \var{predicate} returns
\schfalse{} for all elements of the list, it returns \schfalse{}

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev 4
(find even? '(3 1 5 1 5 9)) \ev \schfalse{}
\end{scheme}
  
\end{entry}

\begin{entry}{%
\proto{forall}{ predicate \vari{list} \varii{list} \dotsfoo}{library procedure}}

\domain{The \var{list}s must be lists, and \var{predicate} must be a
  predicate taking as many arguments as there are {\it list}s. If more
  than one \var{list} is given, then they must all be the same
  length.}  {\cf Forall} applies \var{predicate} element-wise to the
elements of the \var{list}s.  If \var{predicate} returns \schtrue{}
for all but the last elements of the list, \var{forall} performs a
tail call of \var{predicate} on the last elements.  If \var{predicate}
returns \schfalse{} on any set of elements, {\cf forall} returns
\schfalse{} after the first such application of \var{predicate}.  If
the \var{list}s are all empty, {\cf forall} returns \schtrue.

{\cf Exists} applies \var{predicate} element-wise to the
elements of the \var{list}s.  If \var{predicate} returns \schfalse{}
for all but the last elements of the list, \var{exists} performs a
tail call of \var{predicate} on the last elements.  If \var{predicate}
returns a true value on any set of elements, {\cf exists} returns
that value after the first such application of \var{predicate}.  If
the \var{list}s are all empty, {\cf exists} returns \schfalse.

\begin{scheme}
(forall even? '(3 1 4 1 5 9)) \ev \schfalse{}
(forall even? '(2 1 4 14)) \ev \schtrue{}
(forall (lambda (n) (and (even? n) n)) '(2 1 4 14) \ev 14

(exists even? '(3 1 4 1 5 9)) \ev \schtrue{}
(exists even? '(3 1 1 5 9)) \ev \schfalse{}
(exists (lambda (n) (and (even? n) n)) '(2 1 4 14) \ev 2
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{find}{ predicate \vari{list} \varii{list} \dotsfoo}{library procedure}}
\domain{The \var{list}s must be lists, and \var{predicate} must be a
  predicate taking as many arguments as there are {\it list}s. If more
  than one \var{list} is given, then they must all be the same
  length.}  

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev \schfalse{}
(find even? '(3 1 4 1 5 9)) \ev 4
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{filter}{ predicate list}{library procedure}
\proto{partition}{ predicate list}{library procedure}
}

\domain{\var{Predicate} must be a predicate taking a single argument,
  and \var{list} must be a list.}  {\cf Filter} successively applies
\var{predicate} to the elements of \var{list} and returns a list of
the values of \var{list} for which \var{predicate} returned a true
value.  {\cf Partition} also successively applies \var{predicate} to
the elements of \var{list}, but returns two values, the first one a
list of the values of \var{list} for which \var{predicate} returned a
true value, and the second a list of the values of \var{list} for
which \var{predicate} returned \schfalse.

\begin{scheme}
(filter even? '(3 1 4 1 5 9 2 6)) \ev (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6) (3 1 1 5 9) ; two values
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{fold-left}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{library procedure}}

\domain{The \var{list}s must be lists, and \var{kons} must be a
  procedure taking as one more argument than there are {\it list}s. If
  more than one \var{list} is given, then they must all be the same
  length.}  {\cf Fold-left} iterates the \var{kons} procedure over an
accumulator value and the values of the {\it list}s from left to
right, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-left} returns \var{nil} if the {\it list}s are
empty.  If they are not empty, \var{kons} is first applied to
\var{nil} and the respective first elements of the {\it list}s in
order.  The result becomes the new accumulator value, and \var{kons}
is applied to new accumulator value and the respective next elements
of the {\it list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

\begin{scheme}
(fold-left + 0 '(1 2 3 4 5) \ev 15

(fold-left cons '() '(1 2 3 4 5) \lev (5 4 3 2 1)

(fold-left (lambda (x count)
             (if (odd? x) (+ count 1) count))
           0
           '(3 1 4 1 5 9 2 6 5) \lev 6

(fold-left (lambda (s max-len)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer")) \lev 7

(fold-left cons '(q) '(a b c) \lev ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{fold-right}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{library procedure}}

\domain{The \var{list}s must be lists, and \var{kons} must be a
  procedure taking as one more argument than there are {\it list}s. If
  more than one \var{list} is given, then they must all be the same
  length.}  {\cf Fold-right} iterates the \var{kons} procedure over
the values of the {\it list}s from right to left and an accumulator
value, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-right} returns \var{nil} if the {\it list}s
are empty.  If they are not empty, \var{kons} is first applied to the
respective last elements of the {\it list}s in order and \var{nil}.
The result becomes the new accumulator value, and \var{kons} is
applied to the respective previous elements of the {\it list} and the
new accumulator value.  This step is repeated until the beginning of the
list is reached; then the accumulator value is returned.

\begin{scheme}
(fold-right + 0 '(1 2 3 4 5) \ev 15

(fold-right cons '() '(1 2 3 4 5)) \lev (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5)
\ev (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c)) \lev (a b c q)

(fold-right + 0 '(1 2 3) (4 5 6)) \lev 21
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{remp}{ predicate list}{library procedure}
\proto{remove}{ obj list}{library procedure}
\proto{remv}{ obj list}{library procedure}
\proto{remq}{ obj list}{library procedure}}

\domain{\var{Predicate} must be a predicate taking a single argument.}
Each of these procedures returns a list of the elements of \var{lists}
that do not satisfy a given condition.  {\cf Remp} successively
applies \var{predicate} to the elements of \var{list} and returns a
list of the values of \var{list} for which \var{predicate} returned
\schfalse.  {\cf Remove}, {\cf remv}, and {\cf remq} returns a list of
the elements that are not \var{obj}.  {\cf Remq} uses {\cf eq?}\ to
compare \var{obj} with the elements of \var{list}, while {\cf remv}
uses {\cf eqv?}\ and {\cf remove} uses {\cf equal?}.

\begin{scheme}
(remp even? '(3 1 4 1 5 9 2 6 5)) \lev (3 1 1 5 9 2 5)

(remove 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz)) \ev (bar baz)
\end{scheme}
\end{entry}

%% FIXME: remove redundany with core

\begin{entry}{%
\proto{memp}{ predicate list}{library procedure}
\proto{member}{ obj list}{library procedure}
\proto{memv}{ obj list}{library procedure}
\proto{memq}{ obj list}{library procedure}
}

\domain{\var{Predicate} must be a predicate taking a single argument.}
These procedures return the first sublist of \var{list} whose car
satisfies a given condition, where the sublists of \var{list} are the
non-empty lists returned by {\tt (list-tail \var{list} \var{k})} for
\var{k} less than the length of \var{list}..  {\cf Memp} applies
\var{predicate} to the cars of the sublists of \var{list} until it
finds one for which \var{predicate} returns a true value.  {\cf
  Member}, {\cf memv}, and {\cf memq} look for the first occurrence of
\var{obj}.  If \var{list} does not contain an element satisfying the
condition, then \schfalse{} (not the empty list) is returned.  {\cf
  Member} uses {\cf equal?}\ to compare \var{obj} with the elements of
\var{list}, while {\cf memv} uses {\cf eqv?}\ and {\cf memq} uses
{\cf eq?}.

\begin{scheme}
(memp even? '(3 1 4 1 5 9 2 6 5)) \lev (4 1 5 9 2 6 5)

(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
\begin{rationale}
  Although they are ordinarily used as predicates, {\cf memp}, {\cf
    member}, {\cf memv}, {\cf memq}, do not have question marks in
  their names because they return useful values rather than just
  \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{assp}{ predicate alist}{library procedure}
\proto{assoc}{ obj alist}{library procedure}
\proto{assv}{ obj alist}{library procedure}
\proto{assq}{ obj alist}{library procedure}}

\domain{\var{Alist} (for ``association list'') must be a list of
  pairs.  \var{Predicate} must be a predicate taking a single
  argument.}  These procedures find the first pair in \var{alist}
whose car field satisfies a given condition, and returns that pair.
If no pair in \var{alist} satisfies the condition, then \schfalse{}
(not the empty list) is returned.  {\cf Assp} successively applies
\var{predicate} to the car fields of \var{alist} and looks for a pair
for which it returns a true value.  {\cf Assoc}, {\cf assv}, and {\cf
  assq} look for a pair that has \var{obj} as its car {\cf Assoc} uses
{\cf equal?}\ to compare \var{obj} with the car fields of the pairs in
\var{alist}, while {\cf assv} uses {\cf eqv?}\ and {\cf assq} uses
{\cf eq?}.

\begin{scheme}
(define d '((3 a) (1 b) (4 c)))

(assp even? d) \ev (4 c)
(assp odd? d) \ev (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}

\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

