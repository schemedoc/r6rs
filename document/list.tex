\chapter{List utilities}
\label{listutilities}

This chapter describes the \deflibrary{r6rs lists} library.

\begin{entry}{%
\proto{find}{ proc list}{procedure}}

\domain{\var{Proc} shall be a procedure; it shall take a single argument
  if \var{list} is non-empty.}  The {\cf find} procedure applies
\var{proc} to the elements of \var{list} in order.  If
\var{proc} returns a true value for an element, {\cf find}
immediately returns that element.  If \var{proc} returns
\schfalse{} for all elements of the list, it returns \schfalse{}.

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev 4
(find even? '(3 1 5 1 5 9)) \ev \schfalse{}
\end{scheme}
  
\end{entry}

\begin{entry}{%
\proto{forall}{ proc \vari{l} \varii{l} \dotsfoo}{procedure}
\proto{exists}{ proc \vari{l} \varii{l} \dotsfoo}{procedure}}

\domain{The \var{l}s shall all be the empty list, or chains of pairs of
  sizes according to the condition specified below.
  \var{Proc} shall be a procedure; it shall take a single argument if
  the \var{l}s are non-empty.}

The {\cf forall} procedure applies \var{proc} element-wise to the
elements of the \var{l}s.  If \var{proc} returns \schtrue{}
for all but the last elements of the \var{l}s, \var{forall} performs a
tail call of \var{proc} on the last elements---in this case, the
\var{l}s shall all be lists.  If \var{proc}
returns \schfalse{} on any set of elements, {\cf forall} returns
\schfalse{} after the first such application of \var{proc} without
further traversing the \var{l}s.  If
the \var{l}s are all empty, {\cf forall} returns \schtrue.

The {\cf exists} procedure applies \var{proc} element-wise to the
elements of the \var{l}s.  If \var{proc} returns \schfalse{}
for all but the last elements of the \var{l}s, \var{exists} performs a
tail call of \var{proc} on the last elements---in this case, the
\var{l}s shall all be lists.  If \var{proc}
returns a true value on any set of elements, {\cf exists} returns
that value after the first such application of \var{proc} without
further traversing the \var{l}s.  If
the \var{l}s are all empty, {\cf exists} returns \schfalse.


\begin{scheme}
(forall even? '(3 1 4 1 5 9)) \ev \schfalse{}
(forall even? '(3 1 4 1 5 9 . 2)) \ev \schfalse{}
(forall even? '(2 1 4 14)) \ev \schtrue{}
(forall even? '(2 1 4 14 . 9)) \ev \exception{\cf\&contract}
(forall (lambda (n) (and (even? n) n)) '(2 1 4 14) \lev 14

(exists even? '(3 1 4 1 5 9)) \ev \schtrue{}
(exists even? '(3 1 1 5 9)) \ev \schfalse{}
(exists even? '(3 1 1 5 9 . 2)) \ev \exception{\cf\&contract}
(exists (lambda (n) (and (even? n) n)) '(2 1 4 14) \lev 2
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{filter}{ proc list}{procedure}
\proto{partition}{ proc list}{procedure}
}

\domain{\var{Proc} shall be a procedure; it shall take a single argument
  if \var{list} is non-empty.}  The {\cf filter} procedure successively applies
\var{proc} to the elements of \var{list} and returns a list of
the values of \var{list} for which \var{proc} returned a true
value.  The {\cf partition} procedure also successively applies \var{proc} to
the elements of \var{list}, but returns two values, the first one a
list of the values of \var{list} for which \var{proc} returned a
true value, and the second a list of the values of \var{list} for
which \var{proc} returned \schfalse.

\begin{scheme}
(filter even? '(3 1 4 1 5 9 2 6)) \ev (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6) (3 1 1 5 9) ; two values
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{fold-left}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{If
  more than one \var{list} is given, then they shall all be the same
  length.  \var{Kons} shall be a
  procedure; if the \var{list}s are non-empty, it shall take one more
  argument than there are {\it list}s.}
The {\cf fold-left} procedure iterates the \var{kons} procedure over an
accumulator value and the values of the {\it list}s from left to
right, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-left} returns \var{nil} if the {\it list}s are
empty.  If they are not empty, \var{kons} is first applied to
\var{nil} and the respective first elements of the {\it list}s in
order.  The result becomes the new accumulator value, and \var{kons}
is applied to new accumulator value and the respective next elements
of the {\it list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

\begin{scheme}
(fold-left + 0 '(1 2 3 4 5) \ev 15

(fold-left cons '() '(1 2 3 4 5) \lev (5 4 3 2 1)

(fold-left (lambda (x count)
             (if (odd? x) (+ count 1) count))
           0
           '(3 1 4 1 5 9 2 6 5) \lev 6

(fold-left (lambda (s max-len)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer")) \lev 7

(fold-left cons '(q) '(a b c) \lev ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{fold-right}{ kons nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{ If
  more than one \var{list} is given, then they shall all be the same
  length.\var{Kons} shall be a
  procedure; if the \var{list}s are non-empty, it shall take one more
  argument than there are {\it list}s.}
The {\cf fold-right} procedure iterates the \var{kons} procedure over
the values of the {\it list}s from right to left and an accumulator
value, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-right} returns \var{nil} if the {\it list}s
are empty.  If they are not empty, \var{kons} is first applied to the
respective last elements of the {\it list}s in order and \var{nil}.
The result becomes the new accumulator value, and \var{kons} is
applied to the respective previous elements of the {\it list} and the
new accumulator value.  This step is repeated until the beginning of the
list is reached; then the accumulator value is returned.

\begin{scheme}
(fold-right + 0 '(1 2 3 4 5) \ev 15

(fold-right cons '() '(1 2 3 4 5)) \lev (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5)
\ev (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c)) \lev (a b c q)

(fold-right + 0 '(1 2 3) (4 5 6)) \lev 21
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{remp}{ proc list}{procedure}
\proto{remove}{ obj list}{procedure}
\proto{remv}{ obj list}{procedure}
\proto{remq}{ obj list}{procedure}}

\domain{\var{Proc} shall be a procedure; it shall take a single argument
  if \var{list} is non-empty.}
Each of these procedures returns a list of the elements of \var{list}
that do not satisfy a given condition.  The {\cf remp} procedure successively
applies \var{proc} to the elements of \var{list} and returns a
list of the values of \var{list} for which \var{proc} returned
\schfalse.  The {\cf remove}, {\cf remv}, and {\cf remq} procedures return a list of
the elements that are not \var{obj}.  The {\cf remq} procedure uses {\cf eq?}\ to
compare \var{obj} with the elements of \var{list}, while {\cf remv}
uses {\cf eqv?}\ and {\cf remove} uses {\cf equal?}.

\begin{scheme}
(remp even? '(3 1 4 1 5 9 2 6 5)) \lev (3 1 1 5 9 2 5)

(remove 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz)) \ev (bar baz)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{memp}{ proc l}{procedure}
\proto{member}{ obj l}{procedure}
\proto{memv}{ obj l}{procedure}
\proto{memq}{ obj l}{procedure}
}

\domain{\var{Proc} shall be a procedure; it shall take a single argument
  if \var{l} is non-empty.
  \var{L} shall be the empty list or a chain of pairs of size according
to the conditions stated below.}

These procedures return the first sublist of \var{l} whose car
satisfies a given condition, where the subchains of \var{l} are the
chains of pairs returned by {\tt (list-tail \var{l} \var{k})} for
\var{k} less than the length of \var{l}.  The {\cf memp} procedure applies
\var{proc} to the cars of the sublists of \var{l} until it
finds one for which \var{proc} returns a true value without traversing
\var{l} further.  {\cf
  Member}, {\cf memv}, and {\cf memq} look for the first occurrence of
\var{obj}.  If \var{l} does not contain an element satisfying the
condition, then \schfalse{} (not the empty list) is returned; in that
case, \var{l} shall be a list.  {\cf
  Member} uses {\cf equal?}\ to compare \var{obj} with the elements of
\var{l}, while {\cf memv} uses {\cf eqv?}\ and {\cf memq} uses
{\cf eq?}.

\begin{scheme}
(memp even? '(3 1 4 1 5 9 2 6 5)) \lev (4 1 5 9 2 6 5)

(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
\begin{rationale}
  Although they are ordinarily used as predicates, {\cf memp}, {\cf
    member}, {\cf memv}, {\cf memq}, do not have question marks in
  their names because they return useful values rather than just
  \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{assp}{ proc al}{procedure}
\proto{assoc}{ obj al}{procedure}
\proto{assv}{ obj al}{procedure}
\proto{assq}{ obj al}{procedure}}

\domain{\var{Al} (for ``association list'') shall be the empty list or
  a chain of pairs where each car contains a pair of size according to
  the conditions specified below.  \var{Proc} shall be a procedure; it
  shall take a single argument if \var{al} is non-empty.}

These procedures find the first pair in \var{al}
whose car field satisfies a given condition, and returns that pair
without traversing \var{al} further.
If no pair in \var{al} satisfies the condition, then \schfalse{}
(not the empty list) is returned; in that case, \var{al} shall be a
list.  The {\cf assp} procedure successively applies
\var{proc} to the car fields of \var{al} and looks for a pair
for which it returns a true value.  The {\cf assoc}, {\cf assv}, and {\cf
  assq} procedures look for a pair that has \var{obj} as its car.  The
{\cf assoc} procedure uses 
{\cf equal?}\ to compare \var{obj} with the car fields of the pairs in
\var{al}, while {\cf assv} uses {\cf eqv?}\ and {\cf assq} uses
{\cf eq?}.


\begin{scheme}
(define d '((3 a) (1 b) (4 c)))

(assp even? d) \ev (4 c)
(assp odd? d) \ev (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}

\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 

