Formal comment #129 (enhancement)

Provide a way to define nongenerative records without specifying <uid>
Reported by:	Abdulaziz Ghuloum

Component:	records
Version:	5.91

One sentence summary: The syntactic layers of the records facility
should provide a mechanism for creating nongenerative records with an
automatically generated <uid> (generated by the expander).

Description: 

The current (5.91) draft of the report (page 70) specifies that the
only way one can construct nongenerative records through the syntactic
layers is by specifying a (nongenerative <uid>) for some unique
identifier <uid>. The draft then explains the semantics of what
happens when two records definitions with the same <uid> are found in
the running Scheme environment. It also specifies that if the
(nongenerative <uid>) form is missing, then the record type is
generative.

This is all fine; but alas, it does not capture all uses of
nongenerative records.

From my experience, the main use of records with a user-specified
<uid> is when the program contains two different record definitions
with the same <uid> and it is the programmer's intention that the two
records definitions should produce records of the same type (and
therefore fully compatible). This can occur for example when one
defines multiple libraries that operate on the same record types. One
can place all record definitions in one file, and "include" the
definition file in every library that uses these records. This
guarantees that the libraries work seamlessly together.

Also from my experience is the case where one wishes to create a
nongenerative record type that must be different from every other
record type that exists in the system. Programmers defining these
record types do not care about what <uid> is assigned. As a matter of
fact, the existence of a (nongenerative <uid>) form in the record
definition may signal to the programmer that the record type may
actually be shared by other parts of the system (as in case 1 above).

Having to specify the <uid> when defining the record makes the
intention of the programmer ambiguous. Did the programmer mean to
specify this exact <uid>? Or was it just a random sequence of
characters?

For example, consider the example given in page 70 of the draft:

(define-record-type (point3 make-point3 point3?) 
  (fields (immutable x point3-x) 
          (mutable y point3-y set-point3-y!)) 
  (nongenerative point3-4893d957-e00b-11d9-817f-00111175ebe9)) 

In addition to polluting the code with very useless noise, the above
long sequence could hinder maintenance and introduce the need for uuid
management that is generally not needed. I really don't want to
generate names that I don't use; I don't want to see such long
sequences of junk in my code; and I don't want to use uuidgen to
generate these sequences for me. [Oh yes, and I don't want to redefine
define-record-type to do what I'm about to recommend since I believe
it is useful and minor addition to the syntax.]

Recommendation: 

Provide a way of defining nongenerative records without having to
specify a specific <uid>. The macro expander can generate the <uid>
for me if I don't care about what the <uid> is. I recommend using
(nongenerative #t) to mean just that: a nongenerative record
definition. (nongenerative <uid>) still means a nongenerative record
with the specific <uid>. The above example becomes:

(define-record-type (point3 make-point3 point3?) 
  (fields (immutable x point3-x) 
          (mutable y point3-y set-point3-y!)) 
  (nongenerative #t))

RESPONSE:

We have adopted the proposal, albeit with a clause syntax

(nongenerative)

instead of

(nongenerative #t)

ISSUES:

- We need to talk about corner cases, such as macros expanding into
  record-type definitions, or `eval' on expressions containing
  record-type definitions.

- With this change, the explicit-naming layer is no longer
  implementable with `syntax-rules' alone.
