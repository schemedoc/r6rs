Ticket #8 (defect)

Unclear how equality predicates behave on NaN
Status: new
Reported by:	Per Bothner
Assigned to:	will
Priority:	major
Component:	arithmetic
Version:	5.91
Keywords:	
Cc:	

9.10.2 Numerical operations p 39 

Arithmetic operations 

= explicitly specifies the behavior for +inf.0 and -inf.0, but not for
+nan.0. Implicitly, if any operand is +nan.0, then the result should
be #f, and this follows IEEE-754. However, it should be stated
explicitly. (The same is also true for <, >, <= and >=.)

However, in that case the specification of eqv? (9.6 p 35) is
wrong. It says that (eqv? x y) implies that (= x y) for numbers. This
is wrong: (eqv? +nan.0 +nan.0) must return #t. This follows because we
really need (let ((x +nan.0)) (eq? x x)) to be #t.

If x and y are flonums of the same resolution/implementation, then a
reasonable definition of (eqv? x y) is that it is true if and only y
are bit-for-bit equal.

DRAFT RESPONSE

An example should be added to indicate that (= +nan.0 x) is false for
any x. Similar examples could be added for some of the other numerical
predicates.

Contrary to ticket #8, the specification of eqv? does not say that
(eqv? x y) implies (= x y) when x and y are numbers.

Ticket #8 gives no reason in support of its statement that (let ((x +nan.0)) (eq? x x)) needs to be true. The R5RS does not guarantee that (let ((x z)) (eq? x x)) will be true when z is a number, and we see no reason for the R6RS to require it to be true in the special case where z is a NaN. 

When x and y are flonums that are represented in IEEE floating point
or similar, it is reasonable to implement (eq? x y) by a bitwise
comparison of the floating point representations, but the R6RS should
not require this, partly because the R6RS does not require that
flonums be represented by a floating point representation.

