Ticket #61 (defect)

Last modified 1 hour ago
Expansion process violates lexical scoping
Status: new
Reported by:	Andre van Tonder
Assigned to:	dyb
Priority:	major
Component:	macros
Version:	5.91
Keywords:	
Cc:	

Component : Expansion process 

Pages : 27-28 

Dependencies: Section 9.4 (Bodies and sequences) 

Description

According to r6rs, the expression 

  (let ((x #f))
   (let-syntax ((foo (syntax-rules (x)
                       ((_ x y) (define y 'outer))
                       ((_ _ y) (define y 'inner)))))
     (let ()
       (foo x p)
       (define x #f)
       p)))

evaluates to "outer", whereas it would evaluate to "inner" if the
definition preceded (foo x p). This violates lexical scoping.

The following example, in addition to violating lexical scoping

  (let ((x #f))
    (let-syntax ((foo (syntax-rules (x)
                        ((_ x y) (define y 'outer))
                        ((_ _ y) 1))))
      (let ()
        (foo x p)
        (define x #f)
        p)))              ==> outer (wrong)

also violates the spirit (if not the letter) of the first paragraph on
p. 28: "It is a syntax violation if the keyword that identifies one of
the body forms as a definition (derived or core) is redefined by the
same definition or a later definition in the same body."

However, this violation of the spirit will not be detected by the
algorithm described in the same paragraph.

Suggestion

The algorithm described in the first paragraph of p.28 may also have
to record the arguments of each use of free-identifier=?. This is,
however, likely to be expensive.

DRAFT RESPONSE

We agree that this is a problem.  We also agree that recording the
arguments of each use of free-identifier=? is likely to be expensive. 
Furthermore, doing so may cause programs that do not violate either the
letter or spirit of the text to be rejected.

We believe that the right approach in this case is to specify that
programs such as the ones appearing in the formal comment are "in error"
and that the implementation "should" raise an exception, i.e.,
encourage but not require implementations to raise an exception.

Description of a possible expansion algorithm remains useful, but the
accompanying text should be clarified to describe the limitations of the
given algorithm.

DRAFT RESPONSE:

Tracking free-identifier=? calls is indeed potentially expensive and may
cause programs that do not violate either the letter or spirit of the text
to be rejected.  R5.92RS will include text that prohibits such programs
and say that implementations "should" raise an exception, while keeping
the left-to-right expansion order.  R5.92RS will also retain the detailed
algorithm description as an example of a possible algorithm, but explain
its limitations.
